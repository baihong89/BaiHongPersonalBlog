<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>proxy适用场景</title>
      <link href="/371.html"/>
      <url>/371.html</url>
      
        <content type="html"><![CDATA[<p><code>proxy</code> 在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">文档查阅</a></p><p>Proxy 是一种代理模式，常用于三个方面：</p><ul><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul><p>正因为此，可以做一些中间件相关的事情。</p><h2 id="抽离校验模块"><a href="#抽离校验模块" class="headerlink" title="抽离校验模块"></a>抽离校验模块</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  pickyMethodOne: <span class="function"><span class="keyword">function</span>(<span class="params">obj, str, num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  pickyMethodTwo: <span class="function"><span class="keyword">function</span>(<span class="params">num, obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> argTypes = &#123;</span><br><span class="line">  pickyMethodOne: [<span class="string">'object'</span>, <span class="string">'string'</span>, <span class="string">'number'</span>],</span><br><span class="line">  pickyMethodTwo: [<span class="string">'number'</span>, <span class="string">'object'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, key, proxy) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> checkArgs = argChecker(key, args, argTypes[key]);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(value, target, args);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argChecker</span>(<span class="params">name, args, checkers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> idx = <span class="number">0</span>; idx &lt; args.length; idx++) &#123;</span><br><span class="line">    <span class="keyword">var</span> arg = args[idx];</span><br><span class="line">    <span class="keyword">var</span> type = checkers[idx];</span><br><span class="line">    <span class="keyword">if</span> (!arg || <span class="keyword">typeof</span> arg !== type) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`You are incorrectly implementing the signature of <span class="subst">$&#123;name&#125;</span>. Check param <span class="subst">$&#123;idx + <span class="number">1</span>&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.pickyMethodOne();</span><br><span class="line">obj.pickyMethodTwo(<span class="string">'wopdopadoo'</span>, &#123;&#125;);</span><br><span class="line">obj.pickyMethodOne(&#123;&#125;, <span class="string">'a little string'</span>, <span class="number">123</span>);</span><br><span class="line">obj.pickyMethodOne(<span class="number">123</span>, &#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> api = &#123;</span><br><span class="line">  _apiKey: <span class="string">'123abc456def'</span>,</span><br><span class="line">  getUsers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  getUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId</span>) </span>&#123;&#125;,</span><br><span class="line">  setUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId, config</span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> RESTRICTED = [<span class="string">'_apiKey'</span>];</span><br><span class="line">api = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key, proxy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (RESTRICTED.indexOf(key) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is restricted. Please see api documentation for further info.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, proxy);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, key, value, proxy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (RESTRICTED.indexOf(key) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is restricted. Please see api documentation for further info.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, value, proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 以下操作都会抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(api._apiKey);</span><br><span class="line">api._apiKey = <span class="string">'987654321'</span>;</span><br></pre></td></tr></table></figure><h2 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> api = &#123;</span><br><span class="line">  _apiKey: <span class="string">'123abc456def'</span>,</span><br><span class="line">  getUsers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  setUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId, config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMethodAsync</span>(<span class="params">timestamp, method</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;timestamp&#125;</span> - Logging <span class="subst">$&#123;method&#125;</span> request asynchronously.`</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">api = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, key, proxy) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...arguments</span>) </span>&#123;</span><br><span class="line">      logMethodAsync(<span class="keyword">new</span> <span class="built_in">Date</span>(), key);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(value, target, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">api.getUsers();</span><br></pre></td></tr></table></figure><h2 id="预警和拦截"><a href="#预警和拦截" class="headerlink" title="预警和拦截"></a>预警和拦截</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataStore = &#123;</span><br><span class="line">  noDelete: <span class="number">1235</span>,</span><br><span class="line">  oldMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  doNotChange: <span class="string">'tried and true'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> NODELETE = [<span class="string">'noDelete'</span>];</span><br><span class="line"><span class="keyword">const</span> NOCHANGE = [<span class="string">'doNotChange'</span>];</span><br><span class="line"><span class="keyword">const</span> DEPRECATED = [<span class="string">'oldMethod'</span>];</span><br><span class="line">dataStore = <span class="keyword">new</span> <span class="built_in">Proxy</span>(dataStore, &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value, proxy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (NOCHANGE.includes(key)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`Error! <span class="subst">$&#123;key&#125;</span> is immutable.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, proxy);</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteProperty(target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (NODELETE.includes(key)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`Error! <span class="subst">$&#123;key&#125;</span> cannot be deleted.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, key);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>(target, key, proxy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEPRECATED.includes(key)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`Warning! <span class="subst">$&#123;key&#125;</span> is deprecated.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> val = target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'function'</span></span><br><span class="line">      ? <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">Reflect</span>.apply(target[key], target, args);</span><br><span class="line">        &#125;</span><br><span class="line">      : val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// these will throw errors or log warnings, respectively</span></span><br><span class="line">dataStore.doNotChange = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">delete</span> dataStore.noDelete;</span><br><span class="line">dataStore.oldMethod();</span><br></pre></td></tr></table></figure><h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  getGiantFile: <span class="function"><span class="keyword">function</span>(<span class="params">fileId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key, proxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> id = args[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">let</span> isEnroute = checkEnroute(id);</span><br><span class="line">      <span class="keyword">let</span> isDownloading = checkStatus(id);</span><br><span class="line">      <span class="keyword">let</span> cached = getCached(id);</span><br><span class="line">      <span class="keyword">if</span> (isEnroute || isDownloading) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cached) &#123;</span><br><span class="line">        <span class="keyword">return</span> cached;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(target[key], target, args);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="中断代理"><a href="#中断代理" class="headerlink" title="中断代理"></a>中断代理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  username: <span class="string">'korey'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(data, &#123;&#125;);</span><br><span class="line"><span class="comment">// logs 'devbryce'</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.username);</span><br><span class="line">revoke();</span><br><span class="line"><span class="comment">// TypeError: Revoked</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.username);</span><br></pre></td></tr></table></figure><h2 id="解决对象属性为-undefined-的问题"><a href="#解决对象属性为-undefined-的问题" class="headerlink" title="解决对象属性为 undefined 的问题"></a>解决对象属性为 undefined 的问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> handlers = &#123;</span><br><span class="line">    <span class="keyword">get</span>: (target, property) =&gt; &#123;</span><br><span class="line">      target[property] = property <span class="keyword">in</span> target ? target[property] : &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> target[property] === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target[property], handlers);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target[property];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handlers);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'z'</span> <span class="keyword">in</span> proxy.x.y); <span class="comment">// false (其实这一步已经针对`target`创建了一个x.y的属性)</span></span><br><span class="line">  proxy.x.y.z = <span class="string">'hello'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'z'</span> <span class="keyword">in</span> proxy.x.y); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(target.x.y.z); <span class="comment">// hello</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="普通函数与构造函数的兼容处理"><a href="#普通函数与构造函数的兼容处理" class="headerlink" title="普通函数与构造函数的兼容处理"></a>普通函数与构造函数的兼容处理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(a, b) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>, a, b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test(1, 2) // throw an error</span></span><br><span class="line"><span class="keyword">let</span> proxyClass = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Test, &#123;</span><br><span class="line">  apply(target, thisArg, argumentsList) &#123;</span><br><span class="line">    <span class="comment">// 如果想要禁止使用非new的方式来调用函数，直接抛出异常即可</span></span><br><span class="line">    <span class="comment">// throw new Error(`Function $&#123;target.name&#125; cannot be invoked without 'new'`)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> (target.bind(thisArg, ...argumentsList))();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxyClass(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// constructor 1 2</span></span><br></pre></td></tr></table></figure><h2 id="包装-fetch"><a href="#包装-fetch" class="headerlink" title="包装 fetch"></a>包装 fetch</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handlers = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, property) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target.init) &#123;</span><br><span class="line">      <span class="comment">// 初始化对象</span></span><br><span class="line">      [<span class="string">'GET'</span>, <span class="string">'POST'</span>].forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">        target[method] = <span class="function">(<span class="params">url, params = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> fetch(url, &#123;</span><br><span class="line">            headers: &#123;</span><br><span class="line">              <span class="string">'content-type'</span>: <span class="string">'application/json'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            mode: <span class="string">'cors'</span>,</span><br><span class="line">            credentials: <span class="string">'same-origin'</span>,</span><br><span class="line">            method,</span><br><span class="line">            ...params</span><br><span class="line">          &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json());</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target[property];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> API = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handlers);</span><br></pre></td></tr></table></figure><h2 id="断言工具"><a href="#断言工具" class="headerlink" title="断言工具"></a>断言工具</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> assert = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, message, value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!value) <span class="built_in">console</span>.error(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">assert[<span class="string">"Isn't true"</span>] = <span class="literal">false</span>; <span class="comment">// Error: Isn't true</span></span><br><span class="line">assert[<span class="string">'Less than 18'</span>] = <span class="number">18</span> &gt;= <span class="number">19</span>; <span class="comment">// Error: Less than 18</span></span><br></pre></td></tr></table></figure><h2 id="统计函数调用次数"><a href="#统计函数调用次数" class="headerlink" title="统计函数调用次数"></a>统计函数调用次数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orginFunction</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyFunction = <span class="keyword">new</span> <span class="built_in">Proxy</span>(orginFunction, &#123;</span><br><span class="line">  apply (target, thisArg. argumentsList) &#123;</span><br><span class="line">    log(XXX)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target.apply(thisArg, argumentsList)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实现双绑比-Object-defineProperty-的优势"><a href="#实现双绑比-Object-defineProperty-的优势" class="headerlink" title="实现双绑比 Object.defineProperty 的优势"></a>实现双绑比 Object.defineProperty 的优势</h2><ul><li>可以直接监听对象而非属性</li><li>可以直接监听数组的变化</li><li>有多达 13 种拦截方法,不限于 <code>apply、ownKeys、deleteProperty、has</code> 等等</li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(转载)了解HTML5中的MutationObserver</title>
      <link href="/370.html"/>
      <url>/370.html</url>
      
        <content type="html"><![CDATA[<p><code>MutationObserver</code> 翻译过来就是变动观察器，字面上就可以理解这是用来观察 <code>Node</code>（节点）变化的。<code>MutationObserver</code> 是在 <code>DOM4</code> 规范中定义的，它的前身是 <code>MutationEvent</code> 事件，该事件最初在 <code>DOM2</code> 事件规范中介绍，到来了 <code>DOM3</code> 事件规范中正式定义，但是由于该事件存在兼容性以及性能上的问题被弃用。<a href="https://caniuse.com/#search=MutationObserver" target="_blank" rel="noopener">兼容性查阅</a></p><p><code>MutationObserver</code> 是一个构造器，接受一个 <code>callback</code> 参数，用来处理节点变化的回调函数。返回两个参数:</p><ul><li><code>mutations</code>：节点变化记录列表（<code>sequence&lt;MutationRecord&gt;</code>）</li><li><code>observer</code>：构造 <code>MutationObserver 对象</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observe = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations, observer</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p><code>MutationObserver</code> 对象有三个方法，分别如下：</p><ul><li><code>observe</code>：设置观察目标，接受两个参数: (<code>target</code>：观察目标，<code>options</code>：通过对象成员来设置观察选项)</li><li><code>disconnect</code>：阻止观察者观察任何改变</li><li><code>takeRecords</code>：清空记录队列并返回里面的内容</li></ul><p>关于 <code>observe</code> 方法中 <code>options</code> 参数有已下几个选项：</p><ul><li><code>childList</code>：设置 <code>true</code>，表示观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化</li><li><code>attributes</code>：设置 <code>true</code>，表示观察目标属性的改变</li><li><code>characterData</code>：设置 <code>true</code>，表示观察目标数据的改变</li><li><code>subtree</code>：设置为 <code>true</code>，目标以及目标的后代改变都会观察</li><li><code>attributeOldValue</code>：如果属性为 <code>true</code> 或者省略，则相当于设置为 <code>true</code>，表示需要记录改变前的目标属性值，设置了 <code>attributeOldValue</code> 可以省略 <code>attributes</code> 设置</li><li><code>characterDataOldValue</code>：如果 <code>characterData</code> 为 <code>true</code> 或省略，则相当于设置为 <code>true</code>,表示需要记录改变之前的目标数据，设置了 <code>characterDataOldValue</code> 可以省略 <code>characterData</code> 设置</li><li><code>attributeFilter</code>：如果不是所有的属性改变都需要被观察，并且 <code>attributes</code> 设置为 <code>true</code> 或者被忽略，那么设置一个需要观察的属性本地名称（不需要命名空间）的列表</li></ul><p>下表描述了 <code>MutationObserver</code> 选项与 <code>MutationEvent</code> 名称之间的对应关系：</p><table><thead><tr><th>MutationEvent</th><th>MutationObserver options</th></tr></thead><tbody><tr><td>DOMNodeInserted</td><td>{ childList: true, subtree: true }</td></tr><tr><td>DOMNodeRemoved</td><td>{ childList: true, subtree: true }</td></tr><tr><td>DOMSubtreeModified</td><td>{ childList: true, subtree: true }</td></tr><tr><td>DOMAttrModified</td><td>{ attributes: true, subtree: true }</td></tr><tr><td>DOMCharacterDataModified</td><td>{ characterData: true, subtree: true }</td></tr></tbody></table><p>从上表我们也可以看出相比与 <code>MutationEvent</code> 而言 <code>MutationObserver</code> 极大地增加了灵活性，可以设置各种各样的选项来满足程序员对目标的观察。</p><p>我们简单看几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"target"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"block"</span> name=<span class="string">"target"</span>&gt;</span><br><span class="line">  target的第一个子节点</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;span&gt;target的后代&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>1.callback 的回调次数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(<span class="string">'target'</span>);</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> observe = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations, observe</span>) </span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;);</span><br><span class="line">observe.observe(target, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.appendChild(docuemnt.createTextNode(<span class="string">'1'</span>));</span><br><span class="line">target.appendChild(docuemnt.createTextNode(<span class="string">'2'</span>));</span><br><span class="line">target.appendChild(docuemnt.createTextNode(<span class="string">'3'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p><code>MutationObserver</code> 的 <code>callback</code> 回调函数是异步的，只有在全部 <code>DOM</code> 操作完成之后才会调用 <code>callback。</code></p><p>2.当只设置<code>{ childList: true}</code>时,表示观察目标子节点的变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observe = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations, observe</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(mutations);</span><br><span class="line">  <span class="comment">//observe.discount();</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observe.observe(target, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'新增 Text 节点'</span>)); <span class="comment">//增加节点，观察到变化</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].remove(); <span class="comment">//删除节点，可以观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].textContent = <span class="string">'改变子节点的后代'</span>; <span class="comment">//不会观察到</span></span><br></pre></td></tr></table></figure><p>如果想要观察到子节点以及后代的变化需设置<code>{childList: true, subtree: true}</code></p><p><code>attributes</code> 选项用来观察目标属性的变化，用法类似与 <code>childList</code>,目标属性的删除添加以及修改都会被观察到。</p><p>3.我们需要注意的是 <code>characterData</code> 这个选项，它是用来观察 <code>CharacterData</code> 类型的节点的，只有在改变节点数据时才会观察到，如果你删除或者增加节点都不会进行观察，还有如果对不是 <code>CharacterData</code> 类型的节点的改变不会观察到，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observe.observe(target, &#123; <span class="attr">characterData</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.childNodes[<span class="number">0</span>].textContent = <span class="string">'改变 Text 节点'</span>; <span class="comment">//观察到</span></span><br><span class="line">target.childNodes[<span class="number">1</span>].textContent = <span class="string">'改变 p 元素内容'</span>; <span class="comment">//不会观察到</span></span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'新增 Text 节点'</span>)); <span class="comment">//不会观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].remove(); <span class="comment">//删除 TEXT 节点也不会观察到</span></span><br></pre></td></tr></table></figure><p>我们只需要记住只有对 <code>CharacterData</code> 类型的节点的数据改变才会被 <code>characterData</code> 为 <code>true</code> 的选项所观察到。</p><p>4.最后关注一个特别有用的选项 <code>attributeFilter</code>，这个选项主要是用来筛选要观察的属性，比如你只想观察目标 <code>style</code> 属性的变化，这时可以如下设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">observe.observe(target, &#123; <span class="attr">attributeFilter</span>: [<span class="string">'style'</span>], <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.style = <span class="string">'color:red'</span>; <span class="comment">//可以观察到</span></span><br><span class="line">target.removeAttribute(<span class="string">'name'</span>); <span class="comment">//删除 name 属性，无法观察到</span></span><br></pre></td></tr></table></figure><p><code>disconnect</code> 方法是用来阻止观察的，当你不再想观察目标节点的变化时可以调用 <code>observe.disconnect()</code> 方法来取消观察。</p><p><code>takeRecords</code> 方法是用来取出记录队列中的记录。它的一个作用是，比如你对一个节点的操作你不想马上就做出反应，过段时间在显示改变了节点的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observe = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">observe.observe(target, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'新增 Text 节点'</span>));</span><br><span class="line"><span class="keyword">var</span> record = observe.takeRecords(); <span class="comment">//此时 record 保存了改变记录列表</span></span><br><span class="line"><span class="comment">//当调用 takeRecords 方法时，记录队列被清空因此不会触发 MutationObserver 中的 callback 回调方法。</span></span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'span'</span>));</span><br><span class="line">observe.disconnect(); <span class="comment">//停止对 target 的观察。</span></span><br><span class="line"><span class="comment">//MutationObserver 中的回调函数只有一个记录，只记录了新增 span 元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//之后可以对 record 进行操作</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><code>MutationRecord</code>变动记录中的属性如下：</p><ul><li><code>type</code>：如果是属性变化，返回”attributes”，如果是一个 CharacterData 节点（Text 节点、Comment 节点）变化，返回”characterData”，节点树变化返回”childList”</li><li><code>target</code>：返回影响改变的节点</li><li><code>addedNodes</code>：返回添加的节点列表</li><li><code>removedNodes</code>：返回删除的节点列表</li><li><code>previousSibling</code>：返回分别添加或删除的节点的上一个兄弟节点，否则返回 null</li><li><code>nextSibling</code>：返回分别添加或删除的节点的下一个兄弟节点，否则返回 null</li><li><code>attributeName</code>：返回已更改属性的本地名称，否则返回 null</li><li><code>attributeNamespace</code>：返回已更改属性的名称空间，否则返回 null</li><li><code>oldValue</code>：返回值取决于 type。对于”attributes”，它是更改之前的属性的值。对于”characterData”，它是改变之前节点的数据。对于”childList”，它是 null</li></ul><p>其中 <code>type</code>、<code>target</code> 这两个属性不管是哪种观察方式都会有返回值，其他属性返回值与观察方式有关，比如只有当 <code>attributeOldValue</code> 或者 <code>characterDataOldValue</code> 为 <code>true</code> 时 <code>oldValue</code> <code>才有返回值，只有改变属性时，attributeName</code> 才有返回值等。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unable to preventDefault inside passive event listener due to target being treated as passive</title>
      <link href="/369.html"/>
      <url>/369.html</url>
      
        <content type="html"><![CDATA[<h2 id="事件现象"><a href="#事件现象" class="headerlink" title="事件现象"></a>事件现象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>chrome</code> 控制台报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Intervention] Unable to preventDefault inside passive event listener due to target being treated as passive. See https://www.chromestatus.com/features/5093566007214080</span><br></pre></td></tr></table></figure><p>在<code>document</code>上监听<code>touch</code>类事件时，如果在<code>handler</code>里调用了<code>e.preventDefault()</code>，则会报错：<code>不能给passive(被动的)事件监听器preventDefault，因为它被认为是passive</code></p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p><code>addEventListener()</code>的第三个参数（可选）为以下二选一:</p><ul><li><code>useCapture</code> （<code>boolean</code>,默认值<code>false</code>）为 <code>true</code> 表示 <code>listener</code> 会在该类型的事件<code>捕获</code>阶段传播到该 <code>EventTarget</code> 时触发</li><li><code>options</code> （<code>object</code>）<ul><li><code>capture</code> （<code>boolean</code>,默认值<code>false</code>,同<code>useCapture</code>）</li><li><code>once</code> (<code>boolean</code>,默认值<code>false</code>) 为 <code>true</code> 表示 <code>listener</code> 在添加之后最多只调用一次</li><li><code>passive</code> (<code>boolean</code>,默认值<code>false</code>) 为 <code>true</code> 表示 <code>listener</code> 调用 <code>preventDefault()</code>无效并报错</li></ul></li></ul><h2 id="事件原因"><a href="#事件原因" class="headerlink" title="事件原因"></a>事件原因</h2><p>从<code>Chrome 56</code>开始，如果我们给<code>document</code>绑定<code>touchmove</code>或者<code>touchstart</code>事件的监听器，这个<code>passive</code>是会被默认设置为<code>true</code>以提高性能<a href="https://www.chromestatus.com/feature/5093566007214080" target="_blank" rel="noopener">查阅</a></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>避免在<code>handler</code>里调用<code>e.preventDefault()</code>,提高性能</li><li><code>addEventListener</code>里第三个参数设置为<code>{passive:false}</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">'touchstart'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    passive: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(转载)javascript中的装箱和拆箱</title>
      <link href="/368.html"/>
      <url>/368.html</url>
      
        <content type="html"><![CDATA[<h2 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h2><p>把<code>基本数据类型</code>转换为对应的<code>引用类型</code>的操作称为<code>装箱</code>，把<code>引用类型</code>转换为<code>基本数据类型</code>称为<code>拆箱</code>。</p><blockquote><p>每当读取一个基本类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。 –《javascript 高级程序设计》</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'some text'</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>如上所视，变量 <code>s1</code> 是一个基本类型值，它不是对象，所以它不应该有方法。但是 js 内部为我们完成了一系列处理（即我们称之为<code>装箱</code>），使得它能够调用方法,实现的机制如下：</p><ul><li>创建 <code>String</code> 类型的一个实例</li><li>在实例上调用指定的方法</li><li>销毁这个实例</li></ul><p>这个过程也可以用代码来展现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'some text'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>我在很多地方都看到过说装箱操作会泄露内存，可是这里明明是销毁了实例的，哎，我还是相信《javascript 高级程序设计》吧，认为它不会泄露~</p><h2 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h2><p>将<code>引用类型</code>对象转换为对应的<code>基本数据类型</code>，它是通过<code>引用类型</code>的 <code>valueOf()</code>或者 <code>toString()</code>方法来实现的。如果是自定义的对象，你也可以自定义它的 <code>valueOf()/tostring()</code>方法，实现对这个对象的<code>拆箱</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objNum = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">var</span> objStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objNum); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objStr); <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objNum.valueOf()); <span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objStr.valueOf()); <span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objNum.toString()); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objStr.toString()); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ast简介</title>
      <link href="/367.html"/>
      <url>/367.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>抽象语法树（Abstract Syntax Tree，AST）</code>是源代码语法结构的一种抽象表示。它以<strong>树状的形式表现编程语言的语法结构</strong>，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>优化变更代码，改变代码结构达到想要的结构（webpack 等），代码语法、风格的检查（eslint），代码的格式化，代码的高亮，代码错误提示，代码自动补全（IDE）等等。</p><h2 id="如何转换"><a href="#如何转换" class="headerlink" title="如何转换"></a>如何转换</h2><p>可通过一些优秀的 javascript Parser 解析器，来实现源码转换为语法树，更改语法树，生成新的语法树。</p><h3 id="源码-gt-语法树"><a href="#源码-gt-语法树" class="headerlink" title="源码-&gt;语法树"></a>源码-&gt;语法树</h3><p>一般浏览器会把 js 源码通过解析器转化为抽象语法树，再进一步转化为字节码或直接生成机器码。</p><p>每一个 js 引擎都会有自己的抽象语法树格式，chrome 的 v8 引擎，firefox 的 SpiderMonkey 引擎等等，业界标准为：<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API#Node_objects" target="_blank" rel="noopener">AST 对象文档</a>，中文类似<a href="http://developer.51cto.com/art/201611/521405.htm" target="_blank" rel="noopener">讲解</a></p><p>在线解析点<a href="https://astexplorer.net/" target="_blank" rel="noopener">这里</a></p><p>常用的 parser 有：<a href="https://esprima.org/" target="_blank" rel="noopener">esprima</a>，<code>traceur</code>，<code>acorn</code>(webpack 使用)，<code>shift</code></p><h3 id="遍历更新语法树"><a href="#遍历更新语法树" class="headerlink" title="遍历更新语法树"></a>遍历更新语法树</h3><p>常用的 parser 为：<a href="https://github.com/estools/estraverse" target="_blank" rel="noopener">estraverse</a></p><h3 id="语法树-gt-新的源码"><a href="#语法树-gt-新的源码" class="headerlink" title="语法树-&gt;新的源码"></a>语法树-&gt;新的源码</h3><p>常用的 parser 为：<a href="https://github.com/estools/escodegen" target="_blank" rel="noopener">escodegen</a></p><p>使用<code>esprima</code>,<code>estraverse</code>,<code>escodegen</code>三板斧可完成源码编译解析，另有包<a href="https://github.com/benjamn/recast" target="_blank" rel="noopener">recast</a>可完成这一系列操作。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="箭头函数转换成普通函数"><a href="#箭头函数转换成普通函数" class="headerlink" title="箭头函数转换成普通函数"></a>箭头函数转换成普通函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> esprima = <span class="built_in">require</span>(<span class="string">'esprima'</span>);</span><br><span class="line"><span class="keyword">const</span> estraverse = <span class="built_in">require</span>(<span class="string">'estraverse'</span>);</span><br><span class="line"><span class="keyword">const</span> escodegen = <span class="built_in">require</span>(<span class="string">'escodegen'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> code = <span class="string">`var a = b=&gt;&#123;console.log(123);&#125;`</span>;</span><br><span class="line"><span class="keyword">let</span> tree = esprima.parseScript(code);</span><br><span class="line">estraverse.traverse(tree, &#123;</span><br><span class="line">  leave(node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="string">'ArrowFunctionExpression'</span>) &#123;</span><br><span class="line">      node.type = <span class="string">'FunctionDeclaration'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> r = escodegen.generate(tree);</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// var a = function(b)&#123;console.log(123);&#125;</span></span><br></pre></td></tr></table></figure><h3 id="babel-插件"><a href="#babel-插件" class="headerlink" title="babel 插件"></a>babel 插件</h3><p>待补充 <a href="https://segmentfault.com/a/1190000018753707" target="_blank" rel="noopener">参考</a></p><h3 id="vue-template-模板解析-AST"><a href="#vue-template-模板解析-AST" class="headerlink" title="vue template 模板解析 AST"></a>vue template 模板解析 AST</h3><p>待补充 <a href="https://segmentfault.com/a/1190000015432258" target="_blank" rel="noopener">参考</a> <a href="https://blog.csdn.net/violetjack0808/article/details/79354852" target="_blank" rel="noopener">参考 2</a></p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用proxy实现一个简单完整的MVVM库</title>
      <link href="/366.html"/>
      <url>/366.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>MVVM</code> 是当前时代前端日常业务开发中的必备模式（相关框架如<code>react</code>，<code>vue</code>，<code>angular</code> 等）， 使用 <code>MVVM</code> 可以将开发者的精力更专注于业务上的逻辑，而不需要关心如何操作 <code>dom</code>。虽然现在都 9012 年了，<code>mvvm</code> 相关原理的介绍已经烂大街了，但出于学习基础知识的目的（使用 <code>proxy</code> 实现的 <code>vue</code>3.0 还在开发中）， 在参考了之前 <code>vue.js</code> 的整体思路之后，自己动手实现了一个简易的通过 <code>proxy</code> 实现的 <code>mvvm</code>。</p><blockquote><p>本项目代码已经开源在<a href="https://github.com/baihong89/mvvm" target="_blank" rel="noopener">github</a>，项目正在持续完善中，欢迎交流学习，喜欢请点个 star 吧！</p></blockquote><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MVVM <span class="keyword">from</span> <span class="string">'@fe_korey/mvvm'</span>;</span><br><span class="line"><span class="keyword">new</span> MVVM(&#123;</span><br><span class="line">  view: <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>),</span><br><span class="line">  model: &#123;</span><br><span class="line">    title: <span class="string">'hello mvvm!'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'主程编译完成,欢迎使用MVVM！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h2><ul><li><code>Complier</code> 模块实现解析、收集指令，并初始化视图</li><li><code>Observer</code> 模块实现了数据的监听，包括添加订阅者和通知订阅者</li><li><code>Parser</code> 模块实现解析指令，提供该指令的更新视图的更新方法</li><li><code>Watcher</code> 模块实现建立指令与数据的关联</li><li><code>Dep</code> 模块实现一个订阅中心，负责收集，触发数据模型各值的订阅列表</li></ul><p>流程为：<code>Complier</code>收集编译好指令后，根据指令不同选择不同的<code>Parser</code>，根据<code>Parser</code>在<code>Watcher</code>中订阅数据的变化并更新初始视图。<code>Observer</code>监听数据变化然后通知给 <code>Watcher</code> ，<code>Watcher</code> 再将变化结果通知给对应<code>Parser</code>里的 <code>update</code> 刷新函数进行视图的刷新。</p><p><img src="http://cdn.flqin.com/mvvm.jpeg" alt="mvvm.js整体流程图"></p><h2 id="模块详解"><a href="#模块详解" class="headerlink" title="模块详解"></a>模块详解</h2><h3 id="Complier"><a href="#Complier" class="headerlink" title="Complier"></a>Complier</h3><ul><li><p>将整个数据模型 <code>data</code> 传入<code>Observer</code>模块进行数据监听</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$data = <span class="keyword">new</span> Observer(option.model).getData();</span><br></pre></td></tr></table></figure></li><li><p>循环遍历整个 <code>dom</code>，对每个 <code>dom</code> 元素的所有指令进行扫描提取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectDir</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> children = element.childNodes;</span><br><span class="line">  <span class="keyword">const</span> childrenLen = children.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLen; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = children[i];</span><br><span class="line">    <span class="keyword">const</span> nodeType = node.nodeType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodeType !== <span class="number">1</span> &amp;&amp; nodeType !== <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasDirective(node)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$queue.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.hasChildNodes() &amp;&amp; !hasLateCompileChilds(node)) &#123;</span><br><span class="line">      collectDir(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对每个指令进行编译，选择对应的解析器<code>Parser</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parser = <span class="keyword">this</span>.selectParsers(&#123; node, dirName, dirValue, <span class="attr">cs</span>: <span class="keyword">this</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>将得到的解析器<code>Parser</code>传入<code>Watcher</code>，并初始化该 <code>dom</code> 节点的视图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(parser);</span><br><span class="line">parser.update(&#123; <span class="attr">newVal</span>: watcher.value &#125;);</span><br></pre></td></tr></table></figure></li><li><p>所有指令解析完毕后，触发 <code>MVVM</code> 编译完成回调<code>$mounted()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$mounted();</span><br></pre></td></tr></table></figure></li><li><p>使用文档碎片<code>document.createDocumentFragment()</code>来代替真实 <code>dom</code> 节点片段，待所有指令编译完成后，再将文档碎片追加回真实 <code>dom</code> 节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> child;</span><br><span class="line"><span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">while</span> ((child = <span class="keyword">this</span>.$element.firstChild)) &#123;</span><br><span class="line">  fragment.appendChild(child);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析完后</span></span><br><span class="line"><span class="keyword">this</span>.$element.appendChild(fragment);</span><br><span class="line"><span class="keyword">delete</span> $fragment;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><ul><li><p>在<code>Complier</code>模块编译后的指令，选择不同听解析器解析，目前包括<code>ClassParser</code>,<code>DisplayParser</code>,<code>ForParser</code>,<code>IfParser</code>,<code>StyleParser</code>,<code>TextParser</code>,<code>ModelParser</code>,<code>OnParser</code>,<code>OtherParser</code>等解析模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (name) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'text'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> TextParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'style'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> StyleParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'class'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> ClassParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'for'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> ForParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'on'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> OnParser(&#123; node, dirName, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'display'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> DisplayParser(&#123; node, dirName, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'if'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> IfParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'model'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> ModelParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> OtherParser(&#123; node, dirName, dirValue, cs &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不同的解析器提供不同的视图刷新函数<code>update()</code>，通过<code>update</code>更新<code>dom</code>视图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//text.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.el.textContent = _toString(newVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>OnParser</code> 解析事件绑定，与数据模型中的 <code>methods</code>字段对应</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//详见 https://github.com/baihong89/mvvm/blob/master/src/core/parser/on.ts</span></span><br><span class="line">el.addEventListener(handlerType, e =&gt; &#123;</span><br><span class="line">  handlerFn(scope, e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>ForParser</code> 解析数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//详见 https://github.com/baihong89/mvvm/blob/master/src/core/parser/for.ts</span></span><br></pre></td></tr></table></figure></li><li><p><code>ModelParser</code> 解析双向绑定，目前支持<code>input[text/password] &amp; textarea</code>,<code>input[radio]</code>,<code>input[checkbox]</code>,<code>select</code>四种情况的双向绑定，双绑原理：</p><ul><li><p>数据变化更新表单：跟其他指令更新视图一样，通过<code>update</code>方法触发更新表单的<code>value</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">&#123; newVal &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.model.el.value = _toString(newVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表单变化更新数据：监听表单变化事件如<code>input</code>,<code>change</code>，在回调里<code>set</code>数据模型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.model.el.addEventListener(<span class="string">'input'</span>, e =&gt; &#123;</span><br><span class="line">  model.watcher.set(e.target.value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><ul><li><code>MVVM</code> 模型中的核心，一般通过 <code>Object.defineProperty</code> 的 <code>get</code>，<code>set</code> 方法进行数据的监听，在 <code>get</code> 里添加订阅者，<code>set</code> 里通知订阅者更新视图。在本项目采用 <code>Proxy</code> 来实现数据监听，好处有三：<ul><li><code>Proxy</code> 可以直接监听对象而非属性</li><li><code>Proxy</code> 可以直接监听数组的变化</li><li><code>Proxy</code> 有多达 13 种拦截方法，<a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">查阅</a><br>而劣势是兼容性问题,且无法通过 <code>polyfill</code> 磨平。查阅<a href="https://caniuse.com/#search=Proxy" target="_blank" rel="noopener">兼容性</a></li></ul></li><li>注意 <code>Proxy</code> 只会监听自身的每一个属性，如果属性是对象，则该对象不会被监听，所以需要递归监听</li><li>设置监听后，返回一个 <code>Proxy</code> 替代原数据对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, key, receiver) &#123;</span><br><span class="line">    <span class="comment">//如果满足条件则添加订阅者</span></span><br><span class="line">    dep.addDep(curWatcher);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(target, key, value, receiver) &#123;</span><br><span class="line">    <span class="comment">//如果满足条件则通知订阅者</span></span><br><span class="line">    dep.notfiy();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><ul><li><p>在 <code>Complier</code> 模块里对每一个解析后的 <code>Parser</code> 进行指令与数据模型直接的绑定，并触发 <code>Observer</code> 的 <code>get</code> 监听，添加订阅者（<code>Watcher</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._getter(<span class="keyword">this</span>.parser.dirValue)(<span class="keyword">this</span>.scope || <span class="keyword">this</span>.parser.cs.$data);</span><br></pre></td></tr></table></figure></li><li><p>当数据模型变化时，就会触发 -&gt; <code>Observer</code> 的 <code>set</code> 监听 -&gt; <code>Dep</code> 的 <code>notfiy</code> 方法(通知订阅者的所有订阅列表) -&gt; 执行订阅列表所有 <code>Watcher</code> 的 <code>update</code> 方法 -&gt; 执行对应 <code>Parser</code> 的 <code>update</code> -&gt; 完成更新视图</p></li><li><p><code>Watcher</code> 里的 <code>set</code> 方法用于设置双向绑定值，注意访问层级</p></li></ul><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><ul><li><code>MVVM</code> 的订阅中心，在这里收集数据模型的每个属性的订阅列表</li><li>包含添加订阅者，通知订阅者等方法</li><li>本质是一种发布/订阅模式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.dependList = [];</span><br><span class="line">  &#125;</span><br><span class="line">  addDep() &#123;</span><br><span class="line">    <span class="keyword">this</span>.dependList.push(dep);</span><br><span class="line">  &#125;</span><br><span class="line">  notfiy() &#123;</span><br><span class="line">    <span class="keyword">this</span>.dependList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.update();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>目前该 <code>mvvm</code> 项目只实现了<code>数据绑定</code>和<code>视图更新</code>的功能，通过这个简易轮子的实现，对 <code>dom</code> 操作，<code>proxy</code>，<code>发布订阅模式</code>等若干基础知识都进行了再次理解，查漏补缺。同时欢迎大家一起探讨交流，后面会继续完善！</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式的先行断言(lookahead)和后行断言(lookbehind)</title>
      <link href="/365.html"/>
      <url>/365.html</url>
      
        <content type="html"><![CDATA[<p>均是<strong>匹配位置</strong>，在匹配过程中，不占用字符，所以被称为<strong>零宽</strong>。</p><ul><li><p><code>(?=pattern)</code> 零宽<code>正向先行</code>断言(zero-width positive lookahead assertion)</p><ul><li><p>紧接该位置<strong>之后</strong>的字符序列<strong>能够</strong>匹配 <code>pattern</code></p></li><li><p>如替换后面紧跟<code>c</code>的<code>ab</code>为<code>xx</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abcabdabe'</span>.replace(<span class="regexp">/ab(?=c)/g</span>, <span class="string">'xx'</span>); <span class="comment">// xxcabdabe</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>(?!pattern)</code> 零宽<code>负向先行</code>断言(zero-width negative lookahead assertion)</p><ul><li><p>紧接该位置<strong>之后</strong>的字符序列<strong>不能</strong>匹配 <code>pattern</code></p></li><li><p>如替换后面不为<code>c</code>的<code>ab</code>为<code>xx</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abcabdabe'</span>.replace(<span class="regexp">/ab(?!c)/g</span>, <span class="string">'xx'</span>); <span class="comment">// abcxxdxxe</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>(?&lt;=pattern)</code> 零宽<code>正向后行</code>断言(zero-width positive lookbehind assertion)</p><ul><li><p>紧接该位置<strong>之前</strong>的字符序列<strong>能够</strong>匹配 <code>pattern</code></p></li><li><p>如替换前面为<code>a</code>的<code>bc</code>为<code>xx</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abcdbcebc'</span>.replace(<span class="regexp">/(?&lt;=a)bc/g</span>, <span class="string">'xx'</span>); <span class="comment">// axxdbcebc</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>(?&lt;!pattern)</code> 零宽<code>负向后行</code>断言(zero-width negative lookbehind assertion)</p><ul><li><p>紧接该位置<strong>之前</strong>的字符序列<strong>不能</strong>匹配 <code>pattern</code></p></li><li><p>如替换后面不为<code>a</code>的<code>bc</code>为<code>xx</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abcdbcebc'</span>.replace(<span class="regexp">/(?&lt;!a)bc/g</span>, <span class="string">'xx'</span>); <span class="comment">// abcdxxexx</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>另：非捕获分组<code>(?:p)</code></p><p><code>括号</code>是提供分组功能，如果只想要<code>括号</code>最原始的功能，但不会引用它，即既不在 API 里引用，也不在正则里反向引用。此时可以使用<code>非捕获分组(?:p)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abcde'</span>.replace(<span class="regexp">/(ab)c(de)/g</span>, <span class="string">'$1'</span>); <span class="comment">// ab</span></span><br><span class="line"><span class="string">'abcde'</span>.replace(<span class="regexp">/(?:ab)c(de)/g</span>, <span class="string">'$1'</span>); <span class="comment">// de</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(转载)为什么JavaScript里面typeof(null)的值是&quot;object&quot;</title>
      <link href="/364.html"/>
      <url>/364.html</url>
      
        <content type="html"><![CDATA[<ol><li>null 不是一个空引用, 而是一个原始值, 参考 <a href="http://lzw.me/pages/ecmascript/#20" target="_blank" rel="noopener">ECMAScript5.1 中文版</a> 4.3.11 节; 它只是期望此处将引用一个对象, 注意是”期望”, 参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="noopener">null - JavaScript</a>.</li><li>typeof null 结果是 object, 这是个历史遗留 bug, 参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">typeof - JavaScript</a></li><li>在 ECMA6 中, 曾经有提案为历史平反, 将 type null 的值纠正为 null, 但最后提案被拒了. 理由是历史遗留代码太多, 不想得罪人, 不如继续将错就错当和事老, 参考 <a href="http://wiki.ecmascript.org/doku.php?id=harmony%3atypeof_null" target="_blank" rel="noopener">harmony:typeof_null -ES Wiki</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NFE（具名函数表达式）的问题</title>
      <link href="/363.html"/>
      <url>/363.html</url>
      
        <content type="html"><![CDATA[<p>群里小伙伴讨论了这么一个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;;</span><br><span class="line">a(); <span class="comment">//打印b为function()&#123;b=1;console.log(b);&#125;</span></span><br></pre></td></tr></table></figure><p>为什么这里打印的 b 为 b 函数，而不是 1？</p><p>答案是<code>函数表达式</code>如果有 <code>name</code> 的话，这个 <code>name</code> 是<code>不可删除且为只读</code>。</p><p>资料查阅：</p><ul><li><a href="https://goddyzhao.tumblr.com/post/11273713920/functions" target="_blank" rel="noopener">函数（Functions）</a></li><li><a href="https://goddyzhao.tumblr.com/post/11259644092/scope-chain" target="_blank" rel="noopener">作用域链（Scope Chain）</a></li><li><a href="https://goddyzhao.tumblr.com/post/11141710441/variable-object" target="_blank" rel="noopener">变量对象（Variable object）</a></li><li><a href="https://goddyzhao.tumblr.com/post/10020230352/execution-context" target="_blank" rel="noopener">执行上下文（Execution Context）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义事件</title>
      <link href="/362.html"/>
      <url>/362.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建，触发，删除自定义事件"><a href="#创建，触发，删除自定义事件" class="headerlink" title="创建，触发，删除自定义事件"></a>创建，触发，删除自定义事件</h2><ul><li>创建自定义事件 文档<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events" target="_blank" rel="noopener">查阅</a></li><li>Event() 文档<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/Event" target="_blank" rel="noopener">查阅</a></li><li>Event 属性 文档<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank" rel="noopener">查阅</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'build'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for the event.</span></span><br><span class="line">elem.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; ... &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatch the event.</span></span><br><span class="line">elem.dispatchEvent(event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete the event.</span></span><br><span class="line">elem.removeEventListener(<span class="string">'build'</span>);</span><br></pre></td></tr></table></figure><h2 id="添加自定义数据"><a href="#添加自定义数据" class="headerlink" title="添加自定义数据"></a>添加自定义数据</h2><p>要向事件对象添加更多数据，可以使用 <code>CustomEvent</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'build'</span>, &#123; <span class="attr">detail</span>: elem.dataset.time &#125;);</span><br></pre></td></tr></table></figure><p>事件监听器中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  log(<span class="string">'The time is: '</span> + e.detail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="触发内置事件"><a href="#触发内置事件" class="headerlink" title="触发内置事件"></a>触发内置事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'input'</span>, &#123;</span><br><span class="line">  bubbles: <span class="literal">true</span>, <span class="comment">//能否冒泡</span></span><br><span class="line">  cancelable: <span class="literal">true</span> <span class="comment">//事件是否可以取消默认行为</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">element.dispatchEvent(event);</span><br></pre></td></tr></table></figure><h2 id="createEvent-amp-initEvent-（已废弃-IE-中可用）"><a href="#createEvent-amp-initEvent-（已废弃-IE-中可用）" class="headerlink" title="createEvent &amp; initEvent （已废弃,IE 中可用）"></a>createEvent &amp; initEvent （已废弃,IE 中可用）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'Event'</span>);</span><br><span class="line">event.initEvent(<span class="string">'build'</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts项目架构</title>
      <link href="/361.html"/>
      <url>/361.html</url>
      
        <content type="html"><![CDATA[<p>此贴记录下在<code>typescript</code>项目里的一些相关配置和包的选用，其中各种依赖包和最佳实践都在不断发展演变中，最新的以该仓库为准（<a href="https://github.com/baihong89/mvvm" target="_blank" rel="noopener">MVVM</a>）。</p><h2 id="typescript-支持"><a href="#typescript-支持" class="headerlink" title="typescript 支持"></a>typescript 支持</h2><p>在<code>webpack</code>中使用 <code>babel 7.0 +</code>,摒弃了传统的<code>ts-loader</code>或 <code>awesome-typescript-loader</code> 方案，<a href="https://github.com/frontend9/fe9-library/issues/23" target="_blank" rel="noopener">查阅 1</a><a href="https://juejin.im/post/5c822e426fb9a04a0a5ffb49" target="_blank" rel="noopener">查阅 2</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add @babel/core babel-loader @babel/preset-env @babel/preset-typescript -D</span><br><span class="line">yarn add @babel/plugin-proposal-class-propertie -D //根据项目需求添加其他env未包含的转义插件</span><br></pre></td></tr></table></figure><p><code>babel</code>只负责转换，并不会做对应的类型检查，所以需要安装<a href="https://github.com/TypeStrong/fork-ts-checker-webpack-plugin" target="_blank" rel="noopener">查阅</a>来进行报错提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add fork-ts-checker-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>项目通用转 ES5 安装包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @babel/plugin-transform-runtime @babel/runtime-corejs3 -D</span><br></pre></td></tr></table></figure><p>babel.config.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/env'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: <span class="string">'&gt; 1%, not dead'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'@babel/preset-typescript'</span></span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/plugin-transform-runtime'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        corejs: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'@babel/plugin-proposal-class-properties'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>tsconfig.json 配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"ESNext"</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">    <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"sourceMap"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"src/**/*"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(js|ts)$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: [<span class="string">'babel-loader'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码检查-amp-风格统一"><a href="#代码检查-amp-风格统一" class="headerlink" title="代码检查 &amp; 风格统一"></a>代码检查 &amp; 风格统一</h2><p>代码检查 使用<code>eslint</code>（<a href="https://github.com/typescript-eslint/typescript-eslint" target="_blank" rel="noopener">官方未来推荐</a>），抛弃传统的<code>tslint</code>方案<a href="https://ts.xcatliu.com/engineering/lint" target="_blank" rel="noopener">查阅</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn add eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin -D</span><br><span class="line"></span><br><span class="line">//@typescript-eslint/parser :将 TypeScript 转换为 ESTree，使 eslint 可以识别</span><br><span class="line">//@typescript-eslint/eslint-plugin :只是一个可以打开或关闭的规则列表</span><br></pre></td></tr></table></figure><p><code>@typescript-eslint/parser</code>作为 babel 的解析器,这时候就不需要安装 babel 默认推荐的 eslint 解析器(<code>babel-eslint</code>)了。</p><p>风格统一 使用 <code>prettier</code> ,在 ts 项目里将配置文件 <code>prettier.config.js</code> 里添加 <code>parser: &quot;typescript&quot;</code> 即可(前提是已安装<code>@typescript-eslint/parser</code>) <a href="https://prettier.io/docs/en/options.html#parser" target="_blank" rel="noopener">查阅</a>。</p><p>项目通用<code>prettier</code>的其他包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add prettier eslint-config-prettier eslint-plugin-prettier -D</span><br></pre></td></tr></table></figure><p>结合<code>eslint+prettier</code>,配置文件<a href="https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/eslint-plugin" target="_blank" rel="noopener">查阅</a></p><p>prettier.config.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  singleQuote: <span class="literal">false</span>,</span><br><span class="line">  printWidth: <span class="number">200</span>,</span><br><span class="line">  parser: <span class="string">'typescript'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>.eslintrc.js(这里使用的<code>google</code>默认规则 <code>eslint-config-google</code>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  root: <span class="literal">true</span>,</span><br><span class="line">  parser: <span class="string">'@typescript-eslint/parser'</span>,</span><br><span class="line">  plugins: [<span class="string">'@typescript-eslint'</span>],</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    es6: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  extends: [<span class="string">'plugin:@typescript-eslint/recommended'</span>, <span class="string">'google'</span>, <span class="string">'prettier'</span>, <span class="string">'prettier/@typescript-eslint'</span>],</span><br><span class="line">  globals: &#123;</span><br><span class="line">    Atomics: <span class="string">'readonly'</span>,</span><br><span class="line">    SharedArrayBuffer: <span class="string">'readonly'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: <span class="number">2018</span>,</span><br><span class="line">    sourceType: <span class="string">'module'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'@typescript-eslint/no-explicit-any'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'@typescript-eslint/no-use-before-define'</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="jest"><a href="#jest" class="headerlink" title="jest"></a>jest</h3><p>这里选用<code>jest</code>框架来测试 <a href="http://www.fly63.com/article/detial/170" target="_blank" rel="noopener">jest 优势</a>。</p><p>在 ts 项目里,摒弃了传统的<code>ts-jest</code>,只需安装<code>@babel/preset-typescript</code>，并在<code>babel.config.js</code>里的<code>presets</code>添加即可，如上 <a href="#typescript-%e6%94%af%e6%8c%81">babel 配置</a>,<a href="https://jestjs.io/docs/en/getting-started.html#using-typescript" target="_blank" rel="noopener">查阅</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn jest @types/jest -D  //@types/jest 是 jest 的 ts 类型定义文件，而 vscode 便是基于 ts 进行代码提示的</span><br></pre></td></tr></table></figure><ul><li>经查<code>jest</code>依赖包里发现，<code>jest</code>依赖 <code>babel-jest</code>(用于支持 es6 语法)，故不需要在单独引入依赖包<code>babel-jest</code>。</li><li>因为引入了<code>@types/jest</code>,也就不需要引入<code>eslint-plugin-jest</code>来消除 <code>jest</code> 变量的报错。</li><li>jest config 采用默认配置即可，更多个性化配置参见<a href="https://jestjs.io/docs/en/configuration" target="_blank" rel="noopener">查阅</a>。</li></ul><h3 id="coveralls"><a href="#coveralls" class="headerlink" title="coveralls"></a>coveralls</h3><p>这里选用了<a href="https://coveralls.io/" target="_blank" rel="noopener">coveralls</a>作为自动测试代码覆盖率的在线工具。由于项目走<code>travis.com</code>的持续集成，所以配置为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add coveralls -D</span><br></pre></td></tr></table></figure><p>.coveralls.yml:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">service_name:</span> <span class="string">travis-pro</span></span><br><span class="line"><span class="attr">repo_token:</span> <span class="string">COVERALLS_TOKEN</span> <span class="comment"># COVERALLS_TOKEN为加密变量</span></span><br></pre></td></tr></table></figure><p>package.json 添加 <code>scripts</code>(测试框架为<code>jest</code>，<a href="https://github.com/nickmerwin/node-coveralls" target="_blank" rel="noopener">更多方法查阅</a>):</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "coveralls": "jest --coverage &amp;&amp; cat ./coverage/lcov.info | coveralls"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>.travis.yml 添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">sed</span> <span class="bullet">-i</span> <span class="string">"s/COVERALLS_TOKEN/$COVERALLS_TOKEN/"</span> <span class="string">.coveralls.yml</span> <span class="comment">#$COVERALLS_TOKEN为在travis.com项目里配置的加密变量</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">yarn</span> <span class="string">run</span> <span class="string">coveralls</span></span><br></pre></td></tr></table></figure><h3 id="在-vscode-里调试-jest-webpack-等-node-js"><a href="#在-vscode-里调试-jest-webpack-等-node-js" class="headerlink" title="在 vscode 里调试 jest/webpack 等 node.js"></a>在 vscode 里调试 jest/webpack 等 node.js</h3><p><code>调试</code> -&gt; <code>添加配置</code> -&gt; 选择<code>node.js</code>，自动生成<code>.vscode/launch.json</code>，修改配置为：</p><p>文档<a href="https://code.visualstudio.com/docs/nodejs/nodejs-debugging" target="_blank" rel="noopener">查阅</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">"configurations": [</span><br><span class="line">    &#123;</span><br><span class="line">      "type": "node", //系统默认，不可更改，标识要使用的调试器的类型</span><br><span class="line">      "request": "launch", //系统默认，不可更改，在指定的文件上启动调试器 program. attach: 将调试器附加到已经运行的进程。</span><br><span class="line">      "name": "Launch Program", //调试配置的名称</span><br><span class="line">      "program": "$&#123;workspaceFolder&#125;/index.js", //要调试的Node.js程序的绝对路径</span><br><span class="line">      "args": ["--runInBand", "--env=jsdom", "$&#123;fileBasename&#125;"], //传递给程序进行调试的参数[array]</span><br><span class="line">      "runtimeExecutable": "npm", // 要使用的运行时可执行文件的绝对路径。默认是node (https://code.visualstudio.com/docs/nodejs/nodejs-debugging#_launch-configuration-support-for-npm-and-other-tools)</span><br><span class="line">      "runtimeArgs": ["run-script", "debug"], // 传递给运行时可执行文件的可选参数</span><br><span class="line">      "runtimeVersion":"7.10.1", //使用nvm可以用此属性控制node.js版本</span><br><span class="line">      "port": 5858, //要使用的调试端口</span><br><span class="line">      "console": "externalTerminal", //指定如何显示程序输出: externalTerminal:独立控制台窗口,integratedTerminal(默认):VS代码集成终端</span><br><span class="line">      "stopOnEntry": true, // 设置为true时，在调试程序的第一行中断开调试器。如果省略（默认）或设置为false，则调试器将程序运行到第一个断点。</span><br><span class="line">      "skipFiles": ["&lt;node_internals&gt;/**/*.js","$&#123;workspaceFolder&#125;/lib/**/*.js"] // 跳过不感兴趣的代码, Node.js的内置核心模块定义为：&lt;node_internals&gt;，其他变量定义(https://code.visualstudio.com/docs/editor/variables-reference)</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>调试单一 node 文件：<ul><li><code>launch.json</code>配置：<ul><li><code>program:${workspaceFolder}/index.js</code></li><li><code>args:[&#39;--dev&#39;]</code></li></ul></li></ul></li><li>调试<code>npm scripts</code>(包括普通 node 命令如<code>index.js</code>和非 node 命令如<code>jest,webpack</code>等)时：<ul><li><code>launch.json</code>配置：<ul><li><code>runtimeExecutable:&quot;npm&quot;</code> //必须设置为<code>npm</code></li><li><code>runtimeArgs:[&quot;run-script&quot;, &quot;debug&quot;]</code> //第一个参数必须为<code>run-script</code></li><li><code>runtimeVersion:&quot;10.6.0&quot;</code> //可选</li></ul></li><li><code>package.json</code>的<code>npm scripts</code>配置：<ul><li>必须加<code>--inspect-brk=5858</code>，5858 与 port 设置须相同</li><li>非普通命令需要转换成 node 调用: <code>webpack=&gt;./node_modules/.bin/webpack</code>(因为<code>npm run build</code>实际调用的是 <code>node_modules/.bin/webpack</code>)</li><li>带参数的命令接在后面即可：<code>node --inspect-brk=5858 ./node_modules/.bin/jest --coverage</code></li></ul></li></ul></li></ul><p>npm scripts:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "debug": "node --inspect-brk=5858 index.js",</span><br><span class="line">  "build": "node --inspect-brk=5858 ./node_modules/.bin/webpack",</span><br><span class="line">  "test": "node --inspect-brk=5858 ./node_modules/.bin/jest --coverage"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="前端测试概念"><a href="#前端测试概念" class="headerlink" title="前端测试概念"></a>前端测试概念</h3><h4 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h4><ul><li>单元测试 (Unit Test) - 通过模拟输入和预测输出的方式测试独立的函数或者类。</li><li>集成测试 (Integration Test) - 测试多个模块间的联动是否和期望相同。</li><li>E2E 测试 (也被称为 Functional Test) - 关注点不在内部实现方式，而是测试产品在真实使用场景（比如在浏览器）中是否可以达到预想的结果，属于黑盒测试。</li></ul><p>更多<a href="https://zhuanlan.zhihu.com/p/32702421" target="_blank" rel="noopener">查阅</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Typescript-错误忽略"><a href="#Typescript-错误忽略" class="headerlink" title="Typescript 错误忽略"></a>Typescript 错误忽略</h3><ul><li>单行忽略 <code>// @ts-ignore</code></li><li>忽略全文 <code>// @ts-nocheck</code></li><li>取消忽略全文 <code>// @ts-check</code></li></ul><h3 id="github-徽章"><a href="#github-徽章" class="headerlink" title="github 徽章"></a>github 徽章</h3><p>在<a href="https://shields.io/" target="_blank" rel="noopener">shields</a>上面可生成任意徽章。</p><h3 id="d-ts-文件是什么"><a href="#d-ts-文件是什么" class="headerlink" title=".d.ts 文件是什么"></a>.d.ts 文件是什么</h3><p><code>d.ts</code> 就是 <code>TypedDefinition 类型定义文件</code>，用来定义类型信息以及接口规范。</p><p><code>ts</code>代码最终会编译成 <code>.js</code> 的 js 代码，供他人使用。这个时候，类型信息就丢失了。所以 <code>ts</code> 编译器会自动根据 <code>.ts</code> 中的信息，可以自动生成对外的 <code>.d.ts</code> 文件，和生成的 <code>js</code> 文件搭配使用。其中，<code>js</code> 文件是给运行引擎用的，而 <code>.d.ts</code> 文件是给 <code>IDE（智能编辑器）</code>写代码时参考用的。</p><h3 id="如何测试本地-node-包"><a href="#如何测试本地-node-包" class="headerlink" title="如何测试本地 node 包"></a>如何测试本地 node 包</h3><p>采用<code>npm link</code></p><ul><li>在需要测试的包（如<code>test</code>）路径下执行：<code>npm link</code>，这时<code>全局node_modules</code>包下就可以看到这个<code>test</code>包。</li><li>在需引用的目标包的项目下安装该测试包：<code>npm link test</code>（如果有作用域需要加上作用域：<code>npm link @fe_korey/test</code>）,这时 test 包就被安装在了该目录下，在 test 包里的修改会同步到目标包里。</li><li>取消连接：在<code>test</code>包里执行：<code>npm unlink</code>即可.</li></ul><p>注意：在<code>webpack</code>项目中，如果用<code>npm link</code>方式测试本地包，需要设置 config:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  symlinks: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）点击穿透</title>
      <link href="/360.html"/>
      <url>/360.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>点击穿透这种现象算是移动 web 开发比较经典的问题，也常用来做面试题。本文目标是结合移动 web 开发的相关事件，介绍一下点击穿透现象形成的原因以及避免这种现象的解决方法。</p><h2 id="点击穿透现象"><a href="#点击穿透现象" class="headerlink" title="点击穿透现象"></a>点击穿透现象</h2><p>现象描述：</p><p>页面中存在上下两个层，上层元素具有表单，链接或者绑定相应事件，上层元素点击或触摸，导致上层 DOM 改变，下层中同样位置的元素触发点击事件。这种现象就是<code>点击穿透（Ghost Clicks）</code>。其实我觉得用“幽冥点击”称呼它更加带感。</p><p>要理解这种现象，首先要了解移动端的相关事件 —— <code>触摸(Touch)事件</code>，<code>点击(Click)事件</code>。</p><p>Touch 事件中，常用的为 <code>touchstart</code>, <code>touchmove</code>, <code>touchend</code> 三种。除此之外还有 <code>touchcancel</code>。注意，原生事件中并没有 <code>tap</code> 事件。下面会解释 <code>tap</code> 事件怎么产生的。</p><p>事件描述如下：</p><table><thead><tr><th>事件</th><th>描述</th><th>触发时机</th></tr></thead><tbody><tr><td>touchstart</td><td>开始触摸</td><td>手指接触屏幕时立即触发</td></tr><tr><td>touchmove</td><td>移动或拖拽</td><td>取决于系统和浏览器</td></tr><tr><td>touchend</td><td>触摸结束</td><td>手指离开屏幕时立即出发</td></tr></tbody></table><p>而 Touch 事件的触发一般通过手指，还会存在多点触控，拖拽方向等情况。列出几个重要参数如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>touches</td><td>屏幕中每根手指信息列表</td></tr><tr><td>targetTouches</td><td>和 touches 类似，把同一节点的手指信息过滤掉</td></tr><tr><td>changedTouches</td><td>响应当前事件的每根手指的信息列表</td></tr></tbody></table><p>代码获取如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxDOM.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.touches, e.targetTouches, e.changedTouches);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>手指触发触摸事件的过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touchstart -&gt; touchmove -&gt; ... touchmove -&gt; touchend</span><br></pre></td></tr></table></figure><p>由此，我们可以在 <code>ontouchstart</code> 事件上记录开始触摸开始，<code>ontouchend</code> 记录触摸结束信息。</p><p>通过上述这些参数，很容易的去计算幽冥点击的时间，以及点击穿透的相关信息，包括响应的坐标情况。</p><h2 id="造成的原因"><a href="#造成的原因" class="headerlink" title="造成的原因"></a>造成的原因</h2><p>问题来了，<code>click 事件</code>什么时候触发？</p><p>浏览器在 <code>touchend</code> 之后会等待约 <code>300ms</code> ，如果没有 <a href="https://www.cnblogs.com/zhuzhenwei918/p/7588553.html" target="_blank" rel="noopener">tap 行为</a>，则触发 click 事件。</p><p>而浏览器等待约 300ms 的原因是，判断用户是否是<code>双击（double tap）行为</code>，双击过程中就不适合触发 click 事件了。</p><p>由此可以看出 click 事件触发代表一轮触摸事件的结束。</p><p>上面说到原生事件中并没有 tap 事件，可以参考经典的 zepto.js 对 singleTap 事件的处理。<a href="https://github.com/madrobby/zepto/blob/master/src/touch.js#L136-L143" target="_blank" rel="noopener">见源码 136-143 行</a></p><p>可以看出，singleTap 事件的触发时机 —— 在 touchend 事件响应 250ms 无操作后，触发 singleTap。</p><p>因此，点击穿透的现象就容易理解了，在这 300ms 以内，因为上层元素隐藏或消失了，由于 click 事件的滞后性，同样位置的 DOM 元素触发了 click 事件（如果是 input 则触发了 focus 事件）。在代码中，给我们的感觉就是 target 发生了飘移。</p><h2 id="怎样避免点击穿透"><a href="#怎样避免点击穿透" class="headerlink" title="怎样避免点击穿透"></a>怎样避免点击穿透</h2><p>理解点击穿透的原因，我们从各种途径去阻止现象的产生。</p><p>毫无疑问，能想到的方法很多，比如中间的层添加一个 300ms 渐隐的动画，触摸结束后阻止 click 事件等。</p><ol><li><p>触摸开始时<br>touchstart 事件触发时，preventDefault()。毫无疑问，很容易想到这一点，而且也从根本上解决了这个问题。但是，它有一个避免不了或者说引入了很大的缺陷，页面中 DOM 元素无法再进行滚动了。这个方法显然不能满足我们的需求，但是这个思路其实可以给我们更多的启发，比如说 iscroll 只允许横向滚动的实现，相关实现这里暂且不表。</p></li><li><p>触摸结束时<br>touchend 事件触发时，preventDefault()。看上去好像没有什么问题，但是，很遗憾的是不是所有的浏览器都支持。</p></li><li><p>禁止页面缩放<br>通过设置 meta 标签，可以禁止页面缩放，部分浏览器不再需要等待 300ms，导致点击穿透。点击事件仍然会触发，但相对较快，所以 click 事件从某种意义上来说可以取代点击事件，<br>而代价是牺牲少数用户（click 事件触发仍然较慢）的体验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>IE 10 可以用 CSS 取消点击穿透的延迟：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">-ms-touch-action</span>: manipulation;</span><br><span class="line">  <span class="attribute">touch-action</span>: manipulation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IE 11+ 可以用 touch-action: manipulation;属性来阻止元素的双击缩放。</p></li><li><p>CSS3 的方法<br>虽然主要讲的是事件，但是有必要介绍一个 CSS3 的属性 —— <code>pointer-events</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer-events: auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit;</span><br></pre></td></tr></table></figure><p>pointer-events 属性有很多值，有用的主要是 auto 和 none，其他属性为 SVG 服务。</p><p><a href="https://caniuse.com/#search=pointer-events" target="_blank" rel="noopener">查看浏览器支持情况</a> 可见移动端开发还是可以用的。</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>auto</td><td>默认值，鼠标或触屏事件不会穿透当前层</td></tr><tr><td>none</td><td>元素不再是 target，监听的元素变成了下层的元素（如果子元素设置成 auto，点击子元素会继续监听事件）</td></tr></tbody></table></li><li><p>处理点击事件 —— Touch to Click<br>最靠谱的方案还是从点击事件的根源上解决问题。用 js 去判断幽冥点击，然后阻止点击穿透。这种方式显然可以实现，缺点是阻止点击穿透时需要小心，不要导致原生的 HTML 元素（如：链接，多选框，单选框）无法正常运行。</p><p>通过上文中介绍的 touches，targetTouches，changedTouches 参数，我们可以构建出这样的测试页面，可以统计出点击穿透的时间，以及已经响应的情况。</p><table><thead><tr><th></th><th>preventDefault()</th><th>preventDefault()</th><th>点击穿透时间</th><th>点击穿透时间</th><th>点击穿透区域</th><th>点击穿透区域</th></tr></thead><tbody><tr><td>Browser</td><td>touchstart</td><td>touchend</td><td>缩放页面</td><td>禁止缩放页面</td><td>缩放页面</td><td>禁止缩放页面</td></tr><tr><td>Safari Mobile iOS 5.1.1</td><td>Yes</td><td>Yes</td><td>370ms after end</td><td>370ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Safari Mobile iOS 6.1.3</td><td>Yes</td><td>Yes</td><td>370ms after end</td><td>370ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Safari Mobile iOS 7.1.1</td><td>Yes</td><td>Yes</td><td>370ms after end</td><td>370ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 2.3.7</td><td>Yes</td><td>No</td><td>410ms after end</td><td>410ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 4.0.4</td><td>Yes</td><td>No</td><td>300ms after end</td><td>10ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 4.1.2</td><td>Yes</td><td>No</td><td>300ms after end</td><td>300ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 4.2.2</td><td>Yes</td><td>No</td><td>300ms after start</td><td>10ms after end</td><td>touchstart</td><td>touchend</td></tr><tr><td>IE10 Windows Phone 8</td><td>No</td><td>No</td><td>310ms after end</td><td>10ms after end</td><td>touchend</td><td>touchend</td></tr><tr><td>Blackberry 10</td><td>Yes</td><td>Yes</td><td>260ms after end</td><td>10ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Chrome for iOS</td><td>Yes</td><td>Yes</td><td>360ms after end</td><td>360ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Chrome for Android</td><td>Yes</td><td>Yes</td><td>300ms after start</td><td>10ms after end</td><td>touchstart</td><td>touchend</td></tr><tr><td>Firefox for Android</td><td>Yes</td><td>No</td><td>300ms after end</td><td>10ms after end</td><td>touchstart</td><td>touchend</td></tr></tbody></table><p>由此可以看出：</p><ul><li>点击穿透受浏览器和页面是否缩放影响</li><li>点击穿透有两种情况：快速情况有 10ms 慢速情况有 300ms</li><li>在 touchend 时间上调用 preventDefault() 可以阻止多数情况的点击穿透</li></ul><p>代码上处理建议如下：</p><ul><li>在 touchend 事件上调用 preventDefault()</li><li>在一次成功的点击后，建议接下来的 500ms 以内取消所有的 click 事件。</li><li>分析点击事件，判断如果是慢速点击穿透，则取消所有 click 事件，如果是快速点击穿透，取消触摸事件 50ms 以内的 click 事件即可。</li></ul><p>有个好消息是，移动端开发已经有人写好相应的库，帮助我们处理点击穿透。</p><p><a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">fastclick</a> 可以参考和使用。</p><p>其实现思路是，取消 click 事件<a href="https://github.com/ftlabs/fastclick/blob/master/lib/fastclick.js#L521-L610" target="_blank" rel="noopener">（参看源码 164-173 行）</a>，用 touchend 模拟 快速点击行为<a href="https://github.com/ftlabs/fastclick/blob/master/lib/fastclick.js#L164-L173" target="_blank" rel="noopener">（参看源码 521-610 行）</a>。</p></li></ol><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="http://liudong.me/conclusion/touch-defect/" target="_blank" rel="noopener">点击穿透</a></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环(Event Loop)</title>
      <link href="/359.html"/>
      <url>/359.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li>进程是系统分配的独立资源，是 CPU 资源分配的基本单位，进程是由一个或者多个线程组成的。</li><li>线程是进程的执行流，是 CPU 调度和分派的基本单位，同个进程之中的多个线程之间是共享该进程的资源的。</li></ul><h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><ul><li>browser 进程<ul><li>主进程，负责协调、控制其他进程</li><li>负责浏览器界面显示，用户交互（前进、后退等），网络资源下载</li><li>负责将<code>渲染进程</code>得到的在内存中的 bitmap 绘制到用户界面上</li></ul></li><li>第三方插件进程<ul><li>每个插件对应一个进程，仅当使用该插件时才创建</li></ul></li><li>GPU 进程<ul><li>最多一个，用于 3D 绘制等</li></ul></li><li>浏览器内核渲染/renderer 进程<ul><li>浏览器每一个 tab 标签都代表一个独立的进程（也不一定，因为多个空白 tab 标签会合并成一个进程）</li><li>内部为多线程</li></ul></li></ul><p>多进程的好处可以避免单个 page、单个插件 crash 影响整个浏览器，也充分利用多核优势，提高浏览器稳定性。</p><h3 id="浏览器内核-renderer-进程-有多种线程在工作"><a href="#浏览器内核-renderer-进程-有多种线程在工作" class="headerlink" title="浏览器内核(renderer 进程)有多种线程在工作"></a>浏览器内核(renderer 进程)有多种线程在工作</h3><ul><li>GUI 渲染线程<ul><li>负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重绘或者由于某种操作引起回流都会调起该线程。</li><li>和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。</li></ul></li><li>JS 引擎线程(解释器)<ul><li><strong>单线程工作</strong>，负责解析运行 JavaScript 脚本。</li><li>和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。</li><li>一个浏览器 Tab（renderer 进程）只有一个 js 线程运行。</li></ul></li><li>事件触发线程<ul><li>该线程归属浏览器，不属于 JS 引擎，用来控制<strong>事件循环</strong>。</li><li>事件循环是一个程序结构，用于等待和发送消息和事件。</li><li>当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。</li></ul></li><li>定时器触发线程<ul><li>浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。</li><li>开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。</li></ul></li><li>http 请求线程<ul><li>每次 http 请求的时候都会<strong>新开启一条请求线程</strong>。</li><li>请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。</li></ul></li></ul><h3 id="browser-进程与-renderer-进程的通信过程"><a href="#browser-进程与-renderer-进程的通信过程" class="headerlink" title="browser 进程与 renderer 进程的通信过程"></a>browser 进程与 renderer 进程的通信过程</h3><ul><li>Browser 进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过 RendererHost 接口传递给 Render 进程</li><li>Renderer 进程的 Renderer 接口收到消息，简单解释后，交给渲染线程，然后开始渲染</li><li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要 Browser 进程获取资源和需要 GPU 进程来帮助渲染，当然可能会有 JS 线程操作 DOM（这样可能会造成回流并重绘）</li><li>最后 Render 进程将结果传递给 Browser 进程</li><li>Browser 进程接收到结果并将结果绘制出来</li></ul><h3 id="web-workers"><a href="#web-workers" class="headerlink" title="web workers"></a>web workers</h3><ul><li>原理：JS 引擎向浏览器新申请开一个<strong>子线程</strong>，与子线程通过 postMessage API 通信。子线程完全受主线程控制</li><li>作用：后台运行计算，将结果发到主线程，解决单线程的 JS 引擎进行密集型计算会堵塞页面的问题</li><li>子线程不能影响用户界面，即不能操作 dom 等，在一个新的全局上下文</li><li>除了 webworker（属于 renderer 进程） 还有 SharedWorker（多个标签页、iframe 共享，不属于某个 renderer 进程，自己就是一个进程），Service Workers，ChromeWorker 等</li><li>更多<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API" target="_blank" rel="noopener">查阅 1</a>,<a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">查阅 2</a></li></ul><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>事件循环是通过<code>任务队列</code>的机制来进行协调的。一个 <code>Event Loop</code> 中，可以有一个或者多个任务队列<code>(task queue)</code>，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。</p><p>JavaScript 单线程中的任务分为<code>同步任务</code>和<code>异步任务</code>。同步任务会在<code>调用栈</code>中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到<code>任务队列(消息队列)</code>中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。<code>任务队列</code>是<code>先进先出</code>的数据结构。</p><p>异步任务队列可分为 <code>task(macrotask)</code>宏任务 和 <code>microtask(job)</code>微任务 两类，不同的 API 注册的异步任务会依次进入自身对应的队列中，然后等待 <code>Event Loop</code>将它们依次压入执行栈中执行，宏任务队列可以有多个，微任务队列只有一个。</p><ul><li><code>microtask</code> 主要包含：<code>Promise.then</code>、<code>MutaionObserver</code>、<code>process.nextTick(Node.js 环境)</code>、<code>Object.observe(已废弃)</code><a href="https://github.com/luokuning/blogs/issues/1" target="_blank" rel="noopener">查阅</a></li><li><code>(macro)task</code>主要包含：<code>script(整体代码)</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>I/O</code>、<code>UI交互事件</code>、<code>postMessage</code>、<code>MessageChannel</code>、<code>setImmediate(Node.js 环境)</code></li></ul><h3 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环(Event Loop)"></a>事件循环(Event Loop)</h3><p>javascript 从诞生之日起就是一门单线程的非阻塞的脚本语言。而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如 I/O 事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。到底是如何实现非阻塞这一点呢？答案就是 <code>event loop（事件循环）</code>。</p><p><code>call stack 调用栈(执行栈)</code>是一种<code>后进先出</code>的数据结构。所有的同步任务都会被放到<code>调用栈</code>等待<code>主线程</code>执行。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。每次栈内被清空，都会去读取<code>任务队列</code>有没有任务，有就按照顺序读取执行，这个时候栈中又出现了事件，这个事件又去调用了<code>WebAPIs</code>里的异步方法，那这些异步方法会在再被调用的时候放在队列里，一直循环读取-执行的操作，就形成了<code>事件循环</code>。</p><h2 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h2><h3 id="总体图"><a href="#总体图" class="headerlink" title="总体图"></a>总体图</h3><p><img src="http://cdn.flqin.com/p359-1.png" alt="总体图"></p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>在事件循环中，每进行一次循环操作称为 <code>tick</code>，每一次 <code>tick</code> 的任务处理模型是比较复杂的，但关键步骤如下：</p><ul><li>在此次 <code>tick</code> 中选择最先进入队列的任务(<code>oldest task</code>)，如果有则执行(一个)，如果执行中有异步任务就放至各自的队列中</li><li>检查是否存在 <code>Microtasks</code>，如果存在则<strong>不停地执行</strong>，直至清空 <code>Microtasks Queue</code></li><li>更新 <code>render(update rendering)</code></li><li>取出下一个宏任务<code>task</code>,主线程重复执行上述步骤</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li><code>await</code>将直接使用<code>Promise.resolve()</code>相同语义<a href="https://www.zhihu.com/question/268007969/answer/339811998" target="_blank" rel="noopener">查阅</a>，即：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(async2()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Promise.resolve</code> 方法允许调用时不带参数，直接返回一个<code>resolved</code> 状态的 <code>Promise</code> 对象。立即 <code>resolved</code> 的 <code>Promise</code> 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。</li><li><code>Promises/A+规范</code>：实践中要确保 <code>onFulfilled</code> 和 <code>onRejected</code> 方法异步执行，且应该在 <code>then</code> 方法被调用的那一轮事件循环之后的新执行栈中执行。</li><li><code>update rendering（视图渲染）</code>发生在本轮事件循环的 microtask 队列被执行完之后，也就是说执行任务的耗时会影响视图渲染的时机。通常浏览器以每秒 60 帧（60fps）的速率刷新页面，这个帧率最适合人眼交互，大概 16.7ms 渲染一帧，所以如果要让用户觉得顺畅，单个 macrotask 及它相关的所有 microtask 最好能在 16.7ms 内完成。</li><li>也不是每轮事件循环都会执行<code>视图更新</code>，浏览器有自己的优化策略,可能把几次的视图更新累积到一起重绘.重绘之前会通知<code>requestAnimationFrame()</code>执行回调函数.</li><li><code>requestAnimationFrame</code>回调的执行时机是在一次或多次事件循环的<code>UI render</code>阶段。<a href="https://www.cnblogs.com/sunshq/p/5807575.html" target="_blank" rel="noopener">查阅 1</a>,<a href="https://blog.csdn.net/vhwfr2u02q/article/details/79492303" target="_blank" rel="noopener">查阅 2</a></li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h4><p>解析<a href="https://juejin.im/post/5afbc62151882542af04112d" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h4><p>解析<a href="https://github.com/dwqs/blog/issues/61" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">t</span> =&gt;</span> <span class="built_in">console</span>.log(t));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="例-3"><a href="#例-3" class="headerlink" title="例 3"></a>例 3</h4><p>解析<a href="https://segmentfault.com/q/1010000017801324" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">      resolve(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">t</span> =&gt;</span> <span class="built_in">console</span>.log(t));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">t</span> =&gt;</span> <span class="built_in">console</span>.log(t));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h4 id="例-4"><a href="#例-4" class="headerlink" title="例 4"></a>例 4</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise3'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><h4 id="例-5"><a href="#例-5" class="headerlink" title="例 5"></a>例 5</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intervalA = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'intervalA'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line"></span><br><span class="line">  clearInterval(intervalA);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intervalB = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'intervalB'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intervalC = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'intervalC'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    i === <span class="number">9999</span> &amp;&amp; resolve();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise after for-loop'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line"></span><br><span class="line">    clearInterval(intervalB);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise in timeout'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise after timeout'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise4'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise5'</span>);</span><br><span class="line"></span><br><span class="line">    clearInterval(intervalC);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise3'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><h4 id="例-6"><a href="#例-6" class="headerlink" title="例 6"></a>例 6</h4><p>解析<a href="https://zhuanlan.zhihu.com/p/46068171" target="_blank" rel="noopener">查阅</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'start'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'timeout1'</span>);</span></span><br><span class="line">  &#125;, 0);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'timeout2'</span>);</span></span><br><span class="line">  &#125;, 0);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  requestAnimationFrame(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'requestAnimationFrame'</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 输出：start promise1 end promise2 requestAnimationFrame timeout1 timeout2  --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p><img src="http://cdn.flqin.com/p359-2.png" alt="示意图"></p><h2 id="NODE-中的事件循环-适用于-NODE-11-以下"><a href="#NODE-中的事件循环-适用于-NODE-11-以下" class="headerlink" title="NODE 中的事件循环(适用于 NODE 11 以下)"></a>NODE 中的事件循环(适用于 NODE 11 以下)</h2><p><code>Node.js</code>采用<code>V8</code>作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的<code>libuv</code>，<code>libuv</code>是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 API，<code>事件循环机制</code>也是它里面的实现。</p><h3 id="事件循环模型"><a href="#事件循环模型" class="headerlink" title="事件循环模型"></a>事件循环模型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><ul><li>timers: 执行<code>定时器队列中的回调</code>如 setTimeout() 和 setInterval()。</li><li>I/O callbacks: 执行一些<code>系统调用错误</code>，比如网络通信的错误回调。</li><li>idle, prepare: 仅 node 内部使用。</li><li>poll: 等待新的 I/O 事件，node 在一些特殊情况下会阻塞在这里。</li><li>check: 执行<code>setImmediate()的回调</code>。</li><li>close callbacks: 执行 <code>socket 的 close 事件回调</code>，例如 socket.on(‘close’, …)这种。</li></ul><h4 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h4><p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p><ul><li>回到 timer 阶段执行回调</li><li>执行 I/O 回调<ul><li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li><li>如果 poll 队列为空时<ul><li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li><li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li></ul></li></ul></li></ul><p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p><h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>setImmediate()的回调会被加入 check 队列中</p><h3 id="node-事件循环流程"><a href="#node-事件循环流程" class="headerlink" title="node 事件循环流程"></a>node 事件循环流程</h3><p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O 事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段…</p><ul><li><code>event loop</code> 的每个阶段都有一个任务队列。</li><li>当 <code>event loop</code> 到达某个阶段时，将执行该阶段的任务队列，直到队列清空或执行的回调达到系统上限后，才会转入下一个阶段。</li><li>执行完<code>nextTick队列</code>里面的内容。</li><li>执行完<code>微任务队列</code>的内容。</li><li>当所有阶段被顺序执行一次后，称 <code>event loop</code> 完成了一个 <code>tick</code>。</li></ul><h3 id="node-注意点"><a href="#node-注意点" class="headerlink" title="node 注意点"></a>node 注意点</h3><ul><li><code>process.nextTick()</code>:这个函数其实是独立于 <code>Event Loop</code> 之外的，它有一个自己的队列，当<code>每个阶段</code>完成后，如果存在 <code>nextTick 队列</code>，就会清空队列中的所有回调函数，并且<code>优先于其他 microtask 执行</code>。</li><li>如果在 <code>timers</code> 阶段执行时创建了 <code>setImmediate</code> 则会在此轮循环的 <code>check</code> 阶段执行，如果在 <code>timers</code> 阶段创建了 <code>setTimeout</code>，由于 <code>timers</code> 已取出完毕，则会进入下轮循环，<code>check</code> 阶段创建 <code>timers</code> 任务同理。</li><li><code>setTimeout</code> 优先级比 <code>setImmediate</code> 高，但是由于 <code>setTimeout(fn,0)</code>的真正延迟不可能完全为 0 秒，可能出现先创建的 <code>setTimeout(fn,0)</code>而比 <code>setImmediate</code> 的回调后执行的情况。</li></ul><h3 id="node-举例"><a href="#node-举例" class="headerlink" title="node 举例"></a>node 举例</h3><h4 id="node-例-1"><a href="#node-例-1" class="headerlink" title="node 例 1"></a>node 例 1</h4><p>解析<a href="http://lynnelv.github.io/js-event-loop-nodejs" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'test.txt'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'readFile'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//readFile,immediate,timeout</span></span><br></pre></td></tr></table></figure><h4 id="node-例-2"><a href="#node-例-2" class="headerlink" title="node 例 2"></a>node 例 2</h4><p>解析<a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218#heading-14" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise3'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line"><span class="comment">//start=&gt;end=&gt;promise3=&gt;timer1=&gt;timer2=&gt;promise1=&gt;promise2</span></span><br></pre></td></tr></table></figure><h4 id="node-例-3"><a href="#node-例-3" class="headerlink" title="node 例 3"></a>node 例 3</h4><p>解析<a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218#heading-22" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>);</span><br><span class="line">      process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1</span></span><br></pre></td></tr></table></figure><h4 id="node-例-4"><a href="#node-例-4" class="headerlink" title="node 例 4"></a>node 例 4</h4><p>解析<a href="https://juejin.im/post/5aa5dcabf265da239c7afe1e#heading-9" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>() - startTime &lt; time) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1s over'</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout - 1'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout - 1 - 1'</span>);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout - 1 - then'</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setTimeout - 1 - then - then'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout - 2'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout - 2 - 1'</span>);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout - 2 - then'</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setTimeout - 2 - then - then'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout - 1</span></span><br><span class="line"><span class="comment">// 1s over</span></span><br><span class="line"><span class="comment">// setTimeout - 2 //1、2为单阶段task</span></span><br><span class="line"><span class="comment">// 1s over</span></span><br><span class="line"><span class="comment">// setTimeout - 1 - then</span></span><br><span class="line"><span class="comment">// setTimeout - 2 - then</span></span><br><span class="line"><span class="comment">// setTimeout - 1 - then - then</span></span><br><span class="line"><span class="comment">// setTimeout - 2 - then - then</span></span><br><span class="line"><span class="comment">// setTimeout - 1 - 1</span></span><br><span class="line"><span class="comment">// 1s over</span></span><br><span class="line"><span class="comment">// setTimeout - 2 - 1</span></span><br><span class="line"><span class="comment">// 1s over</span></span><br></pre></td></tr></table></figure><h3 id="node-示意图"><a href="#node-示意图" class="headerlink" title="node 示意图"></a>node 示意图</h3><p><img src="http://cdn.flqin.com/p359-3.png" alt="示意图"></p><h3 id="node-11-版本后"><a href="#node-11-版本后" class="headerlink" title="node 11 版本后"></a>node 11 版本后</h3><p><strong>和浏览器趋同，都是每执行一个宏任务就执行完微任务队列</strong>。<a href="https://zhuanlan.zhihu.com/p/54951550" target="_blank" rel="noopener">查阅 1</a>,<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/26" target="_blank" rel="noopener">查阅 2</a></p><h2 id="两者循环区别-NODE-11-之前"><a href="#两者循环区别-NODE-11-之前" class="headerlink" title="两者循环区别(NODE 11 之前)"></a>两者循环区别(NODE 11 之前)</h2><ul><li>浏览器环境下, <code>microtask</code> 的任务队列是每个 <code>macrotask</code> 执行完之后执行。</li><li>在 Node.js 中，<code>microtask</code> 会在事件循环的<code>各个阶段</code>之间执行，也就是一个阶段里所有的 <code>macrotask</code> 执行完毕，才会去执行 <code>microtask</code> 队列的任务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式和发布订阅模式的区别</title>
      <link href="/357.html"/>
      <url>/357.html</url>
      
        <content type="html"><![CDATA[<h2 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h2><p>观察者模式指的是一个对象（Subject）维持一系列依赖于它的对象（Observer），当有关状态发生变更时 Subject 对象则通知一系列 Observer 对象进行更新。</p><p>在观察者模式中，Subject 对象拥有添加、删除和通知一系列 Observer 的方法等等，而 Observer 对象拥有更新方法等等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.list = [];</span><br><span class="line">  &#125;</span><br><span class="line">  add(ob) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(ob);</span><br><span class="line">  &#125;</span><br><span class="line">  remove(ob) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.splice(<span class="keyword">this</span>.list.indexOf(<span class="keyword">this</span>.list.find(<span class="function"><span class="params">item</span> =&gt;</span> ob.id === item.id)), <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  notfiy() &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">      i.update(i.id);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  update(id) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;id&#125;</span>,我被通知了！`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> people1 = <span class="keyword">new</span> Observer(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">let</span> people2 = <span class="keyword">new</span> Observer(<span class="number">9527</span>);</span><br><span class="line"><span class="keyword">let</span> people3 = <span class="keyword">new</span> Observer(<span class="number">89757</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sub = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line">sub.add(people1);</span><br><span class="line">sub.add(people2);</span><br><span class="line">sub.add(people3);</span><br><span class="line"></span><br><span class="line">sub.notfiy();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  sub.remove(people2);</span><br><span class="line">  sub.notfiy();</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><h2 id="发布订阅模式（Publisher-amp-amp-Subscriber）"><a href="#发布订阅模式（Publisher-amp-amp-Subscriber）" class="headerlink" title="发布订阅模式（Publisher &amp;&amp; Subscriber）"></a>发布订阅模式（Publisher &amp;&amp; Subscriber）</h2><p>发布订阅模式指的是希望接收通知的对象（Subscriber）基于一个<code>主题</code>通过自定义事件订阅主题，被激活事件的对象（Publisher）通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发布订阅模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pub</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.list = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  subscribe(name, cb) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.list[name]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.list[name] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.list[name].push(cb);</span><br><span class="line">  &#125;</span><br><span class="line">  unSubscribe(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list[name] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  publish(...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="built_in">Array</span>.from(args).shift();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.list[name] || <span class="keyword">this</span>.list[name].length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>主题没有可发布的事件！`</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.list[name].forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item(args);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> publisher = <span class="keyword">new</span> Pub();</span><br><span class="line"></span><br><span class="line">publisher.subscribe(<span class="string">'event1'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br><span class="line">publisher.subscribe(<span class="string">'event1'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br><span class="line">publisher.subscribe(<span class="string">'event2'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br><span class="line">publisher.subscribe(<span class="string">'event3'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">publisher.publish(<span class="string">'event1'</span>, <span class="string">'额外参数1'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  publisher.unSubscribe(<span class="string">'event2'</span>);</span><br><span class="line">  publisher.publish(<span class="string">'event2'</span>, <span class="string">'额外参数2'</span>);</span><br><span class="line">  publisher.publish(<span class="string">'event3'</span>, <span class="string">'额外参数3'</span>, <span class="string">'额外参数4'</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>发布订阅模式是观察者模式的一种变体。发布订阅只是把一部分功能抽象成一个独立的 ChangeManager。</p><p>在「一对多」的场景下，发布者的某次更新只想通知它的部分订阅者？</p><p>在「多对一」或者「多对多」场景下。一个订阅者依赖于多个发布者，某个发布者更新后是否需要通知订阅者？还是等所有发布者都更新完毕再通知订阅者？</p><p>这些逻辑都可以放到 ChangeManager 里。</p><p>观察者模式中依赖于 Subject 对象的一系列 Observer 对象在被通知之后只能执行同一个特定的更新方法，而在发布订阅模式中则可以基于不同的主题去执行不同的自定义事件。相对而言，发布订阅模式比观察者模式要更加灵活多变。</p><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="http://cdn.flqin.com/p357-1.png" alt="关系图"></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise实现</title>
      <link href="/358.html"/>
      <url>/358.html</url>
      
        <content type="html"><![CDATA[<p>规范查阅 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">英文</a>|<a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">中文</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunc = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Function]'</span>;</span><br><span class="line"><span class="keyword">const</span> isObj = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Object]'</span>;</span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">this</span>.filfulledQueues = [];</span><br><span class="line">    <span class="keyword">this</span>.rejectedQueues = [];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fn(<span class="keyword">this</span>._resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>._reject.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>._reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _resolve(val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      val.then(<span class="keyword">this</span>._resolve, <span class="keyword">this</span>._reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObj(val) || isFunc(val)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFunc(val.then)) &#123;</span><br><span class="line">          val.then(<span class="keyword">this</span>._resolve, <span class="keyword">this</span>._reject);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">this</span>._reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._execCallback(FULFILLED, <span class="keyword">this</span>.filfulledQueues, val);</span><br><span class="line">  &#125;</span><br><span class="line">  _reject(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>._execCallback(REJECTED, <span class="keyword">this</span>.rejectedQueues, val);</span><br><span class="line">  &#125;</span><br><span class="line">  _execCallback(status, list, val) &#123;</span><br><span class="line">    <span class="comment">//规范 2.2.4</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status !== PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.status = status;</span><br><span class="line">      <span class="keyword">this</span>.value = val;</span><br><span class="line">      <span class="keyword">let</span> cb;</span><br><span class="line">      <span class="keyword">while</span> ((cb = list.shift())) &#123;</span><br><span class="line">        cb(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  _resolvePromise(newPromise, x, resolve, reject) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newPromise === x) &#123;</span><br><span class="line">      <span class="comment">//规范 2.3.1</span></span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="comment">//规范 2.3.2</span></span><br><span class="line">      x.then(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObj(x) || isFunc(x)) &#123;</span><br><span class="line">      <span class="comment">//规范 2.3.3</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFunc(x.then)) &#123;</span><br><span class="line">          x.then(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//规范 2.3.4</span></span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">let</span> newPromise;</span><br><span class="line">    onFulfilled = isFunc(onFulfilled) ? onFulfilled : <span class="function"><span class="params">val</span> =&gt;</span> val;</span><br><span class="line">    onRejected = isFunc(onRejected)</span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">// 规范 2.2.7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">newPromise = <span class="keyword">new</span> MyPromise((onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED || <span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">        <span class="comment">//规范 2.2.4</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 规范2.2.5</span></span><br><span class="line">            <span class="keyword">const</span> x = <span class="keyword">this</span>.status === FULFILLED ? onFulfilled(<span class="keyword">this</span>.value) : onRejected(<span class="keyword">this</span>.value);</span><br><span class="line">            <span class="keyword">this</span>._resolvePromise(newPromise, x, onFulfilledNext, onRejectedNext);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            onRejectedNext(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">//规范 2.2.6</span></span><br><span class="line">        <span class="keyword">this</span>.filfulledQueues.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 规范2.2.5</span></span><br><span class="line">            <span class="keyword">const</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">            <span class="keyword">this</span>._resolvePromise(newPromise, x, onFulfilledNext, onRejectedNext);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            onRejectedNext(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//规范 2.2.6</span></span><br><span class="line">        <span class="keyword">this</span>.rejectedQueues.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 规范2.2.5</span></span><br><span class="line">            <span class="keyword">const</span> x = onRejected(<span class="keyword">this</span>.value);</span><br><span class="line">            <span class="keyword">this</span>._resolvePromise(newPromise, x, onFulfilledNext, onRejectedNext);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            onRejectedNext(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span>(cb) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      val =&gt; &#123;</span><br><span class="line">        MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> val);</span><br><span class="line">      &#125;,</span><br><span class="line">      err =&gt; &#123;</span><br><span class="line">        MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> resolve(params) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(params);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> reject(err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> all(params) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> valueList = [];</span><br><span class="line">    <span class="keyword">const</span> promises = <span class="built_in">Array</span>.from(params);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promises.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!item <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          item = MyPromise.resolve(item);</span><br><span class="line">        &#125;</span><br><span class="line">        item.then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          valueList[index] = r;</span><br><span class="line">          <span class="keyword">if</span> (promises.length === ++count) &#123;</span><br><span class="line">            resolve(valueList);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> race(params) &#123;</span><br><span class="line">    <span class="keyword">const</span> promises = <span class="built_in">Array</span>.from(params);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promises.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!item <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          item = MyPromise.resolve(item);</span><br><span class="line">        &#125;</span><br><span class="line">        item.then(resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(转载)nginx配置location总结及rewrite规则写法</title>
      <link href="/356.html"/>
      <url>/356.html</url>
      
        <content type="html"><![CDATA[<h2 id="nginx-介绍"><a href="#nginx-介绍" class="headerlink" title="nginx 介绍"></a>nginx 介绍</h2><p>nginx 是一个高性能的 web 服务器，常用作反向代理服务器。nginx 作为反向代理服务器，就是把 http 请求转发到另一个或者一些服务器上。 通过把本地一个 url 前缀映射到要跨域访问的 web 服务器上，就可以实现跨域访问。 对于浏览器来说，访问的就是同源服务器上的一个 url。而 nginx 通过检测 url 前缀，把 http 请求转发到后面真实的物理服务器。并通过 rewrite 命令把前缀再去掉。这样真实的服务器就可以正确处理请求，并且并不知道这个请求是来自代理服务器的。 简单说，nginx 服务器欺骗了浏览器，让它认为这是同源调用，从而解决了浏览器的跨域问题。又通过重写 url，欺骗了真实的服务器，让它以为这个 http 请求是直接来自与用户浏览器的。 这样，为了解决跨域问题，只需要动一下 nginx 配置文件即可。简单、强大、高效!</p><h2 id="nginx-conf-配置文件"><a href="#nginx-conf-配置文件" class="headerlink" title="nginx.conf 配置文件"></a>nginx.conf 配置文件</h2><p><code>Nginx</code> 配置文件主要分成四部分：<code>main（全局设置）</code>、<code>server（主机设置）</code>、<code>upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）</code>和 <code>location（URL 匹配特定位置后的设置）</code>，每部分包含若干个指令。</p><p><code>main</code> 部分设置的指令将影响其它所有部分的设置；<code>server</code>部分的指令主要用于指定虚拟主机域名、IP 和端口；<code>upstream</code> 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；<code>location</code> 部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。</p><p>他们之间的关系是：<code>server</code> 继承 <code>main</code>，<code>location</code> 继承 <code>server</code>，<code>upstream</code> 既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。</p><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><p>下面的 nginx.conf 简单的实现 nginx 在前端做反向代理服务器的例子，处理 js、png 等静态文件，jsp 等动态请求转发到其它服务器 tomcat：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">user  www www;</span><br><span class="line">worker_processes  2;</span><br><span class="line"></span><br><span class="line">error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  2048;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    # tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">  # gzip压缩功能设置</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_buffers    4 16k;</span><br><span class="line">    gzip_http_version 1.0;</span><br><span class="line">    gzip_comp_level 6;</span><br><span class="line">    gzip_types text/html text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">  # http_proxy 设置</span><br><span class="line">    client_max_body_size   10m;</span><br><span class="line">    client_body_buffer_size   128k;</span><br><span class="line">    proxy_connect_timeout   75;</span><br><span class="line">    proxy_send_timeout   75;</span><br><span class="line">    proxy_read_timeout   75;</span><br><span class="line">    proxy_buffer_size   4k;</span><br><span class="line">    proxy_buffers   4 32k;</span><br><span class="line">    proxy_busy_buffers_size   64k;</span><br><span class="line">    proxy_temp_file_write_size  64k;</span><br><span class="line">    proxy_temp_path   /usr/local/nginx/proxy_temp 1 2;</span><br><span class="line"></span><br><span class="line">  # 设定负载均衡后台服务器列表</span><br><span class="line">    upstream  backend  &#123;</span><br><span class="line">              #ip_hash;</span><br><span class="line">              server   192.168.10.100:8080 max_fails=2 fail_timeout=30s ;</span><br><span class="line">              server   192.168.10.101:8080 max_fails=2 fail_timeout=30s ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  # 很重要的虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  itoatest.example.com;</span><br><span class="line">        root   /apps/oaapp;</span><br><span class="line"></span><br><span class="line">        charset utf-8;</span><br><span class="line">        access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        #对 / 所有做负载均衡+反向代理</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /apps/oaapp;</span><br><span class="line">            index  index.jsp index.html index.htm;</span><br><span class="line"></span><br><span class="line">            proxy_pass        http://backend;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header  Host  $host;</span><br><span class="line">            proxy_set_header  X-Real-IP  $remote_addr;</span><br><span class="line">            proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #静态文件，nginx自己处理，不去backend请求tomcat</span><br><span class="line">        location  ~* /download/ &#123;</span><br><span class="line">            root /apps/oa/fs;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        location ~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$</span><br><span class="line">        &#123;</span><br><span class="line">            root /apps/oaapp;</span><br><span class="line">            expires      7d;</span><br><span class="line">        &#125;</span><br><span class="line">        location /nginx_status &#123;</span><br><span class="line">            stub_status on;</span><br><span class="line">            access_log off;</span><br><span class="line">            allow 192.168.10.0/24;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ ^/(WEB-INF)/ &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ## 其它虚拟主机，server 指令开始</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用指令说明"><a href="#常用指令说明" class="headerlink" title="常用指令说明"></a>常用指令说明</h3><h4 id="main-全局配置"><a href="#main-全局配置" class="headerlink" title="main 全局配置"></a>main 全局配置</h4><p>nginx 在运行时与具体业务功能（比如 http 服务或者 email 服务代理）无关的一些参数，比如工作进程数，运行的身份等。</p><ul><li><p><code>woker_processes 2</code></p><p>在配置文件的顶级 main 部分，worker 角色的工作进程的个数，master 进程是接收并分配请求给 worker 处理。这个数值简单一点可以设置为 cpu 的核数 grep ^processor /proc/cpuinfo | wc -l，也是 auto 值，如果开启了 ssl 和 gzip 更应该设置成与逻辑 CPU 数量一样甚至为 2 倍，可以减少 I/O 操作。如果 nginx 服务器还有其它服务，可以考虑适当减少。</p></li><li><p><code>worker_cpu_affinity</code></p><p>也是写在 main 部分。在高并发情况下，通过设置 cpu 粘性来降低由于多 CPU 核切换造成的寄存器等现场重建带来的性能损耗。如 worker_cpu_affinity 0001 0010 0100 1000; （四核）。</p></li><li><p><code>worker_connections 2048</code></p><p>写在 events 部分。每一个 worker 进程能并发处理（发起）的最大连接数（包含与客户端或后端被代理服务器间等所有连接数）。nginx 作为反向代理服务器，计算公式 最大连接数 = worker_processes * worker_connections/4，所以这里客户端最大连接数是 1024，这个可以增到到 8192 都没关系，看情况而定，但不能超过后面的 worker_rlimit_nofile。当 nginx 作为 http 服务器时，计算公式里面是除以 2。</p></li><li><p><code>worker_rlimit_nofile 10240</code></p><p>写在 main 部分。默认是没有设置，可以限制为操作系统最大的限制 65535。</p></li><li><p><code>use epoll</code></p><p>写在 events 部分。在 Linux 操作系统下，nginx 默认使用 epoll 事件模型，得益于此，nginx 在 Linux 操作系统下效率相当高。同时 Nginx 在 OpenBSD 或 FreeBSD 操作系统上采用类似于 epoll 的高效事件模型 kqueue。在操作系统不支持这些高效模型时才使用 select。</p></li></ul><h4 id="http-服务器"><a href="#http-服务器" class="headerlink" title="http 服务器"></a>http 服务器</h4><p>与提供 http 服务相关的一些配置参数。例如：是否使用 keepalive 啊，是否使用 gzip 进行压缩等。</p><ul><li><p><code>sendfile on</code></p><p>开启高效文件传输模式，sendfile 指令指定 nginx 是否调用 sendfile 函数来输出文件，减少用户空间到内核空间的上下文切换。对于普通应用设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的负载。</p></li><li><p><code>keepalive_timeout 65</code></p><p>长连接超时时间，单位是秒，这个参数很敏感，涉及浏览器的种类、后端服务器的超时设置、操作系统的设置，可以另外起一片文章了。长连接请求大量小文件的时候，可以减少重建连接的开销，但假如有大文件上传，65s 内没上传完成会导致失败。如果设置时间过长，用户又多，长时间保持连接会占用大量资源。</p></li><li><p><code>send_timeout</code></p><p>用于指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx 将会关闭连接。</p></li><li><p><code>client_max_body_size 10m</code></p><p>允许客户端请求的最大单文件字节数。如果有上传较大文件，请设置它的限制值</p></li><li><p><code>client_body_buffer_size 128k</code></p><p>缓冲区代理缓冲用户端请求的最大字节数</p></li></ul><h5 id="模块-http-proxy"><a href="#模块-http-proxy" class="headerlink" title="模块 http_proxy"></a>模块 http_proxy</h5><p>这个模块实现的是 nginx 作为反向代理服务器的功能，包括缓存功能（另见文章）</p><ul><li><p><code>proxy_connect_timeout 60</code></p><p>nginx 跟后端服务器连接超时时间(代理连接超时)</p></li><li><p><code>proxy_read_timeout 60</code></p><p>连接成功后，与后端服务器两个成功的响应操作之间超时时间(代理接收超时)</p></li><li><p><code>proxy_buffer_size 4k</code></p><p>设置代理服务器（nginx）从后端 realserver 读取并保存用户头信息的缓冲区大小，默认与 proxy_buffers 大小相同，其实可以将这个指令值设的小一点</p></li><li><p><code>proxy_buffers 4 32k</code></p><p>proxy_buffers 缓冲区，nginx 针对单个连接缓存来自后端 realserver 的响应，网页平均在 32k 以下的话，这样设置</p></li><li><p><code>proxy_busy_buffers_size 64k</code></p><p>高负荷下缓冲大小（proxy_buffers*2）</p></li><li><p><code>proxy_max_temp_file_size</code></p><p>当 proxy_buffers 放不下后端服务器的响应内容时，会将一部分保存到硬盘的临时文件中，这个值用来设置最大临时文件大小，默认 1024M，它与 proxy_cache 没有关系。大于这个值，将从 upstream 服务器传回。设置为 0 禁用。</p></li><li><p><code>proxy_temp_file_write_size 64k</code></p><p>当缓存被代理的服务器响应到临时文件时，这个选项限制每次写临时文件的大小。proxy_temp_path（可以在编译的时候）指定写到哪那个目录。</p></li></ul><h5 id="模块-http-gzip"><a href="#模块-http-gzip" class="headerlink" title="模块 http_gzip"></a>模块 http_gzip</h5><ul><li><p><code>gzip on</code> : 开启 gzip 压缩输出，减少网络传输。</p><ul><li><code>gzip_min_length 1k</code> ： 设置允许压缩的页面最小字节数，页面字节数从 header 头得 content-length 中进行获取。默认值是 20。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大。</li><li><code>gzip_buffers 4 16k</code> ： 设置系统获取几个单位的缓存用于存储 gzip 的压缩结果数据流。4 16k 代表以 16k 为单位，安装原始数据大小以 16k 为单位的 4 倍申请内存。</li><li><code>gzip_http_version 1.0</code> ： 用于识别 http 协议的版本，早期的浏览器不支持 Gzip 压缩，用户就会看到乱码，所以为了支持前期版本加上了这个选项，如果你用了 Nginx 的反向代理并期望也启用 Gzip 压缩的话，由于末端通信是 http/1.0，故请设置为 1.0。</li><li><code>gzip_comp_level 6</code> ： gzip 压缩比，1 压缩比最小处理速度最快，9 压缩比最大但处理速度最慢(传输快但比较消耗 cpu)</li><li><code>gzip_types</code> ：匹配 mime 类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。</li><li><code>gzip_proxied any</code> ： Nginx 作为反向代理的时候启用，决定开启或者关闭后端服务器返回的结果是否压缩，匹配的前提是后端服务器必须要返回包含”Via”的 header 头。</li><li><code>gzip_vary on</code> ： 和 http 头有关系，会在响应头加个 Vary: Accept-Encoding ，可以让前端的缓存服务器缓存经过 gzip 压缩的页面，例如，用 Squid 缓存经过 Nginx 压缩的数据。。</li></ul></li></ul><h4 id="server-虚拟主机"><a href="#server-虚拟主机" class="headerlink" title="server 虚拟主机"></a>server 虚拟主机</h4><p>http 服务上支持若干虚拟主机。每个虚拟主机一个对应的 server 配置项，配置项里面包含该虚拟主机相关的配置。在提供 mail 服务的代理时，也可以建立若干 server。每个 server 通过监听地址或端口来区分。</p><ul><li><code>listen</code>:监听端口，默认 80，小于 1024 的要以 root 启动。可以为 listen *:80、listen 127.0.0.1:80 等形式。</li><li><code>server_name</code>:服务器名，如 localhost、<a href="http://www.example.com，可以通过正则匹配。" target="_blank" rel="noopener">www.example.com，可以通过正则匹配。</a></li></ul><h5 id="模块-http-stream"><a href="#模块-http-stream" class="headerlink" title="模块 http_stream"></a>模块 http_stream</h5><p>这个模块通过一个简单的调度算法来实现客户端 IP 到后端服务器的负载均衡，upstream 后接负载均衡器的名字，后端 realserver 以 host:port options; 方式组织在 {} 中。如果后端被代理的只有一台，也可以直接写在 proxy_pass 。</p><h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p>http 服务中，某些特定的 URL 对应的一系列配置项。</p><ul><li><p><code>root /var/www/html</code></p><p>定义服务器的默认网站根目录位置。如果 locationURL 匹配的是子目录或文件，root 没什么作用，一般放在 server 指令里面或/下。</p></li><li><p><code>index.jsp index.html index.htm</code></p><p>定义路径下默认访问的文件名，一般跟着 root 放</p></li><li><p><code>proxy_pass http:/backend</code></p><p>请求转向 backend 定义的服务器列表，即反向代理，对应 upstream 负载均衡器。也可以 <code>proxy_pass http://ip:port</code>。</p></li><li><p><code>proxy_redirect off;</code></p><p><code>proxy_set_header Host \$host;</code></p><p><code>proxy_set_header X-Real-IP \$remote_addr;</code></p><p><code>proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;</code></p><p>这四个暂且这样设，如果深究的话，每一个都涉及到很复杂的内容，也将通过另一篇文章来解读。</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="访问控制-allow-deny"><a href="#访问控制-allow-deny" class="headerlink" title="访问控制 allow/deny"></a>访问控制 allow/deny</h4><p>Nginx 的访问控制模块默认就会安装，而且写法也非常简单，可以分别有多个 allow,deny，允许或禁止某个 ip 或 ip 段访问，依次满足任何一个规则就停止往下匹配。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location /nginx-status &#123;</span><br><span class="line">  stub_status on;</span><br><span class="line">  access_log off;</span><br><span class="line">#  auth_basic   &quot;NginxStatus&quot;;</span><br><span class="line">#  auth_basic_user_file   /usr/local/nginx-1.6/htpasswd;</span><br><span class="line"></span><br><span class="line">  allow 192.168.10.100;</span><br><span class="line">  allow 172.29.73.0/24;</span><br><span class="line">  deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也常用 httpd-devel 工具的 htpasswd 来为访问的路径设置登录密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># htpasswd -c htpasswd admin</span><br><span class="line">New passwd:</span><br><span class="line">Re-type new password:</span><br><span class="line">Adding password for user admin</span><br><span class="line"></span><br><span class="line"># htpasswd htpasswd admin    //修改admin密码</span><br><span class="line"># htpasswd htpasswd sean    //多添加一个认证用户</span><br></pre></td></tr></table></figure><p>这样就生成了默认使用 CRYPT 加密的密码文件。打开上面 nginx-status 的两行注释，重启 nginx 生效。</p><h4 id="列出目录-autoindex"><a href="#列出目录-autoindex" class="headerlink" title="列出目录 autoindex"></a>列出目录 autoindex</h4><p>Nginx 默认是不允许列出整个目录的。如需此功能，打开 nginx.conf 文件，在 location，server 或 http 段中加入 autoindex on;，另外两个参数最好也加上去:</p><ul><li><p><code>autoindex_exact_size off;</code></p><p>默认为 on，显示出文件的确切大小，单位是 bytes。改为 off 后，显示出文件的大概大小，单位是 kB 或者 MB 或者 GB</p></li><li><p><code>autoindex_localtime on;</code></p><p>默认为 off，显示的文件时间为 GMT 时间。改为 on 后，显示的文件时间为文件的服务器时间</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /images &#123;</span><br><span class="line">  root   /var/www/nginx-default/images;</span><br><span class="line">  autoindex on;</span><br><span class="line">  autoindex_exact_size off;</span><br><span class="line">  autoindex_localtime on;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="重新加载-nginx-配置文件"><a href="#重新加载-nginx-配置文件" class="headerlink" title="重新加载 nginx 配置文件"></a>重新加载 nginx 配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="location-正则写法"><a href="#location-正则写法" class="headerlink" title="location 正则写法"></a>location 正则写法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">location  = / &#123;</span><br><span class="line">  # 精确匹配 / ，主机名后面不能带任何字符串</span><br><span class="line">  [ configuration A ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location  / &#123;</span><br><span class="line">  # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求</span><br><span class="line">  # 但是正则和最长字符串会优先匹配</span><br><span class="line">  [ configuration B ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /documents/ &#123;</span><br><span class="line">  # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索</span><br><span class="line">  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span><br><span class="line">  [ configuration C ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /documents/Abc &#123;</span><br><span class="line">  # 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索</span><br><span class="line">  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span><br><span class="line">  [ configuration CC ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">  # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。</span><br><span class="line">  [ configuration D ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">  # 匹配所有以 gif,jpg或jpeg 结尾的请求</span><br><span class="line">  # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则</span><br><span class="line">  [ configuration E ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /images/ &#123;</span><br><span class="line">  # 字符匹配到 /images/，继续往下，会发现 ^~ 存在</span><br><span class="line">  [ configuration F ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /images/abc &#123;</span><br><span class="line">  # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在</span><br><span class="line">  # F与G的放置顺序是没有关系的</span><br><span class="line">  [ configuration G ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /images/abc/ &#123;</span><br><span class="line">  # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用</span><br><span class="line">    [ configuration H ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* /js/.*/\.js</span><br></pre></td></tr></table></figure><ul><li>以<code>=</code>开头表示精确匹配</li><li>如<code>A</code>中只匹配根目录结尾的请求，后面不能带任何字符串。</li><li><code>^~</code>开头表示<code>uri</code>以某个常规字符串开头，不是正则匹配</li><li><code>~</code>开头表示区分大小写的正则匹配;</li><li><code>~\*</code>开头表示不区分大小写的正则匹配</li><li><code>/</code>通用匹配, 如果没有其它匹配,任何请求都会匹配到</li><li>顺序<code>(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</code></li></ul><p>按照上面的 location 写法，以下的匹配示例成立:</p><ul><li>/ -&gt; config A<br>精确完全匹配，即使/index.html 也匹配不了</li><li>/downloads/download.html -&gt; config B<br>匹配 B 以后，往下没有任何匹配，采用 B</li><li>/images/1.gif -&gt; configuration D<br>匹配到 F，往下匹配到 D，停止往下</li><li>/images/abc/def -&gt; config D<br>最长匹配到 G，往下匹配 D，停止往下<br>你可以看到 任何以/images/开头的都会匹配到 D 并停止，FG 写在这里是没有任何意义的，H 是永远轮不到的，这里只是为了说明匹配顺序</li><li>/documents/document.html -&gt; config C<br>匹配到 C，往下没有任何匹配，采用 C</li><li>/documents/1.jpg -&gt; configuration E<br>匹配到 C，往下正则匹配到 E</li><li>/documents/Abc.jpg -&gt; config CC<br>最长匹配到 C，往下正则顺序匹配到 CC，不会往下到 E</li></ul><p>实际使用建议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">所以实际使用中，个人觉得至少有三个匹配规则定义，如下：</span><br><span class="line">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。</span><br><span class="line">#这里是直接转发给后端应用服务器了，也可以是一个静态首页</span><br><span class="line"># 第一个必选规则</span><br><span class="line">location = / &#123;</span><br><span class="line">    proxy_pass http://tomcat:8080/index</span><br><span class="line">&#125;</span><br><span class="line"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span><br><span class="line"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span><br><span class="line">location ^~ /static/ &#123;</span><br><span class="line">    root /webroot/static/;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">    root /webroot/res/;</span><br><span class="line">&#125;</span><br><span class="line">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span><br><span class="line">#非静态文件请求就默认是动态请求，自己根据实际把握</span><br><span class="line">#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://tomcat:8080/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Rewrite-规则"><a href="#Rewrite-规则" class="headerlink" title="Rewrite 规则"></a>Rewrite 规则</h2><p><code>rewrite</code>使用<code>nginx</code>提供的全局变量或自己设置的变量，结合<code>正则表达式</code>和<code>标志位</code>实现 url 重写以及重定向。</p><p><code>rewrite</code> 只能放在 <code>server{},location{},if{}</code>中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 <code>http://seanlook.com/a/we/index.php?id=1&amp;u=str</code> 只对<code>/a/we/index.php</code> 重写。</p><p>如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用 <code>proxy_pass</code> 反向代理。</p><p>表明看 <code>rewrite</code> 和 <code>location</code> 功能有点像，都能实现跳转，主要区别在于 <code>rewrite</code> 是在同一域名内更改获取资源的路径，而 <code>location</code> 是对一类路径做控制访问或反向代理，可以 <code>proxy_pass</code> 到其他机器。很多情况下 <code>rewrite</code> 也会写在 <code>location</code> 里，它们的执行顺序是：</p><ul><li>执行 <code>server</code> 块的 <code>rewrite</code> 指令</li><li>执行 location 匹配</li><li>执行选定的 location 中的 rewrite 指令</li></ul><p>如果其中某步 <code>URI</code> 被重写，则重新循环执行 <code>1-3</code>，直到找到真实存在的文件；循环超过 10 次，则返回 500 Internal Server Error 错误。</p><h3 id="flag-标志位"><a href="#flag-标志位" class="headerlink" title="flag 标志位"></a>flag 标志位</h3><ul><li><code>last</code> : 相当于 Apache 的<code>[L]</code>标记，表示完成 rewrite</li><li><code>break</code> : 停止执行当前虚拟主机的后续 rewrite 指令集</li><li><code>redirect</code> : 返回 302 临时重定向，地址栏会显示跳转后的地址</li><li><code>permanent</code> : 返回 301 永久重定向，地址栏会显示跳转后的地址</li></ul><p>因为 301 和 302 不能简单的只返回状态码，还必须有重定向的 URL，这就是 return 指令无法返回 301,302 的原因了。这里 last 和 break 区别有点难以理解：</p><ul><li>last 一般写在 server 和 if 中，而 break 一般使用在 location 中</li><li>last 不终止重写后的 url 匹配，即新的 url 会再从 server 走一遍匹配流程，而 break 终止重写后的匹配</li><li>break 和 last 都能阻止继续执行后面的 rewrite 指令</li></ul><h3 id="if-指令与全局变量"><a href="#if-指令与全局变量" class="headerlink" title="if 指令与全局变量"></a>if 指令与全局变量</h3><h4 id="if-判断指令"><a href="#if-判断指令" class="headerlink" title="if 判断指令"></a>if 判断指令</h4><p>语法为 <code>if(condition){...}</code>，对给定的条件 <code>condition</code> 进行判断。如果为真，大括号内的 <code>rewrite</code> 指令将被执行，if 条件(<code>conditon</code>)可以是如下任何内容：</p><ul><li>当表达式只是一个变量时，如果值为空或任何以 0 开头的字符串都会当做 false</li><li>直接比较变量和内容时，使用<code>=或!=</code></li><li><code>~</code>正则表达式匹配，<code>~\*</code>不区分大小写的匹配，<code>!~</code>区分大小写的不匹配</li><li><code>-f 和!-f</code> 用来判断是否存在文件</li><li>`-d 和!-d 用来判断是否存在目录</li><li><code>-e 和!-e</code> 用来判断是否存在文件或目录</li><li><code>-x 和!-x</code> 用来判断文件是否可执行</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125; //如果UA包含&quot;MSIE&quot;，rewrite请求到/msid/目录下</span><br><span class="line"></span><br><span class="line">if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) &#123;</span><br><span class="line">    set $id $1;</span><br><span class="line"> &#125; //如果cookie匹配正则，设置变量$id等于正则引用部分</span><br><span class="line"></span><br><span class="line">if ($request_method = POST) &#123;</span><br><span class="line">    return 405;</span><br><span class="line">&#125; //如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302</span><br><span class="line"></span><br><span class="line">if ($slow) &#123;</span><br><span class="line">    limit_rate 10k;</span><br><span class="line">&#125; //限速，$slow可以通过 set 指令设置</span><br><span class="line"></span><br><span class="line">if (!-f $request_filename)&#123;</span><br><span class="line">    break;</span><br><span class="line">    proxy_pass  http://127.0.0.1;</span><br><span class="line">&#125; //如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查</span><br><span class="line"></span><br><span class="line">if ($args ~ post=140)&#123;</span><br><span class="line">    rewrite ^ http://example.com/ permanent;</span><br><span class="line">&#125; //如果query string中包含&quot;post=140&quot;，永久重定向到example.com</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|png|swf|flv)$ &#123;</span><br><span class="line">    valid_referers none blocked www.jefflei.com www.leizhenfang.com;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        return 404;</span><br><span class="line">    &#125; //防盗链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>下面是可以用作 if 判断的全局变量:</p><ul><li><code>$args</code> ： #这个变量等于请求行中的参数，同$query_string</li><li><code>$content_length</code> ： 请求头中的 Content-length 字段。</li><li><code>$content_type</code> ： 请求头中的 Content-Type 字段。</li><li><code>$document_root</code> ： 当前请求在 root 指令中指定的值。</li><li><code>$host</code> ： 请求主机头字段，否则为服务器名称。</li><li><code>$http_user_agent</code> ： 客户端 agent 信息</li><li><code>$http_cookie</code> ： 客户端 cookie 信息</li><li><code>$limit_rate</code> ： 这个变量可以限制连接速率。</li><li><code>$request_method</code> ： 客户端请求的动作，通常为 GET 或 POST。</li><li><code>$remote_addr</code> ： 客户端的 IP 地址。</li><li><code>$remote_port</code> ： 客户端的端口。</li><li><code>$remote_user</code> ： 已经经过 Auth Basic Module 验证的用户名。</li><li><code>$request_filename</code> ： 当前请求的文件路径，由 root 或 alias 指令与 URI 请求生成。</li><li><code>$scheme</code> ： HTTP 方法（如 http，https）。</li><li><code>$server_protocol</code> ： 请求使用的协议，通常是 HTTP/1.0 或 HTTP/1.1。</li><li><code>$server_addr</code> ： 服务器地址，在完成一次系统调用后可以确定这个值。</li><li><code>$server_name</code> ： 服务器名称。</li><li><code>$server_port</code> ： 请求到达服务器的端口号。</li><li><code>$request_uri</code> ： 包含请求参数的原始 URI，不包含主机名，如：”/foo/bar.php?arg=baz”。</li><li><code>$uri</code> ： 不带请求参数的当前 URI，$uri 不包含主机名，如”/foo/bar.html”。</li><li><code>$document_uri</code> ： 与$uri 相同。</li></ul><p>例：<code>http://localhost:88/test1/test2/test.php</code></p><ul><li><code>$host</code>：<code>localhost</code></li><li><code>$server_port</code>：<code>88</code></li><li><code>$request_uri</code>：<code>http://localhost:88/test1/test2/test.php</code></li><li><code>$document_uri</code>：<code>/test1/test2/test.php</code></li><li><code>$document_root</code>：<code>/var/www/html</code></li><li><code>$request_filename</code>：<code>/var/www/html/test1/test2/test.php</code></li></ul><h4 id="rewrite-实例"><a href="#rewrite-实例" class="headerlink" title="rewrite 实例"></a>rewrite 实例</h4><p>例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">http &#123; # 定义 image 日志格式</span><br><span class="line">log_format imagelog &apos;[$time_local] &apos; $image_file &apos; &apos; $image_type &apos; &apos; $body_bytes_sent &apos; &apos; $status; # 开启重写日志</span><br><span class="line">rewrite_log on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        root /home/www;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                # 重写规则信息</span><br><span class="line">                error_log logs/rewrite.log notice;</span><br><span class="line">                # 注意这里要用‘’单引号引起来，避免&#123;&#125;</span><br><span class="line">                rewrite &apos;^/images/([a-z]&#123;2&#125;)/([a-z0-9]&#123;5&#125;)/(.*)\.(png|jpg|gif)$&apos; /data?file=$3.$4;</span><br><span class="line">                # 注意不能在上面这条规则后面加上“last”参数，否则下面的set指令不会执行</span><br><span class="line">                set $image_file $3;</span><br><span class="line">                set $image_type $4;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /data &#123;</span><br><span class="line">                # 指定针对图片的日志格式，来分析图片类型和大小</span><br><span class="line">                access_log logs/images.log mian;</span><br><span class="line">                root /data/images;</span><br><span class="line">                # 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最后一个url里</span><br><span class="line">                try_files /$arg_file /image404.html;</span><br><span class="line">        &#125;</span><br><span class="line">        location = /image404.html &#123;</span><br><span class="line">                # 图片不存在返回特定的信息</span><br><span class="line">                return 404 &quot;image not found\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对形如<code>/images/ef/uh7b3/test.png</code> 的请求，重写到<code>/data?file=test.png</code>，于是匹配到 <code>location /data</code>，先看<code>/data/images/test.png</code> 文件存不存在，如果存在则正常响应，如果不存在则重写 <code>tryfiles</code> 到新的 <code>image404 location</code>，直接返回 <code>404</code> 状态码。</p><p>例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^/images/(.\*)\_(\d+)x(\d+)\.(png|jpg|gif)$ /resizer/$1.$4?width=$2&amp;height=\$3? last;</span><br></pre></td></tr></table></figure><p>对形如<code>/images/bla_500x400.jpg</code> 的文件请求，重写到<code>/resizer/bla.jpg?width=500&amp;height=400</code> 地址，并会继续尝试匹配 <code>location</code>。</p><p>例 3：</p><p><a href="http://seanlook.com/2015/05/28/nginx-ssl/" target="_blank" rel="noopener">ssl 部分页面加密</a></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深浅拷贝总结</title>
      <link href="/355.html"/>
      <url>/355.html</url>
      
        <content type="html"><![CDATA[<h2 id="深浅拷贝的区分"><a href="#深浅拷贝的区分" class="headerlink" title="深浅拷贝的区分"></a>深浅拷贝的区分</h2><p>深浅拷贝，只针对复杂数据类型来说的。</p><h3 id="浅拷贝-ShallowCopy"><a href="#浅拷贝-ShallowCopy" class="headerlink" title="浅拷贝 (ShallowCopy)"></a>浅拷贝 (ShallowCopy)</h3><p>是一个对象的逐位副本。创建一个新对象，该对象具有原始对象中的精确副本。如果对象的任何字段是对其他对象的引用，则只复制引用地址，即只复制内存地址，而不复制对象本身，新旧对象还是共享同一块堆内存。改变其中一个对象，另一个也会受影响。如果有修改，会失去原始数据。</p><h3 id="深拷贝-DeepCopy"><a href="#深拷贝-DeepCopy" class="headerlink" title="深拷贝 (DeepCopy)"></a>深拷贝 (DeepCopy)</h3><p>复制出一个全新的对象实例，新对象跟原对象不共享内存，两者操作互不影响。</p><p><strong>深拷贝是一个很复杂的问题，边缘 case 太多，比如<code>环引</code>、<code>原生 DOM/BOM对象</code>、<code>RegExp</code>、<code>Date</code>、<code>包装类Number,String,Boolean</code> 、<code>函数</code>、<code>原型链</code>、<code>不可枚举的属性</code>、<code>set/map/weakset/weakmap</code>、<code>Symbol</code>等，很多深拷贝如<code>函数</code>、<code>RegExp</code>等在实际运用中都没有多大意义，如果在开发中遇到需要深拷贝的地方，首先考虑代码设计问题，它面对的问题往往可以用更优雅的方式解决。</strong></p><h2 id="浅拷贝方法"><a href="#浅拷贝方法" class="headerlink" title="浅拷贝方法"></a>浅拷贝方法</h2><h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">o1.a = <span class="number">2</span>;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o2.a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b === a); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Array-concat"><a href="#Array-concat" class="headerlink" title="Array.concat()"></a>Array.concat()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = [<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> o2 = o1.concat(); <span class="comment">// 这里会返回一个o1对象的浅拷贝对象</span></span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">//  [1, [2], 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(o1 === o2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Array-slice"><a href="#Array-slice" class="headerlink" title="Array.slice()"></a>Array.slice()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = [<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> o2 = o1.slice(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">// [1, [2], 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(o1 === o2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p><code>Object.assign()</code>方法用于将所有可枚举的自有属性的值从一个或多个源对象复制到目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">3</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.assign(&#123;&#125;, o1);</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123; a : 1, b : &#123; c : 2, d : 3&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">// &#123; a : 1, b : &#123; c : 2, d : 3&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2 === o1); <span class="comment">// false    说明实现了浅拷贝</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝方法"><a href="#深拷贝方法" class="headerlink" title="深拷贝方法"></a>深拷贝方法</h2><h3 id="手动拷贝"><a href="#手动拷贝" class="headerlink" title="手动拷贝"></a>手动拷贝</h3><p>将每个引用对象都通过复制值来实现深拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">a</span>: o1.a, <span class="attr">b</span>: o1.b &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o2 === o1); <span class="comment">// false</span></span><br><span class="line">o1.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123;a: 2, b: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure><p>该方法只适合简单的对象，并且没有引用的属性，适用范围很窄。</p><h3 id="JSON-parse-JSON-stringify-（常用）"><a href="#JSON-parse-JSON-stringify-（常用）" class="headerlink" title="JSON.parse(JSON.stringify()) （常用）"></a>JSON.parse(JSON.stringify()) （常用）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(o1));</span><br><span class="line"><span class="built_in">console</span>.log(o1 === o2); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(o1.b === o2.b); <span class="comment">// false</span></span><br><span class="line">o1.b.c = <span class="number">22</span>;</span><br><span class="line">o1.a = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">//   &#123; a : 11, b : &#123; c : 22&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">//   &#123; a : 1, b : &#123; c : 2&#125; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>该方法只能深拷贝对象和数组，内部递归实现，毕竟 JSON 的两个方法本身就只是用来转换 js 内的对象为 JSON 格式</li><li>Set 类型、Map 类型以及 Buffer 类型会被转换成 {}</li><li>undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）</li><li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误</li><li>所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们</li><li>不可枚举的属性会被忽略</li></ul><h3 id="迭代递归法（常用）"><a href="#迭代递归法（常用）" class="headerlink" title="迭代递归法（常用）"></a>迭代递归法（常用）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(x) === <span class="string">'[object Object]'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(obj)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'obj 不是一个对象！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isArray = <span class="built_in">Array</span>.isArray(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = isArray ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法存在的问题：</p><ul><li>适合一般<code>对象</code>和<code>数组</code>的拷贝</li><li>层级太深时容易爆栈</li><li>未考虑<code>func,date,reg,err,Map,Set,Symbol,原型链，不可枚举</code>等 case</li><li>未考虑循环引用</li></ul><h3 id="循环法"><a href="#循环法" class="headerlink" title="循环法"></a>循环法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保持引用关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneForce</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// =============</span></span><br><span class="line">  <span class="keyword">const</span> uniqueList = []; <span class="comment">// 用来去重</span></span><br><span class="line">  <span class="comment">// =============</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环数组</span></span><br><span class="line">  <span class="keyword">const</span> loopList = [</span><br><span class="line">    &#123;</span><br><span class="line">      parent: root,</span><br><span class="line">      key: <span class="literal">undefined</span>,</span><br><span class="line">      data: x</span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (loopList.length) &#123;</span><br><span class="line">    <span class="comment">// 广度优先</span></span><br><span class="line">    <span class="keyword">const</span> node = loopList.pop();</span><br><span class="line">    <span class="keyword">const</span> parent = node.parent;</span><br><span class="line">    <span class="keyword">const</span> key = node.key;</span><br><span class="line">    <span class="keyword">const</span> data = node.data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class="line">    <span class="keyword">let</span> res = parent;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      res = parent[key] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =============</span></span><br><span class="line">    <span class="comment">// 数据已经存在</span></span><br><span class="line">    <span class="keyword">let</span> uniqueData = find(uniqueList, data);</span><br><span class="line">    <span class="keyword">if</span> (uniqueData) &#123;</span><br><span class="line">      parent[key] = uniqueData.target;</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// 中断本次循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据不存在</span></span><br><span class="line">    <span class="comment">// 保存源数据，在拷贝数据中对应的引用</span></span><br><span class="line">    uniqueList.push(&#123;</span><br><span class="line">      source: data,</span><br><span class="line">      target: res</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// =============</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> data[k] === <span class="string">'object'</span>) &#123;</span><br><span class="line">          <span class="comment">// 下一次循环</span></span><br><span class="line">          loopList.push(&#123;</span><br><span class="line">            parent: res,</span><br><span class="line">            key: k,</span><br><span class="line">            data: data[k]</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          res[k] = data[k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i].source === item) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该方法未采用递归，采用循环的方式遍历，不会爆栈。</li><li>解决了循环引用的问题。</li><li>未考虑<code>func,date,reg,err,Map,Set,Symbol,原型链，不可枚举</code>等 case</li></ul><h3 id="结构化克隆方法"><a href="#结构化克隆方法" class="headerlink" title="结构化克隆方法"></a>结构化克隆方法</h3><p>结构化算法嗦支持的拷贝类型见<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/The_structured_clone_algorithm" target="_blank" rel="noopener">文档</a></p><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage()"></a>postMessage()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;port1, port2&#125; = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">    port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">const</span> clone = <span class="keyword">await</span> structuralClone(obj);</span><br></pre></td></tr></table></figure><p>特点：异步、兼容性 ok</p><h4 id="Notification-API"><a href="#Notification-API" class="headerlink" title="Notification API"></a>Notification API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Notification(<span class="string">''</span>, &#123;<span class="attr">data</span>: obj, <span class="attr">silent</span>: <span class="literal">true</span>&#125;).data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">const</span> clone = structuralClone(obj);</span><br></pre></td></tr></table></figure><p>特点：简洁、兼容性不佳（safari 全系列不支持）</p><h4 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldState = history.state;</span><br><span class="line">  history.replaceState(obj, <span class="built_in">document</span>.title);</span><br><span class="line">  <span class="keyword">const</span> copy = history.state;</span><br><span class="line">  history.replaceState(oldState, <span class="built_in">document</span>.title);</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">const</span> clone = structuralClone(obj);</span><br></pre></td></tr></table></figure><p>特点：Safari 对 replaceState 调用的限制数量为 30 秒内 100 次。</p><h2 id="深拷贝中其他类型的拷贝"><a href="#深拷贝中其他类型的拷贝" class="headerlink" title="深拷贝中其他类型的拷贝"></a>深拷贝中其他类型的拷贝</h2><h3 id="拷贝-Symbol"><a href="#拷贝-Symbol" class="headerlink" title="拷贝 Symbol"></a>拷贝 Symbol</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接 迭代递归法</span></span><br><span class="line"><span class="keyword">let</span> symKeys = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="keyword">if</span> (symKeys.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  symKeys.forEach(<span class="function"><span class="params">symKey</span> =&gt;</span> &#123;</span><br><span class="line">    cloneObj[symKey] = isObject(obj[symKey]) ? deepClone(obj[symKey]) : obj[symKey];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝原型上的属性"><a href="#拷贝原型上的属性" class="headerlink" title="拷贝原型上的属性"></a>拷贝原型上的属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj));</span><br></pre></td></tr></table></figure><h3 id="拷贝不可枚举的属性"><a href="#拷贝不可枚举的属性" class="headerlink" title="拷贝不可枚举的属性"></a>拷贝不可枚举的属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), <span class="built_in">Object</span>.getOwnPropertyDescriptors());</span><br></pre></td></tr></table></figure><h3 id="拷贝-Map-Set"><a href="#拷贝-Map-Set" class="headerlink" title="拷贝 Map,Set"></a>拷贝 Map,Set</h3><h3 id="拷贝原始值和包装类"><a href="#拷贝原始值和包装类" class="headerlink" title="拷贝原始值和包装类"></a>拷贝原始值和包装类</h3><h4 id="等号直接赋值"><a href="#等号直接赋值" class="headerlink" title="等号直接赋值"></a>等号直接赋值</h4><h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h4><h3 id="拷贝-Date-对象"><a href="#拷贝-Date-对象" class="headerlink" title="拷贝 Date 对象"></a>拷贝 Date 对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().valueOf());</span><br></pre></td></tr></table></figure><h3 id="拷贝正则"><a href="#拷贝正则" class="headerlink" title="拷贝正则"></a>拷贝正则</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneRegExp</span>(<span class="params">regexp</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回当前匹配的文本</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> regexp.constructor(regexp.source, reFlags.exec(regexp));</span><br><span class="line">  <span class="comment">// 下一次匹配的起始索引</span></span><br><span class="line">  result.lastIndex = regexp.lastIndex;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝函数，Err"><a href="#拷贝函数，Err" class="headerlink" title="拷贝函数，Err"></a>拷贝函数，Err</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cloneObj = <span class="built_in">eval</span>(obj[k].toString());</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">cloneObj = obj[k].bind();</span><br></pre></td></tr></table></figure><h3 id="拷贝-Map-WeakMap-Set-WeakSet"><a href="#拷贝-Map-WeakMap-Set-WeakSet" class="headerlink" title="拷贝 Map,WeakMap,Set,WeakSet"></a>拷贝 Map,WeakMap,Set,WeakSet</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用遍历for...of 或者 forEach</span></span><br><span class="line"><span class="comment">//如果是Map,WeakMap</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> newS = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  newS.add(item);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是Set,WeakSet</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line"><span class="keyword">let</span> newM = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">  newM.set(key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="更多参考-lodash"><a href="#更多参考-lodash" class="headerlink" title="更多参考 lodash"></a>更多参考 lodash</h2><p><a href="https://github.com/lodash/lodash/blob/master/.internal/baseClone.js" target="_blank" rel="noopener">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>line-height 3种设置方式的区别</title>
      <link href="/354.html"/>
      <url>/354.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载来源 <a href="https://www.jianshu.com/p/76071076a8f6" target="_blank" rel="noopener">line-height 3 种设置方式的区别</a></p></blockquote><p><code>line-height</code> 是具有继承性的，如果直接在某个元素上使用 <code>line-height</code>，那么这三种写法是没有区别的，比如给所有的 <code>p</code> 标签添加行高属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">150%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果是一样的。</p><p>这三种方式的区别在于，给父元素设置行高的时候子元素的继承方式。</p><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><ul><li>子元素字体大小的 <code>em</code> 是相对于父元素字体大小</li><li>元素的 <code>width/height/padding/margin/line-height等</code> 用 <code>em</code> 的话是相对于该元素的 <code>font-size</code></li></ul><p>假如我们有一个父 div 类名为 parent1，另一个父 div 类名为 parent2，均包含了一个类名为 child 的子 div，HTML 结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>line-height: 1.5em;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>line-height: 1.5;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS 如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">26px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的页面如下截图：</p><p><img src="http://cdn.flqin.com/p354-1.png" alt="line-height"></p><p>可以看到，当设置 <code>line-height: 1.5em</code> 时，很明显子 div 的文字已经超出自己的行高范围了，设置 <code>line-height: 1.5</code> 时子 div 的文字没有超出自己的行高。</p><p>这是由于 CSS 继承时的计算方式区别造成的，如示例，当我们给类名为 parent1 的父 div 设置 <code>line-height：1.5em</code> 时，该 div 的 font-size 为 14，此时经过计算父 div 的 line-height 为 14px*1.5=21px，然后子 div 的 line-height 就会继承 21px 这个值，而子 div 的 font-size 为 26px，自然会超出自己的行高范围。</p><p>而当我们给类名为 parent2 的父 div 设置 <code>line-height：1.5</code> 时，子 div 会直接继承 <code>line-height：1.5</code>，然后计算 26px*1.5=39px，不会超出自己的行高范围。</p><p>经过测试 <code>line-height: 150%</code>和 <code>line-height: 1.5em</code> 相同，都是先计算然后把固定的行高继承给子元素，所以我们可以总结一下，<strong>继承 <code>line-height</code> 的时候，带单位的先计算再继承，不带单位的直接继承</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS Grid布局</title>
      <link href="/353.html"/>
      <url>/353.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-grid"><a href="#什么是-grid" class="headerlink" title="什么是 grid"></a>什么是 grid</h2><p>网格布局（Grid）是最强大的 CSS 布局方案。它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。浏览器支持程度<a href="https://www.caniuse.com/#search=grid" target="_blank" rel="noopener">查阅</a>。</p><p>设为网格布局以后，容器子元素的 <code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code> 和 <code>column-*</code>等设置都将失效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">display</span>: inline-grid; <span class="comment">/* 行内元素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>以下属性设置在 grid 布局中的父元素（即设有 <code>display:grid</code> 的元素），用来控制内部子元素的行为。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>grid-template-columns/grid-template-rows</code> 定义每一列的列宽/每一行的行宽</p><ul><li><code>none</code> 所有的列和其大小都将由 <code>grid-auto-columns</code> 属性隐式的指定。</li><li><code>fr</code> 表示比例关系,按比例分配剩余的可用空间</li><li><code>auto</code> 由浏览器自己决定长度</li><li><code>&lt;length&gt;</code> 非负值的长度大小</li><li><code>&lt;percentage&gt;</code> 非负值且相对于网格容器的百分比</li><li><code>repeat(&lt;number&gt;|auto-fill|auto-fit,value)</code> 重复设置。第一个参数是重复次数，第二个参数是重复的值。<code>auto-fill</code>指容纳尽可能多的子元素。</li><li><code>minmax(min, max)</code> 表示长度范围</li></ul></li><li><p><code>column-gap/row-gap/gap</code> 定义列间距/行间距/两者合并简写(<code>&lt;row-gap&gt; &lt;column-gap&gt;</code>,简写若省略第二个值，即表示跟第一个值一样)</p><ul><li><code>&lt;length&gt;</code> 非负值的长度大小</li><li><code>&lt;percentage&gt;</code> 非负值列之间的间隔大小</li></ul></li><li><p><code>grid-auto-flow</code> 定义子元素排列顺序是先行后列还是先列后行</p><ul><li><code>row(默认)</code> 先行后列</li><li><code>column</code> 先列后行</li><li><code>row dense</code> 先行后列,并且尽量填满空格</li><li><code>column dense</code> 先列后行,并且尽量填满空格</li></ul></li><li><p><code>justify-items/align-items/place-items</code> 定义子元素内容水平位置（左中右）/垂直位置（上中下）/两者合并简写（<code>&lt;align-items&gt; &lt;justify-items&gt;</code>,简写若省略第二个值，即表示跟第一个值一样）</p><ul><li><code>stretch(默认)</code> 拉伸，占满单元格的整个宽度</li><li><code>start</code> 对齐单元格的起始边缘</li><li><code>end</code> 对齐单元格的结束边缘</li><li><code>center</code> 单元格内部居中</li></ul></li><li><p><code>justify-content/align-content/place-content</code> 定义整个内容在容器里的水平位置（左中右）/垂直位置（上中下）/两者合并简写（<code>&lt;align-content&gt; &lt;justify-content&gt;</code>简写若省略第二个值，即表示跟第一个值一样）</p><ul><li><code>start</code> 对齐容器的起始边框</li><li><code>end</code> 对齐容器的结束边框</li><li><code>center</code> 容器内部居中</li><li><code>stretch</code> 项目大小没有指定时，拉伸占据整个网格容器</li><li><code>space-around</code> 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍</li><li><code>space-between</code> 项目与项目的间隔相等，项目与容器边框之间没有间隔</li><li><code>space-evenly</code> 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</li></ul></li><li><p><code>grid-auto-columns/grid-auto-rows</code> 定义浏览器自动创建的多余网格的列宽和行高，取值与<code>grid-template-columns/grid-template-rows</code>相同。</p></li><li><p><code>grid-template-areas</code> 定义区域，一个区域由单个或多个单元格组成。如果某些区域不需要利用，则使用”点”（<code>.</code>）表示。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-areas</span>:</span><br><span class="line">  'header header header'</span><br><span class="line">  'main main sidebar'</span><br><span class="line">  'footer footer footer';</span><br></pre></td></tr></table></figure><p>区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p></li></ul><h2 id="容器内子元素的属性"><a href="#容器内子元素的属性" class="headerlink" title="容器内子元素的属性"></a>容器内子元素的属性</h2><ul><li><p><code>grid-column-start/grid-column-end/grid-row-start/grid-row-end</code> 定义子元素的<code>左边框/右边框/上边框/下边框</code>的网格线。</p><ul><li><code>&lt;number&gt;</code> 指定第几根网格线</li><li><code>&lt;网格线名字&gt;</code> 直接指定网格线名字如（<code>区域名-start</code>）</li><li><code>span &lt;number&gt;</code> 指跨越多少个网格</li></ul></li><li><p><code>grid-column/grid-row</code> 分别是<code>grid-column-start,grid-column-end</code>,<code>grid-row-start,grid-row-end</code>的合并简写（<code>&lt;start&gt; / &lt;end&gt;</code>）,斜杠以及后面的部分可以省略，默认跨越一个网格。</p></li><li><p><code>grid-area</code> 指定子元素放在哪一个区域。也作为<code>grid-row-start、grid-column-start、grid-row-end、grid-column-end</code>的合并简写:<code>grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</code></p></li><li><p><code>justify-self/align-self/place-self</code>定义某个单独的子元素内容水平位置（左中右）/垂直位置（上中下）/两者合并简写（<code>&lt;align-items&gt; &lt;justify-items&gt;</code>,简写若省略第二个值，即表示跟第一个值一样）。</p><ul><li>用法取值跟<code>justify-items/align-items/place-items</code>一样，只是作用于单个子元素。</li></ul></li></ul><blockquote><p>参考：<a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">CSS Grid 网格布局教程</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome provisional headers are shown 是什么意思</title>
      <link href="/352.html"/>
      <url>/352.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载来源 <a href="https://juejin.im/post/5c00980751882518805add83" target="_blank" rel="noopener">provisional headers are shown 知多少</a></p></blockquote><p>启发的一篇文章(<a href="https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger" target="_blank" rel="noopener">详情点击</a>)。</p><p>摘抄部分如下：</p><blockquote><p>The resource could be being blocked by an extension (AdBlock in my case).The message is there because the request to retrieve that resource was never made, so the headers being shown are not the real thing. As explained in the issue you referenced, the real headers are updated when the server responds, but there is no response if the request was blocked.</p></blockquote><p>资源可能被一些扩展程序拦截 。</p><p>另外还有一句：</p><blockquote><p>I believe it happens when the actual request is not sent. Usually happens when you are loading a cached resource.</p></blockquote><p>真正请求并未被发送，当使用缓存时经常发生。</p><p>之所以会出现这个信息是因为获取相关资源的请求并没有发出，所以 headers 被展示并不是真正的信息。</p><p>就像提到的那样，真正的 header 只有在服务端返回的时候会更新。当请求被拦截后，并没有返回。</p><p>基于这个情况开始猜测原因所在：</p><h3 id="猜测一、请求跨域被拦截"><a href="#猜测一、请求跨域被拦截" class="headerlink" title="猜测一、请求跨域被拦截"></a>猜测一、请求跨域被拦截</h3><p>虽然现在网站的静态资源都会存在专门的静态域名下面，和 html 域名可能不一致。</p><p>但是基本都是基于 CORS 来解决这个问题，所以不存在这个问题。</p><p>再有就是，我们这种情况首次请求的时候不会发生，如果有跨域，应该都被 block。</p><p>另外如果是被拦截，那么请求应该不会被响应的，我们这里显然得到了正确的响应。<br>这种被排除。</p><h3 id="猜测二、服务器未及时响应"><a href="#猜测二、服务器未及时响应" class="headerlink" title="猜测二、服务器未及时响应"></a>猜测二、服务器未及时响应</h3><p>这种猜测和一差不多，特定情况下才会出现，跟服务器关联不大。</p><h3 id="猜测三、被扩展程序拦截"><a href="#猜测三、被扩展程序拦截" class="headerlink" title="猜测三、被扩展程序拦截"></a>猜测三、被扩展程序拦截</h3><p>作为一个开发人员，大家的 chrome 上肯定装了不少的插件。这种原因还是有可能的。</p><p>我们可以通过 chrome://net-export/ 来根据关键字查找相关请求，然后具体去看相关状态。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>结合上面的分析，我们可以缩小到缓存上面。冲着这个目标，我们继续去看下相关资料。</p><p>最后在一篇<a href="https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/" target="_blank" rel="noopener">日文资料</a>里找到了相关解释。</p><p>似乎只从缓存中获得的通信显示为“显示临时标题”（或“执行”）。</p><p>因为该文件是从缓存中获取的，并且未进行通信。</p><p>所以详细标头并不会显示。</p><h3 id="原因：未与服务端正确通信"><a href="#原因：未与服务端正确通信" class="headerlink" title="原因：未与服务端正确通信"></a>原因：未与服务端正确通信</h3><p>回过头来看，前面提到的那么多情况其实都是与服务器没有进行或者完成正确的通信，所以只展示临时信息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>provisional headers are shown 出现的情况有这么几种：</p><ul><li>跨域，请求被浏览器拦截</li><li>请求被浏览器插件拦截</li><li>服务器出错或者超时，没有真正的返回</li><li>强缓存 from disk cache 或者 from memory cache，此时也不会显示</li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS遍历对象的方式</title>
      <link href="/351.html"/>
      <url>/351.html</url>
      
        <content type="html"><![CDATA[<h2 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for..in 循环"></a>for..in 循环</h2><ul><li>返回的是所有<code>可枚举</code>的属性，包括<code>实例</code>和<code>原型</code>上的属性。</li><li>如果只需要获取对象的实例属性，可以联合使用<code>hasOwnProperty()</code>进行过滤（过滤后等价 <code>Object.keys()</code>）。</li><li>不建议用来遍历数组<a href="https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-a-bad-idea" target="_blank" rel="noopener">查阅</a></li></ul><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><ul><li>返回的<code>实例</code>里<code>可枚举</code>的<code>属性</code>的<code>数组</code>，不包括<code>原型</code>。</li><li><code>Object.values()</code>返回<code>实例</code>里<code>可枚举</code>的<code>属性值</code>的<code>数组</code>，不包括<code>原型</code>。</li><li><code>Object.entries()</code>返回<code>实例</code>里<code>可枚举</code>的<code>键值对</code>的<code>数组</code>，不包括<code>原型</code>。</li></ul><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><ul><li>返回的<code>实例</code>里<code>所有</code>属性的数组，包括不可枚举属性，但不包括<code>Symbol</code>(注：<code>Symbol</code>可枚举)，但不会获取原型上的属性。</li><li><code>Object.getOwnPropertySymbols()</code> 返回自身的<code>Symol</code>属性。</li></ul><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h2><ul><li>返回的<code>实例</code>里<code>所有</code>属性的数组，包括不可枚举属性和<code>Symbol</code>。但不会获取原型上的属性。</li><li>基本等于<code>Object.getOwnPropertySymbols</code>+<code>Object.getOwnPropertyNames</code></li></ul><h2 id="题外话：for-of"><a href="#题外话：for-of" class="headerlink" title="题外话：for..of"></a>题外话：for..of</h2><ul><li>适用范围：iterable（Array, Map, Set, arguments 等）</li><li>返回迭代器<code>属性值</code></li><li>扩展运算符<code>（...）</code>内部使用 <code>for...of</code> 循环</li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babel7.4配置总结</title>
      <link href="/350.html"/>
      <url>/350.html</url>
      
        <content type="html"><![CDATA[<h2 id="本文适用版本"><a href="#本文适用版本" class="headerlink" title="本文适用版本"></a>本文适用版本</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"@babel/core": "^7.4.4",</span><br><span class="line">"@babel/plugin-transform-runtime": "^7.4.4",</span><br><span class="line">"@babel/preset-env": "^7.4.5",</span><br><span class="line">"@babel/runtime": "^7.4.5",</span><br><span class="line">"@babel/runtime-corejs2": "^7.4.5",</span><br><span class="line">"@babel/runtime-corejs3": "^7.4.5",</span><br><span class="line">"babel-loader": "^8.0.6",</span><br><span class="line">"core-js": "^3.1.4",</span><br><span class="line">"regenerator-runtime": "^0.13.2",</span><br><span class="line">"webpack": "^4.17.1",</span><br><span class="line">"webpack-cli": "^3.1.0"</span><br></pre></td></tr></table></figure><h2 id="什么是-babel"><a href="#什么是-babel" class="headerlink" title="什么是 babel"></a>什么是 babel</h2><p><code>babel</code> 把 JavaScript 中 es2015/2016/2017/2046 的新语法转化为 es5，让低端运行环境(如浏览器和 node )能够认识并执行。</p><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p><code>babel</code> 总共分为三个阶段：解析，转换，生成。</p><p><code>babel</code> 本身不具有任何转化功能，它把转化的功能都分解到一个个 <code>plugin</code> 里面。因此当我们不配置任何插件时，经过 babel 的代码和输入是相同的。</p><h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><ol><li>语法插件(@babel/parser):使得 babel 能够解析更多的语法。</li><li>转译插件:源码转换并输出。</li></ol><h2 id="Preset"><a href="#Preset" class="headerlink" title="Preset"></a>Preset</h2><p><code>preset</code>即一组官方推荐的预设插件的集合。目前推荐使用<code>@babel/preset-env</code>。</p><h2 id="Plugin-和-Preset-执行顺序"><a href="#Plugin-和-Preset-执行顺序" class="headerlink" title="Plugin 和 Preset 执行顺序"></a>Plugin 和 Preset 执行顺序</h2><ul><li>Plugin 会运行在 Preset 之前。</li><li>Plugin 会从前到后顺序执行。</li><li>Preset 的顺序则 刚好相反(从后向前)。</li></ul><h2 id="browserslist"><a href="#browserslist" class="headerlink" title="browserslist"></a>browserslist</h2><p><a href="https://github.com/browserslist/browserslist" target="_blank" rel="noopener">browserslist</a> 是在不同的前端工具之间共用目标浏览器和 node 版本的配置工具,中文<a href="https://juejin.im/post/5b8cff326fb9a019fd1474d6" target="_blank" rel="noopener">参阅</a>。浏览器特性支持可查询<a href="https://caniuse.com/" target="_blank" rel="noopener">caniuse</a>。</p><p>eg:package.json</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"browserslist": [</span><br><span class="line">  "last 1 version",</span><br><span class="line">  "&gt; 1%",</span><br><span class="line">  "maintained node versions",</span><br><span class="line">  <span class="string">"not dead"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="各-babel-包介绍"><a href="#各-babel-包介绍" class="headerlink" title="各 babel 包介绍"></a>各 babel 包介绍</h2><h3 id="babel-core"><a href="#babel-core" class="headerlink" title="@babel/core"></a>@babel/core</h3><p><code>babel</code>的编译核心包，内置 <code>helpers</code> 插件模块，是语法转换的主要辅助工具，所谓<code>babel</code>版本多少就是指这个包的版本多少。</p><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p><code>webpack</code>中使用<code>babel</code>加载文件。</p><h3 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="@babel/preset-env"></a>@babel/preset-env</h3><ol><li>文档<a href="https://babeljs.io/docs/en/next/babel-preset-env" target="_blank" rel="noopener">查阅</a></li><li><code>@babel/preset-env</code>是一个智能预设，集合了一系列常用插件，会根据<code>browserslist</code>设置的目标浏览器，自动将代码中的新特性转换成目标浏览器支持的代码。</li><li>默认的<code>@babel/preset-env</code>是无法转换新的 API，比如 <code>Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise</code> 等全局对象，以及一些定义在全局对象上的方法(比如 Object.assign)都不会转码。需要根据需要添加<code>core-js</code>包和<code>regenerator-runtime</code>包支持。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i core-js egenerator-runtime</span><br></pre></td></tr></table></figure><p><code>babel.config.js</code>配置:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/env'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: &#123;</span><br><span class="line">          browsers: [<span class="string">'&gt; 1%'</span>, <span class="string">'last 2 versions'</span>, <span class="string">'not dead'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        modules: <span class="literal">false</span>, <span class="comment">//取值可以是 amd, umd, systemjs, commonjs 和 false,为false时可以用于webpack做tree shaking。</span></span><br><span class="line">        useBuiltIns: <span class="string">'usage'</span>, <span class="comment">// usage-按需引入 entry-入口引入（代码里需手动引入core-js） false-不引入</span></span><br><span class="line">        corejs: <span class="number">3</span> <span class="comment">// 2-corejs@2  3-corejs@3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="core-js"><a href="#core-js" class="headerlink" title="core-js"></a>core-js</h3><ol><li>文档<a href="https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md" target="_blank" rel="noopener">查阅</a></li><li>JavaScript 标准库的 polyfill，目前提供 <code>core-js</code>，<code>core-js-pure</code>，<code>core-js-bundle</code> 3 个版本。</li><li>可直接项目里引用各种 polyfill。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polyfill all `core-js` features:</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js'</span>;</span><br><span class="line"><span class="comment">// polyfill only stable `core-js` features - ES and web standards:</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js/stable'</span>;</span><br></pre></td></tr></table></figure><h3 id="regenerator-runtime"><a href="#regenerator-runtime" class="headerlink" title="regenerator-runtime"></a>regenerator-runtime</h3><ol><li>regenerator-runtime 模块来自 facebook 的 regenerator 模块。</li><li>生成器函数、async、await 函数经 babel 编译后，regenerator-runtime 模块用于提供功能实现。</li><li>源码<a href="https://schifred.iteye.com/blog/2369320" target="_blank" rel="noopener">查阅</a></li></ol><h3 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="@babel/polyfill"></a>@babel/polyfill</h3><p><code>babel</code>7.4 版本已<a href="https://babeljs.io/docs/en/babel-polyfill" target="_blank" rel="noopener">废弃</a>，因为他仅仅依赖了<code>core-js</code>和<code>regenerator-runtime</code>,安装这两个就可以了。</p><h3 id="babel-runtime-babel-runtime-corejs2-babel-runtime-corejs3"><a href="#babel-runtime-babel-runtime-corejs2-babel-runtime-corejs3" class="headerlink" title="@babel/runtime/@babel/runtime-corejs2/@babel/runtime-corejs3"></a>@babel/runtime/@babel/runtime-corejs2/@babel/runtime-corejs3</h3><ol><li><code>@babel/runtime</code>提供 <code>helpers</code> 函数，并会去安装<code>regenerator-runtime</code>包，只做语法转换(helpers 和 regenerator)， 没有新 api 的实现。</li><li><code>@babel/runtime-corejs2</code>包含<code>@babel/runtime</code>的全部并额外安装<code>core-js@2</code></li><li><code>@babel/runtime-corejs3</code>包含<code>@babel/runtime</code>的全部并额外安装<code>core-js-pure@3</code></li><li>相比之下<code>@babel/runtime-corejs3</code>支持更多，包括实例，api 等。</li><li>三者均需要与<code>@babel/plugin-transform-runtime</code>搭配使用（但<code>@babel/plugin-transform-runtime</code>不一定要和他们用）。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [<span class="string">'@babel/env'</span>],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/plugin-transform-runtime'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        corejs: <span class="number">3</span> <span class="comment">//为false就安装 npm i @babel/runtime,为2就安装@babel/runtime-corejs2，为3就安装@babel/runtime-corejs3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="@babel/plugin-transform-runtime"></a>@babel/plugin-transform-runtime</h3><ol><li>对 <code>Babel</code> 编译过程中产生的 <code>helper</code> 方法进行重新利用(聚合)，以达到减少打包体积的目的.</li><li>避免全局补丁污染，对打包过的 <code>bundler</code> 提供”沙箱”式的补丁。</li><li>文档<a href="https://babeljs.io/docs/en/next/babel-plugin-transform-runtime" target="_blank" rel="noopener">查阅</a></li></ol><h2 id="两种最优方案"><a href="#两种最优方案" class="headerlink" title="两种最优方案"></a>两种最优方案</h2><h3 id="使用-corejs-useBuiltIns"><a href="#使用-corejs-useBuiltIns" class="headerlink" title="使用 corejs+useBuiltIns"></a>使用 corejs+useBuiltIns</h3><p>npm 安装：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i @babel/core @babel/preset-env @babel/plugin-transform-runtime -D</span><br><span class="line">npm i core-js regenerator-runtime</span><br></pre></td></tr></table></figure><p>babel.config.js 配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/env'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: &#123;</span><br><span class="line">          browsers: [<span class="string">'&gt; 1%'</span>, <span class="string">'last 2 versions'</span>, <span class="string">'not dead'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        useBuiltIns: <span class="string">'usage'</span>,</span><br><span class="line">        corejs: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  plugins: [[<span class="string">'@babel/plugin-transform-runtime'</span>]]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>该方案支持所有，包括转译语法，API 及实例方法的 polyfill。</li><li>该方案会污染全局。</li></ol><h3 id="使用-runtime-corejs3"><a href="#使用-runtime-corejs3" class="headerlink" title="使用 runtime-corejs3"></a>使用 runtime-corejs3</h3><p>npm 安装：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i @babel/core @babel/preset-env @babel/plugin-transform-runtime -D</span><br><span class="line">npm i @babel/runtime-corejs3</span><br></pre></td></tr></table></figure><p>babel.config.js 配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/env'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: &#123;</span><br><span class="line">          browsers: [<span class="string">'&gt; 1%'</span>, <span class="string">'last 2 versions'</span>, <span class="string">'not dead'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/plugin-transform-runtime'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        corejs: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>该方案支持所有，包括转译语法，API 及实例方法的 polyfill。</li><li>该方案不会污染全局。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Babel 版本号&lt; 7.4.0<ul><li>开发类库：@babel/runtime</li><li>内部项目：@babel/polyfill</li></ul></li><li>Babel 版本号&gt;= 7.4.0<ul><li>@babel/runtime-corejs3</li></ul></li><li>这文档都是坑爹的,网上的各种经验也都是之前的某个版本的总结，babel 包变化很快，最好的还是去看源码，和多测试不同包的效果，自己摸索体验。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>var let const fn变量提升</title>
      <link href="/349.html"/>
      <url>/349.html</url>
      
        <content type="html"><![CDATA[<p>JS 变量的声明分为<code>创建create</code>、<code>初始化initialize</code> 和<code>赋值assign」</code>。</p><h2 id="var-声明的过程"><a href="#var-声明的过程" class="headerlink" title="var 声明的过程"></a>var 声明的过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><ol><li>进入 fn，为 fn 创建一个环境。</li><li>找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。</li><li>将这些变量「初始化」为 undefined。</li><li>开始执行代码</li><li>x = 1 将 x 变量「赋值」为 1</li><li>y = 2 将 y 变量「赋值」为 2</li></ol><h2 id="function-声明过程"><a href="#function-声明过程" class="headerlink" title="function 声明过程"></a>function 声明过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">fn2()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>找到所有用 function 声明的变量，在环境中「创建」这些变量。</li><li>将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。</li><li>开始执行代码 fn2()</li></ol><h2 id="let-声明过程"><a href="#let-声明过程" class="headerlink" title="let 声明过程"></a>let 声明过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>找到所有用 let 声明的变量，在环境中「创建」这些变量</li><li>开始执行代码（注意现在还没有初始化）</li><li>执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化 4.为 undefined）</li><li>执行 x = 2，对 x 进行「赋值」</li></ol><h3 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">'global'</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>console.log(x) 中的 x 指的是下面的 x，而不是全局的 x</li><li>执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）</li></ol><h3 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> liList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>); <span class="comment">// 共5个li</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">  liList[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>for( let i = 0; i&lt; 5; i++) 这句话的圆括号之间，有一个隐藏的作用域</li><li>for( let i = 0; i&lt; 5; i++) { 循环体 } 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次（即 let/const 在与 for 一起用时，会有一个 perIterationBindings 的概念）。</li></ol><p>可理解为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> liList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>); <span class="comment">// 共5个li</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = 隐藏作用域中的i;</span><br><span class="line">  liList[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例-3"><a href="#例-3" class="headerlink" title="例 3"></a>例 3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = x; <span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br><span class="line"><span class="keyword">let</span> x; <span class="comment">//Identifier 'x' has already been declared</span></span><br></pre></td></tr></table></figure><ol><li>如果 let x 的初始化过程失败了,x 变量就将永远处于 created 状态。</li><li>无法再次对 x 进行初始化, x 永远处在暂时性死区.</li></ol><blockquote><p>当程序的控制流程在新的作用域（module function 或 block 作用域）进行实例化时，在此作用域中用 let/const 声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定，所以是不能被访问的，如果访问就会抛出错误。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时性死区。</p></blockquote><h2 id="const-声明过程"><a href="#const-声明过程" class="headerlink" title="const 声明过程"></a>const 声明过程</h2><p>const 过程跟 let 一样，但 const 只有「创建」和「初始化」，没有「赋值」过程。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>let、const 的「创建」过程被提升了，但是初始化没有提升。</li><li>var 的「创建」和「初始化」都被提升了。</li><li>function 的「创建」「初始化」和「赋值」都被提升了。</li></ol><p><img src="http://cdn.flqin.com/p349-1.jpg" alt="git命令总结"></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/28140450" target="_blank" rel="noopener">我用了两个月的时间才理解 let</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>amd,umd,commonJs,ES6模块的相关总结</title>
      <link href="/348.html"/>
      <url>/348.html</url>
      
        <content type="html"><![CDATA[<h2 id="AMD-CMD-模块（requireJS-seaJs）（即将退出历史舞台）"><a href="#AMD-CMD-模块（requireJS-seaJs）（即将退出历史舞台）" class="headerlink" title="AMD/CMD 模块（requireJS/seaJs）（即将退出历史舞台）"></a>AMD/CMD 模块（requireJS/seaJs）（即将退出历史舞台）</h2><ul><li><code>AMD</code>（Asynchronous Module Definition 异步模块定义）和 <code>CMD</code>（Common Module Definition 通用模块定义）是基于浏览器使用并且是<code>异步执行</code></li><li><code>AMD</code> 推崇依赖前置，在定义模块的时候就要声明其依赖的模块</li><li><code>CMD</code> 推崇就近依赖，只有在用到某个模块的时候再去 require</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMD</span></span><br><span class="line"><span class="comment">// 定义模块 myModule.js</span></span><br><span class="line">define([<span class="string">'dependency'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Byron'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    printName: printName</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'myModule'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>) </span>&#123;</span><br><span class="line">  my.printName();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CMD</span></span><br><span class="line"><span class="comment">// 定义模块  myModule.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>);</span><br><span class="line">  $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li>AMD 在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入 require 的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。</li><li>CMD 加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的</li></ul><h2 id="commonJS-模块（nodejs）"><a href="#commonJS-模块（nodejs）" class="headerlink" title="commonJS 模块（nodejs）"></a>commonJS 模块（nodejs）</h2><ul><li>使用 <code>require</code> 来引入其他模块的代码，使用 <code>module.exports</code> 来引出。</li><li><code>exports</code>与<code>module.exports</code>的初始指针相同，即<code>module.exports === exports</code>,如果<code>exports</code>一旦指向了其他对象，即不能用于导出。</li><li>运行时加载，输出的是一个值的拷贝。</li></ul><h3 id="值的拷贝"><a href="#值的拷贝" class="headerlink" title="值的拷贝"></a>值的拷贝</h3><p><code>require</code>引入的是值的拷贝(基本类型拷贝值，引用类型拷贝地址)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.js</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line">exports.age = age;</span><br><span class="line">exports.getAge = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  age = age + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">//1 原本的会改变</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./4'</span>);</span><br><span class="line"><span class="keyword">var</span> age = a.age;</span><br><span class="line"><span class="keyword">var</span> getAge = a.getAge;</span><br><span class="line">getAge();</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">//0 不会改变age，一旦生成缓存后就会从缓存里读这个值</span></span><br></pre></td></tr></table></figure><h3 id="commonjs-循环加载"><a href="#commonjs-循环加载" class="headerlink" title="commonjs 循环加载"></a>commonjs 循环加载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4开始执行'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  exports.name = <span class="string">'qxq1'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">exports.name = <span class="string">'qxq'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4执行一半'</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./5'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in 4, b.done ='</span>, b.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4执行结束'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5开始执行'</span>);</span><br><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./4'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in 5, a.name ='</span>, a.name);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in 5, a.done ='</span>, a.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5执行结束'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">666</span>, a);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">4</span>开始执行</span><br><span class="line"><span class="number">4</span>执行一半</span><br><span class="line"><span class="number">5</span>开始执行</span><br><span class="line"><span class="keyword">in</span> <span class="number">5</span>, a.name = qxq</span><br><span class="line"><span class="keyword">in</span> <span class="number">5</span>, a.done = <span class="literal">undefined</span></span><br><span class="line"><span class="number">5</span>执行结束</span><br><span class="line"><span class="keyword">in</span> <span class="number">4</span>, b.done = <span class="literal">true</span></span><br><span class="line"><span class="number">4</span>执行结束</span><br><span class="line"><span class="number">666</span> <span class="built_in">Object</span> &#123;<span class="attr">name</span>: <span class="string">"qxq1"</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>执行到<code>require</code>那行才会去加载该脚本</li><li><code>require</code> 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象，本质就是一个一次性赋值操作。</li><li>再次执行 <code>require</code> 命令，也不会再次执行该模块，而是到缓存之中取值。</li><li>一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</li></ul><h2 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h2><ul><li><code>import/export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，则会报错。</li><li>ES6 模块输入是 <code>export</code> 的动态<code>只读视图（live read-only views）</code></li></ul><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>使用<code>import</code>命令加载其他模块，<code>import</code> 命令输入的变量都是<code>只读</code>的，因为它的本质是<code>输入接口</code>。</p><ol><li><p>语法<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认导出的导入</span></span><br><span class="line"><span class="keyword">import</span> defaultExport <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整体导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入单个接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重命名接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入多个接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo , bar &#125; <span class="keyword">from</span> <span class="string">"module-name/path/to/specific/un-exported/file"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 <span class="keyword">as</span> alias2 , [...] &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;个接口</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时导入默认和多个接口</span></span><br><span class="line"><span class="keyword">import</span> defaultExport, &#123; <span class="keyword">export</span> [ , [...] ] &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> defaultExport, * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只运行模块代码不导入接口</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"module-name"</span>;</span><br></pre></td></tr></table></figure></li><li><p>如果多次重复执行同一句 <code>import</code> 语句，那么只会执行一次.</p></li><li><p><code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p></li></ol><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><ol><li><p>使用<code>export</code>命令规定对外的<code>接口</code>，必须与模块内部的变量建立一一对应关系。<code>export</code>语句输出的接口，与其对应的值是<code>动态绑定</code>关系，即通过该接口，可以取到模块内部实时的值。</p></li><li><p>语法<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出单个特性</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1, name2, …, nameN; <span class="comment">// also var, const</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1 = …, name2 = …, …, nameN; <span class="comment">// also var, const</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">FunctionName</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导处列表</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1, name2, …, nameN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; variable1 <span class="keyword">as</span> name1, variable2 <span class="keyword">as</span> name2, …, nameN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> expression;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">…</span>) </span>&#123; … &#125; <span class="comment">// also class, function*</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">name1</span>(<span class="params">…</span>) </span>&#123; … &#125; <span class="comment">// also class, function*</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1 <span class="keyword">as</span> <span class="keyword">default</span>, … &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> …;</span><br><span class="line"><span class="keyword">export</span> &#123; name1, name2, …, nameN &#125; <span class="keyword">from</span> …;</span><br><span class="line"><span class="keyword">export</span> &#123; import1 <span class="keyword">as</span> name1, import2 <span class="keyword">as</span> name2, …, nameN &#125; <span class="keyword">from</span> …;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> …;</span><br></pre></td></tr></table></figure></li><li><p>默认导出 <code>export default</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> k;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> k = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>因为 <code>export default</code> 命令的本质是将后面的值，赋给 <code>default</code> 变量，所以可以直接将一个值写在 <code>export default</code> 之后。</p></li></ol><h3 id="值的引用"><a href="#值的引用" class="headerlink" title="值的引用"></a>值的引用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; age, getAge &#125; <span class="keyword">from</span> <span class="string">'./5.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">//原本为0</span></span><br><span class="line">getAge();</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">//因为是值的引用，所以要变，为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  age = age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">//要变，为1</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><h3 id="ES6-循环加载"><a href="#ES6-循环加载" class="headerlink" title="ES6 循环加载"></a>ES6 循环加载</h3><ul><li><code>import</code>命令会被 JavaScript 引擎静态分析，具有提升效果，会提升到整个模块的头部，首先执行。</li><li><code>export</code> 命令会有变量声明提前的效果。</li><li>ES6 模块遇到模块加载命令<code>import</code>时，不会去执行模块，而是只生成一个<code>引用</code>。等到真的需要用到时，再到模块里面去取值。</li><li>ES6 根本不会关心是否发生了”循环加载”，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</li><li>通常存在强耦合，应避免出现。</li></ul><h4 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar2'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar3'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> a <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// 注意函数表达式和函数声明的区别（提升）</span></span><br></pre></td></tr></table></figure><h4 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a starting'</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in b, foo:'</span>, foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a done'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b starting'</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in a, bar:'</span>, bar);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'in a, setTimeout bar:'</span>, bar);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b done'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel-node a.js</span></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// b starting</span></span><br><span class="line"><span class="comment">// in a, bar: undefined</span></span><br><span class="line"><span class="comment">// b done</span></span><br><span class="line"><span class="comment">// a starting</span></span><br><span class="line"><span class="comment">// in b, foo: foo</span></span><br><span class="line"><span class="comment">// a done</span></span><br><span class="line"><span class="comment">// in a, setTimeout bar: 2</span></span><br><span class="line"><span class="comment">// 注意该例不能用const或let，否则报错:Cannot access 'bar' before initialization 暂时性死区</span></span><br><span class="line"><span class="comment">// export变量声明提升</span></span><br></pre></td></tr></table></figure><h3 id="高版本浏览器可以直接使用-es6-module"><a href="#高版本浏览器可以直接使用-es6-module" class="headerlink" title="高版本浏览器可以直接使用 es6 module"></a>高版本浏览器可以直接使用 es6 module</h3><p><a href="https://caniuse.com/#search=module" target="_blank" rel="noopener">点此查询版本支持</a></p><ol><li><p>script 标签加 type=’module’属性启动支持</p></li><li><p>支持相对路径和绝对路径</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; getName &#125; <span class="keyword">from</span> <span class="string">'utils.js'</span>; <span class="comment">// error</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; getName &#125; <span class="keyword">from</span> <span class="string">'./utils.js'</span>; <span class="comment">// right</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>nomodule</code>向下兼容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"module.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">"fallback.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因老版本不识别<code>type=&quot;module&quot;</code>即不会执行<code>module.js</code>，同时不识别<code>nomodule</code>即忽略该属性<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script" target="_blank" rel="noopener">参考</a></p></li><li><p>加载方式默认使用 defer</p></li><li><p>只执行一次</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.js 只会被加载执行一次--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> <span class="string">'./1.js'</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  普通JS 也只会被加载一次，但是会被执行多次--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>type=”module” 默认不支持跨域,需要服务器设置 <code>cors</code></p></li><li><p>服务器必须要设置有效的 MIME types：<code>text/javascript</code></p></li></ol><h3 id="动态异步加载-import"><a href="#动态异步加载-import" class="headerlink" title="动态异步加载 import()"></a>动态异步加载 import()</h3><ul><li><code>import()</code>返回一个<code>promise对象</code>,可以用在任何地方，运行时加载。</li><li>主要用在<code>按需加载</code>及<code>条件加载</code>。</li><li>使用 babel 编译时，需要添加<code>syntax-dynamic-import</code>插件</li></ul><h2 id="UMD-模块"><a href="#UMD-模块" class="headerlink" title="UMD 模块"></a>UMD 模块</h2><p>实际上就是 <code>amd/cmd + commonjs + 全局变量</code> 这三种风格的结合，对当前运行环境的判断，如果是 Node 环境 就是使用 CommonJs 规范， 如果不是就判断是否为 AMD 环境， 最后导出全局变量。（AMD）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> ? (<span class="built_in">module</span>.exports = factory()) : <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ? define(factory) : (global.libName = factory());</span><br><span class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>blog从wordpress迁移至hexo+next，并通过travis自动部署到ftp及github.io</title>
      <link href="/250.html"/>
      <url>/250.html</url>
      
        <content type="html"><![CDATA[<p>因 wordpress 后台臃肿反应慢，外加上本人作为前端代码狗，基于 nodejs 的 hexo 对我非常友好。所以花了 2 天时间终于把 blog 从 wordpress 迁移至 hexo， 通过直接在 md 里面来写博客，简直爽到飞起。特此记录一下我在迁移搭建中做了哪些操作，以便后面遗忘。</p><hr><p><strong>博客效果:</strong></p><ul><li><a href="http://blog.flqin.com">blog</a></li><li><a href="https://zhaoky.github.io" target="_blank" rel="noopener">github.io</a></li></ul><hr><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>安装 node.js</li><li>安装 git</li><li>全局安装 Hexo-cli（生成 hexo 项目用）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="生成静态网站"><a href="#生成静态网站" class="headerlink" title="生成静态网站"></a>生成静态网站</h3><p>打开目标文件夹，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexo-demo</span><br><span class="line"><span class="built_in">cd</span> hexo-demo</span><br><span class="line">yarn //也可以用npm i，个人喜好</span><br></pre></td></tr></table></figure><p>通过命令 <code>hexo s</code>可本地预览</p><p>通过命令 <code>hexo g</code>可本地生成建站资源 public 包，用来部署</p><p>相关文件夹的作用及配置<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">点此查阅</a>,命令<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">点此查阅</a></p><h3 id="从-wordpress-迁移"><a href="#从-wordpress-迁移" class="headerlink" title="从 wordpress 迁移"></a>从 wordpress 迁移</h3><p>hexo-demo 里安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-migrator-wordpress -D</span><br></pre></td></tr></table></figure><p>同时在<code>WordPress仪表盘</code>中导出数据(“Tools” → “Export” → “WordPress”)</p><p>安装好后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo migrate wordpress &lt;source&gt; #source为 WordPress 导出的文件路径或网址</span><br></pre></td></tr></table></figure><p>转换后再自己检查修改下就可以了，因为这个转换插件我只需要用一次，然后我就把<code>hexo-migrator-wordpress</code>删掉了。</p><h3 id="hexo-优化"><a href="#hexo-优化" class="headerlink" title="hexo 优化"></a>hexo 优化</h3><p>项目有两个_config.yml 文件，分别是<code>项目_config.yml</code>和<code>主题_config.yml</code>。</p><h4 id="项目增强"><a href="#项目增强" class="headerlink" title="项目增强"></a>项目增强</h4><ul><li>添加<a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">页面 2d 萌宠</a>插件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-helper-live2d -D</span><br><span class="line">yarn add live2d-widget-model-koharu -D</span><br></pre></td></tr></table></figure><p><code>项目config</code>添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  scriptFrom:</span> <span class="string">jsdelivr</span> <span class="comment"># 默认</span></span><br><span class="line"><span class="attr">  pluginRootPath:</span> <span class="string">live2dw/</span> <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line"><span class="attr">  pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line"><span class="attr">  pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line"><span class="attr">  tagMode:</span> <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line"><span class="attr">  debug:</span> <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    use:</span> <span class="string">live2d-widget-model-koharu</span> <span class="comment"># npm-module package name</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line"><span class="attr">    vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    superSample:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    width:</span> <span class="number">125</span></span><br><span class="line"><span class="attr">    height:</span> <span class="number">150</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">left</span></span><br><span class="line"><span class="attr">    hOffset:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">    vOffset:</span> <span class="bullet">-5</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">0.05</span></span><br><span class="line"><span class="attr">  react:</span></span><br><span class="line"><span class="attr">    opacityDefault:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    opacityOnHover:</span> <span class="number">0.2</span></span><br></pre></td></tr></table></figure><ul><li>添加<a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">搜索功能</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-generator-search -D</span><br></pre></td></tr></table></figure><p><code>项目config</code> 设置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p><code>主题config</code> 设置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/theme-next/hexo-filter-**optimize**" target="_blank" rel="noopener">页面加载优化</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-filter-optimize -D</span><br></pre></td></tr></table></figure><p>配置见作者说明。</p><ul><li>注意插件与 next font-awesome 本地库有冲突，需要把<code>主题config</code>里的<code>fontawesome</code>替换为线上 CDN。<a href="https://github.com/theme-next/hexo-filter-optimize/issues/2" target="_blank" rel="noopener">详见</a></li><li>在本地 sever 的时候很慢，建议只在发布部署的时候使用。（用<code>sed -i</code>在 travis 构建里开启）</li></ul><h4 id="主题相关"><a href="#主题相关" class="headerlink" title="主题相关"></a>主题相关</h4><p>采用了 star 最多的 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">hexo</a>，官方文档<a href="https://theme-next.org/docs/" target="_blank" rel="noopener">查阅</a>。设置方式：修改<code>项目config</code>里的 <code>theme</code> 为 <code>next</code>即可。</p><h5 id="主题优化（以下配置均在主题config）"><a href="#主题优化（以下配置均在主题config）" class="headerlink" title="主题优化（以下配置均在主题config）"></a>主题优化（以下配置均在<code>主题config</code>）</h5><ul><li>生成缓存： <code>cache.enable:true</code></li><li>修改网站 favicon： <code>favicon</code></li><li>页脚修改： <code>footer</code></li><li>右上角 github banner 生成： <code>github_banner</code></li><li>设置导航： <code>menu</code></li><li>选择主题 Pisces：<code>scheme: Pisces</code></li><li>设置概览信息：<code>social social_icons</code></li><li>设置头像相关：<code>avatar</code></li><li>代码风格：<code>highlight_theme</code></li><li>设置百度统计：<code>baidu_analytics</code></li><li>设置显示加载更多：<code>scroll_to_more</code></li><li>保存滚动位置：<code>save_scroll</code></li><li>添加打赏：<code>reward_settings reward</code></li><li>拷贝<a href="https://github.com/theme-next/theme-next-reading-progress" target="_blank" rel="noopener">滑动进度条</a>并设置：<code>reading_progress</code></li><li>拷贝<a href="https://github.com/theme-next/theme-next-pace" target="_blank" rel="noopener">加载进度条</a>并设置：<code>pace pace_theme</code></li><li>拷贝<a href="https://github.com/theme-next/theme-next-canvas-nest" target="_blank" rel="noopener">页面 3D 背景</a>并设置<code>canvas_nest</code></li><li>拷贝<a href="https://github.com/theme-next/theme-next-fancybox3" target="_blank" rel="noopener">fancyBox</a>并设置<code>fancybox</code></li><li>拷贝<a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">字数统计插件</a>并设置（需同时设置两个<code>_onfig</code>,并在项目 yarn add 该插件）：<code>symbols_count_time</code></li></ul><h4 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h4><ul><li><p>百度站长平台：<a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">https://ziyuan.baidu.com/</a></p></li><li><p>谷歌站长平台：<a href="https://search.google.com/search-console" target="_blank" rel="noopener">https://search.google.com/search-console/</a></p></li><li><p>通过在搜索引擎输入:<code>site: blog.flqin.com</code>测试是否被收录</p></li><li><p>未被收录的话，在站长平台添加。</p></li><li><p>提交链接：包括<code>主动推送</code>，<code>自动推送</code>，<code>sitemap</code>,效率:<code>主动推送&gt;自动推送&gt;sitemap</code>,可同时配合使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-generator-sitemap hexo-generator-baidu-sitemap hexo-baidu-url-submit -D</span><br></pre></td></tr></table></figure><p>并设置<code>项目config</code>:<code>url</code>,<code>permalink</code>,<code>sitemap</code>,<code>baidusitemap</code>,<code>baidu_url_submit</code>,<code>deploy</code></p></li></ul><h3 id="travis-ci-持续部署到-ftp-和-gitlab-io"><a href="#travis-ci-持续部署到-ftp-和-gitlab-io" class="headerlink" title="travis-ci 持续部署到 ftp 和 gitlab.io"></a>travis-ci 持续部署到 ftp 和 gitlab.io</h3><p>添加部署相关插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-deployer-git -D</span><br><span class="line">yarn add hexo-deployer-ftpsync -D</span><br></pre></td></tr></table></figure><p>部署之前，先生成要部署的静态文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>部署的<code>项目config</code>配置(详细配置<a href="https://hexo.io/zh-cn/docs/deployment" target="_blank" rel="noopener">查阅</a>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:zhaoky/zhaoky.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">ftpsync</span></span><br><span class="line"><span class="attr">  host:</span> <span class="string">ftpHost</span></span><br><span class="line"><span class="attr">  user:</span> <span class="string">ftpUser</span></span><br><span class="line"><span class="attr">  pass:</span> <span class="string">ftpPass</span></span><br><span class="line"><span class="attr">  remote:</span> <span class="string">ftpRemote</span></span><br></pre></td></tr></table></figure><p>部署命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h4 id="ftp-部署相关设置"><a href="#ftp-部署相关设置" class="headerlink" title="ftp 部署相关设置"></a>ftp 部署相关设置</h4><p>为了 ftp 的账号密码的安全性，所以在 config 中的配置用 travis 加密变量表示（如<code>ftpsync，ftpHost，ftpPass，ftpRemote</code>），然后在 travis 里的该项目配置该加密变量。这样在 travis 运行构建的时候就可以应用替换回真实的账号密码。</p><p><em>但我实际操作的时候一直报<code>Error: read ETIMEDOUT at TCP.onStreamRead (internal/stream_base_commons.js:111:27)</code>的错误，查了下源码可能是<code>jsftp</code>包报的错，已经向<a href="https://github.com/hexojs/hexo/issues/3585" target="_blank" rel="noopener">hexo</a>和<a href="https://github.com/hexojs/hexo-deployer-ftpsync/issues/33" target="_blank" rel="noopener">hexo-deployer-ftpsync</a>提 issue,如果有解决方案请告知我，多谢指教！</em></p><h4 id="git-部署相关设置"><a href="#git-部署相关设置" class="headerlink" title="git 部署相关设置"></a>git 部署相关设置</h4><p>github 部署采用 ssh 的通讯加密方式，首先在 github 上建一个命名为 zhaoky.github.io(zhaoky 替换成 github 名)的仓库，然后本地本地生成一对公私钥（运行<code>ssh-keygen -t rsa -C youremail@example.com</code>生成）,将.pub 公钥配置在 zhaoky.github.io 仓库的 <code>deploy key</code>，把私钥和 ssh-config 发到 travis 的构建服务器里。私钥为了保证安全性，本地通过 travis 命令加密，然后在 travis 构建时再解密，这样就能自动发布了。</p><h4 id="本地-travis-命令如何加密"><a href="#本地-travis-命令如何加密" class="headerlink" title="本地 travis 命令如何加密"></a>本地 travis 命令如何加密</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gem install travis</span><br><span class="line">travis login --com #如果仍在使用travis-ci.org，则需要使用--org</span><br><span class="line">travis encrypt-file id_rsa --add --pro #使用--add自动添加到travis.yml,--pro将生成的加密环境变量添加到travis项目后台管理中</span><br></pre></td></tr></table></figure><p>这样就生成了一个加密后的.enc 的文件了</p><h4 id="ssh-config-怎么配置"><a href="#ssh-config-怎么配置" class="headerlink" title="ssh/config 怎么配置"></a>ssh/config 怎么配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    StrictHostKeyChecking no</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    IdentitiesOnly yes</span><br></pre></td></tr></table></figure><p>我的做法是在项目里建了一个.travis 的文件夹，将加密后的.enc 文件和 ssh-config 放进去，在 travis 构建的时候发到构建的机器上。</p><h4 id="我的-travis-yml-的配置"><a href="#我的-travis-yml-的配置" class="headerlink" title="我的.travis.yml 的配置"></a>我的.travis.yml 的配置</h4><p>直接看配置就明白了。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'10'</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_43f9974e8d06_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_43f9974e8d06_iv</span></span><br><span class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">.travis/id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cp</span> <span class="string">.travis/ssh_config</span> <span class="string">~/.ssh/config</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">user.name</span> <span class="string">'korey'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">user.email</span> <span class="string">'keyu.zhao@foxmail.com'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-cli</span> <span class="bullet">-g</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">yarn</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">bash</span> <span class="string">sed.sh</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">yarn</span> <span class="string">run</span> <span class="string">deploy</span> <span class="comment">#hexo clean &amp;&amp; hexo g -d</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git命令总结</title>
      <link href="/347.html"/>
      <url>/347.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h2><p>当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中，里面可配置 git 相关的全局信息。</p><h3 id="安装好后，最后一步设置"><a href="#安装好后，最后一步设置" class="headerlink" title="安装好后，最后一步设置"></a>安装好后，最后一步设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"korey"</span></span><br><span class="line">git config --global user.email <span class="string">"xxx@163.com"</span></span><br><span class="line">git config --global alias.st status <span class="comment">#设置别名</span></span><br></pre></td></tr></table></figure><h3 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.ignorecase <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="列举所有配置"><a href="#列举所有配置" class="headerlink" title="列举所有配置"></a>列举所有配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><h3 id="查看系统-config"><a href="#查看系统-config" class="headerlink" title="查看系统 config"></a>查看系统 config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure><h3 id="查看当前用户（global）配置"><a href="#查看当前用户（global）配置" class="headerlink" title="查看当前用户（global）配置"></a>查看当前用户（global）配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><h3 id="查看当前仓库配置信息"><a href="#查看当前仓库配置信息" class="headerlink" title="查看当前仓库配置信息"></a>查看当前仓库配置信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span>  --list</span><br></pre></td></tr></table></figure><h3 id="删除某个配置"><a href="#删除某个配置" class="headerlink" title="删除某个配置"></a>删除某个配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> user.emaill</span><br></pre></td></tr></table></figure><p>全局的通过 <code>vim ~/.gitconfig</code> 来查看 局部的通过当前路径下的 <code>.git/config</code> 文件来查看</p><h2 id="创建版本库（仓库）"><a href="#创建版本库（仓库）" class="headerlink" title="创建版本库（仓库）"></a>创建版本库（仓库）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir aaa</span><br><span class="line"><span class="built_in">cd</span> aaa</span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><h2 id="三态转换"><a href="#三态转换" class="headerlink" title="三态转换"></a>三态转换</h2><h3 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><ul><li><code>工作区 Working tree</code>：即文件目录内容</li><li><code>暂存区 index</code>：目录 .git 内的 stage/index (已 add 未 commit)</li><li><code>版本库 repo</code>：文件 .git 新修改的文件 (工作区) （untracked）→ 通过 add→ 暂存区 → 通过 commit→ 版本库</li></ul><h3 id="工作区-gt-暂存区"><a href="#工作区-gt-暂存区" class="headerlink" title="工作区-&gt;暂存区"></a>工作区-&gt;暂存区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><h3 id="暂存区-gt-版本库"><a href="#暂存区-gt-版本库" class="headerlink" title="暂存区-&gt;版本库"></a>暂存区-&gt;版本库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git commit &lt;file&gt;</span><br><span class="line">git commit .</span><br><span class="line">git commit -a</span><br><span class="line">git commit -amend  <span class="comment">#修改最后一次提交</span></span><br><span class="line">git commit -m “xxx”</span><br></pre></td></tr></table></figure><h3 id="撤销工作区的修改"><a href="#撤销工作区的修改" class="headerlink" title="撤销工作区的修改"></a>撤销工作区的修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout --  &lt;file&gt;</span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure><p>checkout 还可以检出提交，查看某个版本的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 5aab391 <span class="comment">#跳到该commit快照</span></span><br><span class="line">git checkout - <span class="comment">#回到当前</span></span><br></pre></td></tr></table></figure><h3 id="已暂存撤销到工作区-git-不再跟踪"><a href="#已暂存撤销到工作区-git-不再跟踪" class="headerlink" title="已暂存撤销到工作区(git 不再跟踪)"></a>已暂存撤销到工作区(git 不再跟踪)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm -- cached &lt;file&gt;</span><br><span class="line">git reset &lt;file&gt;</span><br><span class="line">git reset .   <span class="comment">#--mixed 为默认参数 意思是把变更放在工作区</span></span><br><span class="line">git reset --hard <span class="comment">#工作区和暂存区都撤销</span></span><br></pre></td></tr></table></figure><h3 id="文件改名"><a href="#文件改名" class="headerlink" title="文件改名"></a>文件改名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv oldName newName</span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt;</span><br></pre></td></tr></table></figure><h2 id="比较-diff"><a href="#比较-diff" class="headerlink" title="比较 diff"></a>比较 diff</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git diff                <span class="comment">#比较Working tree和index之间的差异</span></span><br><span class="line">git diff &lt;file&gt;      <span class="comment">#比较Working tree和index之间的差异</span></span><br><span class="line">git diff --cached 或 <span class="variable">$git</span> diff --staged    <span class="comment">#两个都是比较index和版本库的差异</span></span><br><span class="line">git diff HEAD <span class="comment"># 查看Working tree和版本库的差异</span></span><br><span class="line">git diff &lt;<span class="variable">$id1</span>&gt; &lt;<span class="variable">$id2</span>&gt;  <span class="comment">#比较两次提交之间的差异</span></span><br><span class="line">git diff &lt;branch1&gt;..&lt;branch2&gt; <span class="comment">#在两个分支之间比较</span></span><br><span class="line">git diff --name-only HEAD src <span class="comment">#显示当前分支最新的提交与工作区或暂存区的比较，只显示文件名</span></span><br></pre></td></tr></table></figure><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="^和~的区别"></a>^和~的区别</h2><ul><li><code>^</code>代表父提交,当一个提交有多个父提交时，可以通过在<code>^</code>后面跟上一个数字，表示第几个父提交，<code>^</code>相当于<code>^1</code>。</li><li><code>~&lt;n&gt;</code>表示第 n 个祖先提交，相当于连续的 n 个<code>^</code>。如<code>HEAD~3</code>即 HEAD 的父提交的父提交的父提交。如要取 merge 的第二个父提交的父提交:<code>HEAD^2~1</code></li></ul><h2 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span>                      <span class="comment">#第一行为commit ID</span></span><br><span class="line">git <span class="built_in">log</span>  -p &lt;file&gt;  <span class="comment">#查看指定文件的提交历史</span></span><br><span class="line">git blame  &lt;file&gt; <span class="comment">#以列表方式查看指定文件的提交历史</span></span><br><span class="line">git reflog show master | head  <span class="comment">#显示所有的版本记录</span></span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>收集了<code>四种</code>方式实现版本回退</p><p>通过<code>git reflog</code>可以查看操作记录</p><h3 id="暴力-reset-回退"><a href="#暴力-reset-回退" class="headerlink" title="暴力 reset 回退"></a>暴力 reset 回退</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line">git reset --hard &lt;commit&gt;</span><br><span class="line">git push origin master -f</span><br></pre></td></tr></table></figure><p>该方式会<code>改变历史进程</code>，多人开发时会混乱,非常不推荐。</p><h3 id="使用-revert-生成一个新-commit"><a href="#使用-revert-生成一个新-commit" class="headerlink" title="使用 revert 生成一个新 commit"></a>使用 revert 生成一个新 commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git revert 5aab391 <span class="comment">#回滚某次commit</span></span><br><span class="line">git revert -n 5aab391..1hd2d72 <span class="comment">#回滚从5aab391到1hd2d72，但中间如果有merge等则不适用</span></span><br><span class="line">git revert -m 1 5aab391 <span class="comment">#回滚某次merge的commit -m 1是选择保留1，抛弃2，这个1，2的定义在git log中的merge那行顺序为准</span></span><br></pre></td></tr></table></figure><p>该方法<code>不会改变历史进程</code>，适用于单个回滚或者多个无 merge 的回滚。</p><h3 id="使用-reset-–head-–soft"><a href="#使用-reset-–head-–soft" class="headerlink" title="使用 reset –head –soft"></a>使用 reset –head –soft</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 5aab391</span><br><span class="line">git reset --soft 1hd2d72 <span class="comment">#5aab391到1hd2d72之前的放到了暂存区 ？</span></span><br><span class="line">git commit -m <span class="string">'生成一个新提交，回滚5aab391到1hd2d72的内容'</span></span><br><span class="line">git push xxx</span><br></pre></td></tr></table></figure><p>该方法<code>不会改变历史进程</code>，生成一个新的 commit 来覆盖之前的内容达到回滚，推荐。</p><h3 id="使用-s-ours-master"><a href="#使用-s-ours-master" class="headerlink" title="使用 -s ours master"></a>使用 -s ours master</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b v2 4a50c9f <span class="comment">#切一个新分支并使用历史安全版本</span></span><br><span class="line">git merge -s ours master</span><br><span class="line">git push origin master <span class="comment">#等价于git push origin v2:master</span></span><br></pre></td></tr></table></figure><p>该方法<code>不会改变历史进程</code>，生成一个新的 commit 来覆盖之前的内容达到回滚，墙裂推荐。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@git ….</span><br></pre></td></tr></table></figure><h3 id="创建-SSH-Key"><a href="#创建-SSH-Key" class="headerlink" title="创建 SSH Key"></a>创建 SSH Key</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -c <span class="string">"623212389@qq.com"</span></span><br></pre></td></tr></table></figure><p>用户主目录下 →.ssh→id_rsa（私钥）+id_rsa.pub（公钥）或<code>\$cat ~/.ssh/id-rsa.pub</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">git remote -v     <span class="comment">#查看远程服务器地址和仓库名称</span></span><br><span class="line">git remote show origin   <span class="comment">#查看远程服务器仓库状态</span></span><br><span class="line">git remote add origin git@git……    <span class="comment">#添加远程仓库地址</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin git@git……    <span class="comment">#修改远程地址</span></span><br><span class="line">git remote rm    <span class="comment">#删除远程创库地址</span></span><br><span class="line"></span><br><span class="line">git pull  <span class="comment"># =git fetch + git merge</span></span><br><span class="line">git fetch <span class="comment">#拉取</span></span><br><span class="line">git merge <span class="comment">#合并</span></span><br><span class="line">git push <span class="comment"># push所有分支</span></span><br><span class="line">git push origin master           <span class="comment"># 将本地主分支推到远程主分支</span></span><br><span class="line">git push -u origin master       <span class="comment"># 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</span></span><br><span class="line">git push origin &lt;local_branch&gt;   <span class="comment"># 创建远程分支， origin是远程仓库名</span></span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  <span class="comment"># 创建远程分支</span></span><br><span class="line">git push origin :&lt;remote_branch&gt;  <span class="comment">#先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支</span></span><br><span class="line"></span><br><span class="line">git rebase</span><br><span class="line"></span><br><span class="line">git remote update origin --prune  <span class="comment">#更新远程分支信息</span></span><br></pre></td></tr></table></figure><h2 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><h3 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h3 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a <span class="comment">#远程分支用的红色</span></span><br></pre></td></tr></table></figure><h3 id="查看已经被合并到当前分支的分支"><a href="#查看已经被合并到当前分支的分支" class="headerlink" title="查看已经被合并到当前分支的分支"></a>查看已经被合并到当前分支的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged</span><br></pre></td></tr></table></figure><h3 id="查看未被合并到当前分支的分支"><a href="#查看未被合并到当前分支的分支" class="headerlink" title="查看未被合并到当前分支的分支"></a>查看未被合并到当前分支的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch xxx</span><br></pre></td></tr></table></figure><h3 id="切换分支或标签"><a href="#切换分支或标签" class="headerlink" title="切换分支或标签"></a>切换分支或标签</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout xxx/tag</span><br></pre></td></tr></table></figure><h3 id="创建加切换"><a href="#创建加切换" class="headerlink" title="创建加切换"></a>创建加切换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b xxx</span><br></pre></td></tr></table></figure><h3 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m old new</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d xxx   <span class="comment">#-D为强制删除</span></span><br></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;branchName&gt;</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">git push origin  :&lt;branchName&gt;  <span class="comment">#推送一个空分支到远程</span></span><br></pre></td></tr></table></figure><h2 id="暂存管理"><a href="#暂存管理" class="headerlink" title="暂存管理"></a>暂存管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash  <span class="comment">#将工作区做的修改暂存到一个git栈中</span></span><br><span class="line">git stash list <span class="comment">#查看栈中所有暂存</span></span><br><span class="line">git stash apply &lt;暂存编号&gt;  <span class="comment">#回复对应编号暂存到工作区，如果不指定编号为栈顶的，注意：这些暂存还在栈中</span></span><br><span class="line">git stash pop <span class="comment">#将栈顶的暂存，恢复到工作区，并从栈中弹出</span></span><br><span class="line">git stash clear <span class="comment">#清空暂存栈</span></span><br></pre></td></tr></table></figure><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0 <span class="comment">#id</span></span><br><span class="line">git tag -a v1.0.0 -m <span class="string">"你的附注信息"</span> <span class="comment">#id</span></span><br><span class="line">git tag</span><br><span class="line">git show v1.0.0</span><br><span class="line">git tag -d v1.0.0</span><br><span class="line">git push origin :refs/tags/v1.0.0</span><br><span class="line">git push --tags <span class="comment">#上传所有标签</span></span><br></pre></td></tr></table></figure><h2 id="挑拣提交"><a href="#挑拣提交" class="headerlink" title="挑拣提交"></a>挑拣提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick 1hs73hds <span class="comment">#直接在该分支应用任意其他分支的commit即可</span></span><br></pre></td></tr></table></figure><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>使用 Windows 的童鞋注意了，如果你在资源管理器里新建一个.gitignore 文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore 了。</p><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p>在 GitHub 上，可以任意 Fork 开源仓库； 自己拥有 Fork 后的仓库的读写权限； 可以推送 pull request 给官方仓库来贡献代码。</p><h2 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h2><p><img src="http://cdn.flqin.com/p347-1.png" alt="git命令总结"></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cookie浅析</title>
      <link href="/340.html"/>
      <url>/340.html</url>
      
        <content type="html"><![CDATA[<h2 id="我们看到的-cookie"><a href="#我们看到的-cookie" class="headerlink" title="我们看到的 cookie"></a>我们看到的 cookie</h2><p>例如网址为<a href="http://ppsc.sankuai.com。在这个网页中我设置了几个cookie：JSSESSIONID，PA_VTIME，skmtutc，test。" target="_blank" rel="noopener">http://ppsc.sankuai.com。在这个网页中我设置了几个cookie：JSSESSIONID，PA_VTIME，skmtutc，test。</a></p><p>在 chrome 浏览器中打开这个网站，进入开发者模式，点击 Resources 栏 -&gt; 选择 cookies，我们会看到如下图所示的界面：</p><p><img src="http://cdn.flqin.com/p340-1.png" alt></p><p>解释一下：左边栏 Cookies 下方会列举当前网页中设置过 cookie 的域都有哪些。上图中只有一个域，即“ppsc.sankuai.com”。而右侧区域显示的就是某个域下具体的 cookie 列表，对应上图就是“ppsc.sankuai.com”域下设置的 4 个 cookie。</p><p>在这个网页中我往<a href="http://ppsc.sankuai.com/getList接口发了一个" target="_blank" rel="noopener">http://ppsc.sankuai.com/getList接口发了一个</a> Ajax 请求，request header 如下图所示：</p><p><img src="http://cdn.flqin.com/p340-2.png" alt></p><p>从上图中我们会看到 request header 中自动添加了 Cookie 字段（我并没有手动添加这个字段哦~），Cookie 字段的值其实就是我设置的那 4 个 cookie。这个请求最终会发送到<a href="http://ppsc.sankuai.com这个服务器上，这个服务器就能从接收到的request" target="_blank" rel="noopener">http://ppsc.sankuai.com这个服务器上，这个服务器就能从接收到的request</a> header 中提取那 4 个 cookie。</p><p>上面两张图展示了 cookie 的基本通信流程：设置 cookie =&gt; cookie 被自动添加到 request header 中 =&gt; 服务端接收到 cookie。这个流程中有几个问题需要好好研究：</p><ul><li>什么样的数据适合放在 cookie 中？</li><li>cookie 是怎么设置的？</li><li>cookie 为什么会自动加到 request header 中？</li><li>cookie 怎么增删查改？</li></ul><p>我们要带着这几个问题继续往下阅读。</p><h2 id="cookie-是怎么工作的？"><a href="#cookie-是怎么工作的？" class="headerlink" title="cookie 是怎么工作的？"></a>cookie 是怎么工作的？</h2><p>首先必须明确一点，存储 cookie 是浏览器提供的功能。cookie 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的 cookie。</p><p>当网页要发 http 请求时，浏览器会先检查是否有相应的 cookie，有则自动添加在 request header 中的 cookie 字段中。这些是浏览器自动帮我们做的，而且每一次 http 请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在 cookie 中”。</p><p>存储在 cookie 中的数据，每次都会被浏览器自动放在 http 请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在 cookie 中，其他类型的数据就不适合了。</p><p>但在 localStorage 出现之前，cookie 被滥用当做了存储工具。什么数据都放在 cookie 中，即使这些数据只在页面中使用而不需要随请求传送到服务端。当然 cookie 标准还是做了一些限制的：每个域名下的 cookie 的大小最大为 4KB，每个域名下的 cookie 数量最多为 20 个（但很多浏览器厂商在具体实现时支持大于 20 个）。</p><h2 id="cookie-的格式"><a href="#cookie-的格式" class="headerlink" title="cookie 的格式"></a>cookie 的格式</h2><h3 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h3><p>JS 原生的 API 提供了获取 cookie 的方法：document.cookie（注意，这个方法只能获取非 HttpOnly 类型的 cookie）。在 console 中执行这段代码可以看到结果如下图：</p><p><img src="http://cdn.flqin.com/p340-3.png" alt></p><p>打印出的结果是一个字符串类型，因为 cookie 本身就是存储在浏览器中的字符串。但这个字符串是有格式的，由键值对 key=value 构成，键值对之间由一个分号和一个空格隔开。</p><h3 id="cookie-的属性选项"><a href="#cookie-的属性选项" class="headerlink" title="cookie 的属性选项"></a>cookie 的属性选项</h3><p>每个 cookie 都有一定的属性，如什么时候失效，要发送到哪个域名，哪个路径等等。这些属性是通过 cookie 选项来设置的，cookie 选项包括：expires、domain、path、secure、HttpOnly。在设置任一个 cookie 时都可以设置相关的这些属性，当然也可以不设置，这时会使用这些属性的默认值。在设置这些属性时，属性之间由一个分号和一个空格隔开。代码示例如下：</p><pre><code>&quot;key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly&quot;</code></pre><p><strong>expires</strong></p><p>expires 选项用来设置“cookie 什么时间内有效”。expires 其实是 cookie 失效日期，expires 必须是 GMT 格式的时间（可以通过 new Date().toGMTString()或者 new Date().toUTCString() 来获得）。</p><p>如 expires=Thu, 25 Feb 2016 04:18:00 GMT 表示 cookie 讲在 2016 年 2 月 25 日 4:18 分之后失效，对于失效的 cookie 浏览器会清空。如果没有设置该选项，则默认有效期为 session，即会话 cookie。这种 cookie 在浏览器关闭后就没有了。</p><blockquote><p>expires 是 http/1.0 协议中的选项，在新的 http/1.1 协议中 expires 已经由 max-age 选项代替，两者的作用都是限制 cookie 的有效时间。expires 的值是一个时间点（cookie 失效时刻= expires），而 max-age 的值是一个以秒为单位时间段（cookie 失效时刻= 创建时刻+ max-age）。 另外，max-age 的默认值是 -1(即有效期为 session )；若 max-age 有三种可能值：负数、0、正数。负数：有效期 session；0：删除 cookie；正数：有效期为创建时刻+ max-age</p></blockquote><p><strong>domain 和 path</strong></p><p>domain 是域名，path 是路径，两者加起来就构成了 URL，domain 和 path 一起来限制 cookie 能被哪些 URL 访问。</p><p>一句话概括：某 cookie 的 domain 为“baidu.com”, path 为“/ ”，若请求的 URL(URL 可以是 js/html/img/css 资源请求，但不包括 XHR 请求)的域名是“baidu.com”或其子域如“api.baidu.com”、“dev.api.baidu.com”，且 URL 的路径是“/ ”或子路径“/home”、“/home/login”，则浏览器会将此 cookie 添加到该请求的 cookie 头部中。</p><p>所以 domain 和 path2 个选项共同决定了 cookie 何时被浏览器自动添加到请求头部中发送出去。如果没有设置这两个选项，则会使用默认值。domain 的默认值为设置该 cookie 的网页所在的域名，path 默认值为设置该 cookie 的网页所在的目录。</p><blockquote><p><strong>特别说明 1：</strong> 发生跨域 xhr 请求时，即使请求 URL 的域名和路径都满足 cookie 的 domain 和 path，默认情况下 cookie 也不会自动被添加到请求头部中。若想知道原因请阅读本文最后一节）</p><p><strong>特别说明 2：</strong> domain 是可以设置为页面本身的域名（本域），或页面本身域名的父域，但不能是公共后缀 public suffix。举例说明下：如果页面域名为 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>, domain 可以设置为“<a href="http://www.baidu.com”，也可以设置为“baidu.com”，但不能设置为“.com”或“com”。" target="_blank" rel="noopener">www.baidu.com”，也可以设置为“baidu.com”，但不能设置为“.com”或“com”。</a></p></blockquote><p><strong>secure</strong></p><p>secure 选项用来设置 cookie 只在确保安全的请求中才会发送。当请求是 HTTPS 或者其他安全协议时，包含 secure 选项的 cookie 才能被发送至服务器。</p><p>默认情况下，cookie 不会带 secure 选项(即为空)。所以默认情况下，不管是 HTTPS 协议还是 HTTP 协议的请求，cookie 都会被发送至服务端。但要注意一点，secure 选项只是限定了在安全情况下才可以传输给服务端，但并不代表你不能看到这个 cookie。</p><p>下面我们设置一个 secure 类型的 cookie：</p><pre><code>document.cookie = &quot;name=huang; secure&quot;;</code></pre><p>之后你就能在控制台中看到这个 cookie 了，如下图所示：</p><p><img src="http://cdn.flqin.com/p340-4.png" alt></p><blockquote><p>这里有个坑需要注意下： 如果想在客户端即网页中通过 js 去设置 secure 类型的 cookie，必须保证网页是 https 协议的。在 http 协议的网页中是无法设置 secure 类型 cookie 的。</p></blockquote><p><strong>httpOnly</strong></p><p>这个选项用来设置 cookie 是否能通过 js 去访问。默认情况下，cookie 不会带 httpOnly 选项(即为空)，所以默认情况下，客户端是可以通过 js 代码去访问（包括读取、修改、删除等）这个 cookie 的。当 cookie 带 httpOnly 选项时，客户端则无法通过 js 代码去访问（包括读取、修改、删除等）这个 cookie。</p><p>在客户端是不能通过 js 代码去设置一个 httpOnly 类型的 cookie 的，这种类型的 cookie 只能通过服务端来设置。</p><p>那我们在页面中怎么知道哪些 cookie 是 httpOnly 类型的呢？看下图：</p><p><img src="http://cdn.flqin.com/p340-5.png" alt></p><p>凡是 httpOnly 类型的 cookie，其 HTTP 一列都会打上 √，如上图中的 PA_VTIME。你通过 document.cookie 是不能获取的，也不能修改 PA_VTIME 的。</p><blockquote><p>——httpOnly 与安全</p><p>从上面介绍中，大家是否会有这样的疑问：为什么我们要限制客户端去访问 cookie？其实这样做是为了保障安全。</p><p>试想：如果任何 cookie 都能被客户端通过 document.cookie 获取会发生什么可怕的事情。当我们的网页遭受了 XSS 攻击，有一段恶意的 script 脚本插到了网页中。这段 script 脚本做的事情是：通过 document.cookie 读取了用户身份验证相关的 cookie，并将这些 cookie 发送到了攻击者的服务器。攻击者轻而易举就拿到了用户身份验证信息，于是就可以摇摇大摆地冒充此用户访问你的服务器了（因为攻击者有合法的用户身份验证信息，所以会通过你服务器的验证）。</p></blockquote><h2 id="如何设置-cookie？"><a href="#如何设置-cookie？" class="headerlink" title="如何设置 cookie？"></a>如何设置 cookie？</h2><p>知道了 cookie 的格式，cookie 的属性选项，接下来我们就可以设置 cookie 了。首先得明确一点：cookie 既可以由服务端来设置，也可以由客户端来设置。</p><h3 id="服务端设置-cookie"><a href="#服务端设置-cookie" class="headerlink" title="服务端设置 cookie"></a>服务端设置 cookie</h3><p>不管你是请求一个资源文件（如 html/js/css/图片），还是发送一个 ajax 请求，服务端都会返回 response。而 response header 中有一项叫 set-cookie，是服务端专门用来设置 cookie 的。如下图所示，服务端返回的 response header 中有 5 个 set-cookie 字段，每个字段对应一个 cookie（注意不能将多个 cookie 放在一个 set-cookie 字段中），set-cookie 字段的值就是普通的字符串，每个 cookie 还设置了相关属性选项。</p><p><img src="http://cdn.flqin.com/p340-6.png" alt></p><p>注意：</p><ul><li>一个 set-Cookie 字段只能设置一个 cookie，当你要想设置多个 cookie，需要添加同样多的 set-Cookie 字段。</li><li>服务端可以设置 cookie 的所有选项：expires、domain、path、secure、HttpOnly</li></ul><h3 id="客户端设置-cookie"><a href="#客户端设置-cookie" class="headerlink" title="客户端设置 cookie"></a>客户端设置 cookie</h3><p>在网页即客户端中我们也可以通过 js 代码来设置 cookie。如我当前打开的网址为<a href="http://dxw.st.sankuai.com/mp/，在控制台中我们执行了下面代码：" target="_blank" rel="noopener">http://dxw.st.sankuai.com/mp/，在控制台中我们执行了下面代码：</a></p><pre><code>document.cookie = &quot;name=Jonh; &quot;;</code></pre><p>查看浏览器 cookie 面板如下图所示，cookie 确实设置成功了，而且属性选项 domain、path、expires 都用了默认值。</p><p><img src="http://cdn.flqin.com/p340-7.png" alt></p><p>再执行下面代码：</p><pre><code>document.cookie=&quot;age=12; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&quot;;</code></pre><p>查看浏览器 cookie 面板，如下图所示，新的 cookie 设置成功了，而且属性选项 domain、path、expires 都变成了设定的值。</p><p><img src="http://cdn.flqin.com/p340-8.png" alt></p><p>注意：客户端可以设置 cookie 的下列选项：expires、domain、path、secure（有条件：只有在 https 协议的网页中，客户端设置 secure 类型的 cookie 才能成功），但无法设置 HttpOnly 选项。</p><p><strong>用 js 如何设置多个 cookie</strong></p><p>当要设置多个 cookie 时， js 代码很自然地我们会这么写：</p><pre><code>document.cookie = &quot;name=Jonh; age=12; class=111&quot;;</code></pre><p>但你会发现这样写只是添加了第一个 cookie“name=John”，后面的所有 cookie 都没有添加成功。所以最简单的设置多个 cookie 的方法就在重复执行 document.cookie = “key=name”，如下：</p><pre><code>document.cookie = &quot;name=Jonh&quot;;document.cookie = &quot;age=12&quot;;document.cookie = &quot;class=111&quot;;</code></pre><h2 id="如何修改、删除"><a href="#如何修改、删除" class="headerlink" title="如何修改、删除"></a>如何修改、删除</h2><h3 id="修改-cookie"><a href="#修改-cookie" class="headerlink" title="修改 cookie"></a>修改 cookie</h3><p>要想修改一个 cookie，只需要重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新 cookie 时，path/domain 这几个选项一定要旧 cookie 保持一样。否则不会修改旧值，而是添加了一个新的 cookie。</p><h3 id="删除-cookie"><a href="#删除-cookie" class="headerlink" title="删除 cookie"></a>删除 cookie</h3><p>删除一个 cookie 也挺简单，也是重新赋值，只要将这个新 cookie 的 expires 选项设置为一个过去的时间点就行了。但同样要注意，path/domain/这几个选项一定要旧 cookie 保持一样。</p><h2 id="cookie-编码"><a href="#cookie-编码" class="headerlink" title="cookie 编码"></a>cookie 编码</h2><p>cookie 其实是个字符串，但这个字符串中逗号、分号、空格被当做了特殊符号。所以当 cookie 的 key 和 value 中含有这 3 个特殊字符时，需要对其进行额外编码，一般会用 escape 进行编码，读取时用 unescape 进行解码；当然也可以用 encodeURIComponent/decodeURIComponent 或者 encodeURI/decodeURI（三者的区别可以参考这篇文章）。</p><pre><code>var key = escape(&quot;name;value&quot;);var value = escape(&quot;this is a value contain , and ;&quot;);document.cookie= key + &quot;=&quot; + value + &quot;; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&quot;;</code></pre><h2 id="跨域请求中-cookie"><a href="#跨域请求中-cookie" class="headerlink" title="跨域请求中 cookie"></a>跨域请求中 cookie</h2><p>之前在介绍 XHR 的一篇文章里面提过：默认情况下，在发生跨域时，cookie 作为一种 credential 信息是不会被传送到服务端的。必须要进行额外设置才可以。具体原因和如何设置可以参考我的这篇文章：你真的会使用 XMLHttpRequest 吗？</p><p>另外，关于跨域资源共享 CORS 极力推荐大家阅读阮一峰老师的这篇 <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a>。</p><h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><p>1.什么时候 cookie 会被覆盖：name/domain/path 这 3 个字段都相同的时候； 2.关于 domain 的补充说明：</p><ul><li>如果显式设置了 domain，则设置成什么，浏览器就存成什么；但如果没有显式设置，则浏览器会自动取 url 的 host 作为 domain 值；</li><li>新的规范中，显式设置 domain 时，如果 value 最前面带点，则浏览器处理时会将这个点去掉，所以最后浏览器存的就是没有点的（注意：但目前大多数浏览器并未全部这么实现）</li><li>前面带点‘.’和不带点‘.’有啥区别：<ul><li>带点：任何 subdomain 都可以访问，包括父 domain</li><li>不带点：只有完全一样的域名才能访问，subdomain 不能（但在 IE 下比较特殊，它支持 subdomain 访问）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(转载)从输入URL到页面加载的过程</title>
      <link href="/336.html"/>
      <url>/336.html</url>
      
        <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>对知识体系进行一次预评级</li><li>为什么说知识体系如此重要？</li><li>梳理主干流程</li><li>从浏览器接收url到开启网络请求线程<ul><li>多进程的浏览器</li><li>多线程的浏览器内核</li><li>解析URL</li><li>网络请求都是单独的线程</li><li>更多</li></ul></li><li>开启网络线程到发出一个完整的http请求<ul><li>DNS查询得到IP</li><li>tcp/ip请求</li><li>五层因特网协议栈</li></ul></li><li>从服务器接收到请求到对应后台接收到请求<ul><li>负载均衡</li><li>后台的处理</li></ul></li><li>后台和前台的http交互<ul><li>http报文结构</li><li>cookie以及优化</li><li>gzip压缩</li><li>长连接与短连接</li><li>http 2.0</li><li>https</li></ul></li><li>单独拎出来的缓存问题，http的缓存<ul><li>强缓存与弱缓存</li><li>缓存头部简述</li><li>头部的区别</li></ul></li><li>解析页面流程<ul><li>流程简述</li><li>HTML解析，构建DOM</li><li>生成CSS规则</li><li>构建渲染树</li><li>渲染</li><li>了解层</li><li>Chrome中的调试</li><li>资源外链的下载</li><li>loaded和domcontentloaded</li></ul></li><li>CSS的可视化格式模型<ul><li>包含块（Containing Block）</li><li>控制框（Controlling Box）</li><li>盒模型</li><li>BFC（Block Formatting Context）</li><li>IFC（Inline Formatting Context）</li><li>其它</li></ul></li><li>JS引擎解析过程<ul><li>JS的解释阶段</li><li>JS的预处理阶段</li><li>JS的执行阶段</li><li>回收机制</li></ul></li><li>其它</li><li>总结</li></ul><h2 id="对知识体系进行一次预评级"><a href="#对知识体系进行一次预评级" class="headerlink" title="对知识体系进行一次预评级"></a>对知识体系进行一次预评级</h2><p>看到这道题目，不借助搜索引擎，自己的心里是否有一个答案？</p><p>这里，以目前的经验（了解过一些处于不同阶段的相关前端人员的情况），大概有以下几种情况：（以下都是以点见面，实际上不同阶段人员一般都会有其它的隐藏知识点的）</p><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><p>完全没什么概念的，支支吾吾的回答，一般就是这种水平（大致形象点描述）：</p><ul><li>浏览器发起请求，服务端返回数据，然后前端解析成网页，执行脚本。。。</li></ul><p>这类人员一般都是：</p><ul><li>萌新（刚接触前端的，包括0-6个月都有可能有这种回答）</li><li>沉淀人员（就是那种可能已经接触了前端几年，但是仍然处于初级阶段的那种。。。）</li></ul><p>当然了，后者一般还会偶尔提下<code>http、后台、浏览器渲染，js引擎</code>等等关键字，但基本都是一详细的问就不知道了。。。</p><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><p>已经有初步概念，但是可能没有完整梳理过，导致无法形成一个完整的体系，或者是很多细节都不会展开，大概是这样子的：（可能符合若干条）</p><ul><li>知道浏览器输入url后会有http请求这个概念</li><li>有后台这个概念，大致知道前后端的交互，知道前后端靠http报文通信</li><li>知道浏览器接收到数据后会进行解析，有一定概念，但是具体流程不熟悉（如render树构建流程，layout、paint，复合层与简单层，常用优化方案等不是很熟悉）</li><li>对于js引擎的解析流程有一定概念，但是细节不熟悉（如具体的形参，函数，变量提升，执行上下文以及VO、AO、作用域链，回收机制等概念不是很熟悉）</li><li>如可能知道一些http规范初步概念，但是不熟悉（如http报文结构，常用头部，缓存机制，http2.0，https等特性，跨域与web安全等不是很熟悉）</li></ul><p>到这里，看到这上面一大堆的概念后，心里应该也会有点底了。。。</p><p><strong>实际上，大部分的前端人员可能都处于level2</strong>，但是，跳出这个阶段并不容易，一般需要积累，不断学习，才能水到渠成。</p><p>这类人员一般都是：</p><ul><li>工作1-3年左右的普通人员（占大多数，而且大多数人员工作3年左右并没有实质上的提升）</li><li>工作3年以上的老人（这部分人大多都业务十分娴熟，一个当好几个用，但是，基础比较薄弱，可能没有尝试写过框架、组件、脚手架等）</li></ul><p>大部分的初中级都陷在这个阶段，如果要突破，不断学习，积累，自然能水到渠成，打通任督二脉。</p><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>基本能到这一步的，不是高阶就是接近高阶，因为很多概念并不是靠背就能理解的，而要理解这么多，需形成体系，一般都需要积累，非一日之功。</p><p>一般包括什么样的回答呢？（这里就以自己的简略回答进行举例），一般这个阶段的人员都会符合若干条（不一定全部，当然可能还有些是这里遗漏的）:</p><ul><li>首先略去那些键盘输入、和操作系统交互、以及屏幕显示原理、网卡等硬件交互之类的（前端向中，很多硬件原理暂时略去。。。）</li><li>对浏览器模型有整体概念，知道浏览器是多进程的，浏览器内核是多线程的，清楚进程与线程之间得区别，以及输入url后会开一个新的网络线程</li><li>对从开启网络线程到发出一个完整的http请求中间的过程有所了解（如dns查询，tcp/ip链接，五层因特网协议栈等等，以及一些优化方案，如dns-prefetch）</li><li>对从服务器接收到请求到对应后台接收到请求有一定了解（如负载均衡，安全拦截以及后台代码处理等）</li><li>对后台和前台的http交互熟悉（包括http报文结构，场景头部，cookie，跨域，web安全，http缓存，http2.0，https等）</li><li>对浏览器接收到http数据包后的解析流程熟悉（包括解析html，词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、里面可能还包括复合图层的合成、GPU绘制、外链处理、加载顺序等）</li><li>对JS引擎解析过程熟悉（包括JS的解释，预处理，执行上下文，VO，作用域链，this，回收机制等）</li></ul><p>可以看到，上述包括了一大堆的概念，仅仅是偏前端向，而且没有详细展开，就已经如此之多的概念了，所以，个人认为如果没有自己的见解，没有形成自己的知识体系，仅仅是看看，背背是没用的，过一段时间就会忘光了。</p><p>再说下一般这个阶段的都可能是什么样的人吧。（不一定准确，这里主要是靠少部分现实以及大部分推测得出）</p><ul><li>工作2年以上的前端（基本上如果按正常进度的话，至少接触前端两年左右才会开始走向高阶，当然，现在很多都是上学时就开始学了的，还有部分是天赋异禀，不好预估。。。）</li><li>或者是已经十分熟悉其它某门语言，再转前端的人（基本上是很快就可以将前端水准提升上去）</li></ul><p>一般符合这个条件的都会有各种隐藏属性（如看过各大框架、组件的源码，写过自己的组件、框架、脚手架，做过大型项目，整理过若干精品博文等）</p><h3 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h3><p>由于本人层次尚未达到，所以大致说下自己的见解吧。</p><p>一般这个层次，很多大佬都并不仅仅是某个技术栈了，而是成为了技术专家，技术leader之类的角色。所以仅仅是回答某个技术问题已经无法看出水准了， 可能更多的要看架构，整体把控，大型工程构建能力等等</p><p>不过，对于某些执着于技术的大佬，大概会有一些回答吧：（猜的）</p><ul><li>从键盘谈起到系统交互，从浏览器到CPU，从调度机制到系统内核，从数据请求到二进制、汇编，从GPU绘图到LCD显示，然后再分析系统底层的进程、内存等等</li></ul><p>总之，从软件到硬件，到材料，到分子，原子，量子，薛定谔的猫，人类起源，宇宙大爆炸，平行宇宙？感觉都毫无违和感。。。</p><p>这点可以参考下本题的原始出处：<a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="noopener">查阅</a></p><h2 id="为什么说知识体系如此重要"><a href="#为什么说知识体系如此重要" class="headerlink" title="为什么说知识体系如此重要"></a>为什么说知识体系如此重要</h2><p>为什么说知识体系如此重要呢？这里举几个例子</p><p>假设有被问到这样一道题目（随意想到的一个）：</p><ul><li>如何理解<code>getComputedStyle</code></li></ul><p>在尚未梳理知识体系前，大概会这样回答：</p><ul><li>普通版本：<code>getComputedStyle</code>会获取当前元素所有最终使用的CSS属性值（最终计算后的结果），通过<code>window.getComputedStyle</code>等价于<code>document.defaultView.getComputedStyle</code>调用</li><li>详细版本：<code>window.getComputedStyle(elem, null).getPropertyValue(&quot;height&quot;)</code>可能的值为<code>100px</code>，而且，就算是css上写的是<code>inherit</code>，<code>getComputedStyle</code>也会把它最终计算出来的。不过注意，如果元素的背景色透明，那么<code>getComputedStyle</code>获取出来的就是透明的这个背景（因为透明本身也是有效的），而不会是父节点的背景。所以它不一定是最终显示的颜色。</li></ul><p>就这个API来说，上述的回答已经比较全面了。</p><p>但是，其实它是可以继续延伸的。</p><p>譬如现在会这样回答：</p><ul><li><code>getComputedStyle</code>会获取当前元素所有最终使用的CSS属性值，<code>window.</code>和<code>document.defaultView.</code>等价</li><li><code>getComputedStyle</code>会引起回流，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），所以用的时候慎用，回流会引起性能问题。然后合适的话会将话题引导回流，重绘，浏览器渲染原理等等。当然也可以列举一些其它会引发回流的操作，如<code>offsetXXX，scrollXXX，clientXXX，currentStyle</code>等等</li></ul><p>再举一个例子：</p><ul><li><code>visibility: hidden</code>和<code>display: none</code>的区别</li></ul><p>可以如下回答：</p><ul><li>普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置</li><li>进一步，display由于隐藏后不占据位置，所以造成了dom树的改变，会引发<code>回流</code>，代价较大</li><li>再进一步，当一个页面某个元素经常需要切换<code>display</code>时如何优化，一般会用复合层优化，或者要求低一点用<code>absolute</code>让其脱离普通文档流也行。然后可以将话题引到普通文档流，<code>absolute</code>文档流，复合图层的区别，</li><li>再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）</li></ul><p>上面这些大概就是知识系统化后的回答，会更全面，容易由浅入深，而且一有机会就可以往更底层挖</p><h3 id="前端向知识的重点"><a href="#前端向知识的重点" class="headerlink" title="前端向知识的重点"></a>前端向知识的重点</h3><p>此部分的内容是站在个人视角分析的，并不是说就一定是正确答案</p><p>首先明确，计算机方面的知识是可以无穷无尽的挖的，而本文的重点是梳理<code>前端向</code>的重点知识</p><p>对于<code>前端向</code>（这里可能没有提到<code>node.js</code>之类的，更多的是指客户端前端），这里将知识点按重要程度划分成以下几大类：</p><ul><li>核心知识，必须掌握的，也是最基础的，譬如浏览器模型，渲染原理，JS解析过程，JS运行机制等，作为骨架来承载知识体系</li><li>重点知识，往往每一块都是一个知识点，而且这些知识点都很重要，譬如http相关，web安全相关，跨域处理等</li><li>拓展知识，这一块可能更多的是了解，稍微实践过，但是认识上可能没有上面那么深刻，譬如五层因特网协议栈，hybrid模式，移动原生开发，后台相关等等（当然，在不同领域，可能有某些知识就上升到重点知识层次了，譬如hybrid开发时，懂原生开发是很重要的）</li></ul><p>为什么要按上面这种方式划分？</p><p>这大概与个人的技术成长有关。</p><p>记得最开始学前端知识时，是一点一点的积累，一个知识点一个知识点的攻克。</p><p>就这样，虽然在很长一段时间内积累了不少的知识，但是，总是无法将它串联到一起。每次梳理时都是很分散的，无法保持思路连贯性。</p><p>直到后来，在将<code>浏览器渲染原理</code>、<code>JS运行机制</code>、<code>JS引擎解析流程</code>梳理一遍后，感觉就跟打通了任督二脉一样，有了一个整体的架构，以前的知识点都连贯起来了。</p><p>梳理出了一个知识体系，以后就算再学新的知识，也会尽量往这个体系上靠拢，环环相扣，更容易理解，也更不容易遗忘。</p><h2 id="梳理主干流程"><a href="#梳理主干流程" class="headerlink" title="梳理主干流程"></a>梳理主干流程</h2><p>回到这道题上，如何回答呢？先梳理一个骨架</p><p>知识体系中，最重要的是骨架，脉络。有了骨架后，才方便填充细节。所以，先梳理下<code>主干流程</code>：</p><ol><li>从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</li><li>开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）</li><li>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</li><li>后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）</li><li>单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）</li><li>浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</li><li>CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）</li><li>JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</li><li>其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）</li></ol><p>梳理出主干骨架，然后就需要往骨架上填充细节内容。</p><h2 id="从浏览器接收url到开启网络请求线程"><a href="#从浏览器接收url到开启网络请求线程" class="headerlink" title="从浏览器接收url到开启网络请求线程"></a>从浏览器接收url到开启网络请求线程</h2><p>这一部分展开的内容是：<code>浏览器进程/线程模型</code>，<code>JS引擎的运行机制</code></p><h3 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h3><p>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）</p><p>进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p><ul><li>Browser进程：浏览器的主进程（负责协调、主控），只有一个</li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D绘制</li><li>浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li></ul><p><img src="http://cdn.flqin.com/p336-1.png" alt="多进程的浏览器"></p><h3 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" class="headerlink" title="多线程的浏览器内核"></a>多线程的浏览器内核</h3><p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程</p><ul><li>GUI线程</li><li>JS引擎线程</li><li>事件触发线程</li><li>定时器线程</li><li>网络请求线程</li></ul><p><img src="http://cdn.flqin.com/p336-2.png" alt="多线程的浏览器内核"></p><p>可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的，<a href="https://blog.flqin.com/359.html">JS引擎的运行机制查阅</a></p><h3 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h3><p>输入URL后，会进行解析（URL的本质就是统一资源定位符）</p><p>URL一般包括几大部分：</p><ul><li><code>protocol</code>，协议头，譬如有http，ftp等</li><li><code>host</code>，主机域名或IP地址</li><li><code>port</code>，端口号</li><li><code>path</code>，目录路径</li><li><code>query</code>，即查询参数</li><li><code>fragment</code>，即<code>#</code>后的hash值，一般用来定位到某个位置</li></ul><h3 id="网络请求都是单独的线程"><a href="#网络请求都是单独的线程" class="headerlink" title="网络请求都是单独的线程"></a>网络请求都是单独的线程</h3><p>每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载</p><p>因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）</p><h2 id="开启网络线程到发出一个完整的http请求"><a href="#开启网络线程到发出一个完整的http请求" class="headerlink" title="开启网络线程到发出一个完整的http请求"></a>开启网络线程到发出一个完整的http请求</h2><p>这一部分主要内容包括：<code>dns查询</code>，<code>tcp/ip请求构建</code>，<code>七层因特网协议栈（ISO）</code>等等</p><p>仍然是先梳理主干，有些详细的过程不展开（因为展开的话内容过多）</p><h3 id="DNS查询得到IP"><a href="#DNS查询得到IP" class="headerlink" title="DNS查询得到IP"></a>DNS查询得到IP</h3><p>如果输入的是域名，需要进行dns解析成IP，大致流程：</p><ul><li>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用<code>host</code></li><li>如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP</li></ul><p>注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）</p><p>而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑<code>dns-prefetch</code>优化</p><p>这一块可以深入展开，具体请去网上搜索，这里就不占篇幅了（网上可以看到很详细的解答）</p><h3 id="tcp-ip请求"><a href="#tcp-ip请求" class="headerlink" title="tcp/ip请求"></a>tcp/ip请求</h3><p><code>http</code>的本质就是<code>tcp/ip</code>请求，<code>tcp</code>将<code>http</code>长报文划分为短报文，通过<code>三次握手</code>与服务端建立连接，进行可靠传输</p><p>然后，待到断开连接时，由于TCP连接是<code>全双工</code>的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个<code>FIN</code>来终止这个方向的连接。收到一个<code>FIN</code>只意味着这一方向上没有数据流动，一个TCP连接在收到一个<code>FIN</code>后仍能发送数据。首先进行关闭的一方将执行<code>主动关闭</code>，而另一方执行<code>被动关闭</code>。</p><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ul><li>SYN(synchronous建立联机)同步序列号</li><li>ACK(acknowledgement 确认)应答码</li><li>PSH(push传送)</li><li>FIN(finish结束)</li><li>RST(reset重置)</li><li>URG(urgent紧急)</li><li>Sequence number(seq 顺序号码) 对方上次的ack（首次发送时seq为系统随机生成）</li><li>Acknowledge number(ack 确认号码)对方的seq+1（无数据传输时） 或者 seq+L（报文数据的长度L）</li></ul><p><img src="http://cdn.flqin.com/p336-17.png" alt="TCP通信握手图解"></p><h4 id="三次握手的步骤"><a href="#三次握手的步骤" class="headerlink" title="三次握手的步骤"></a>三次握手的步骤</h4><ol><li>客户端发送<code>SYN包</code>（SYN=1,seq=x,x为随机数）的数据包到服务器，并进入<code>SYN_SEND</code>状态，等待服务器确认</li><li>服务器收到<code>SYN包</code>，发现SYN=1知客户端想请求连接，然后需要确认客户的<code>SYN包</code>（ACK number=x+1,ACK位码=1），同时自己也发送一个<code>SYN包</code>（seq=y），即<code>SYN+ACK包</code>，此时服务器进入<code>SYN_RECV</code>状态</li><li>客户端收到服务器的<code>SYN＋ACK包</code>，发现<code>ACK number=x+1，ACK位码=1</code>的话， 就向服务器发送<code>确认包ACK</code>(ACK number=y+1，ACK位码=1)，此包发送完毕，客户端和服务器进入<code>ESTABLISHED</code>状态，完成三次握手</li></ol><p>建立连接成功后，接下来就正式传输数据。</p><h4 id="四次挥手的步骤"><a href="#四次挥手的步骤" class="headerlink" title="四次挥手的步骤"></a>四次挥手的步骤</h4><ol><li>主动关闭方发送一个<code>FIN包</code>，用来关闭主动方到被动方的数据传送</li><li>被动方收到<code>FIN包</code>后，发送一个<code>ACK</code>给对方，确认序号为收到序号+1</li><li>被动方发送一个<code>FIN包</code>，用来关闭被动方到主动方的数据传送</li><li>主动方收到<code>FIN包</code>后，发送一个<code>ACK</code>给被动关闭方，确认序号为收到序号+1</li></ol><p>注：2，3次挥手不会一起发送，当<code>Server端</code>收到<code>FIN</code>报文时，很可能并不会立即关闭 <code>SOCKET</code>，所以只能先回复一个<code>ACK</code>报文，告诉<code>Client端</code>，”你发的<code>FIN报文</code>我收到了”。只有等到我<code>Server端</code>所有的报文都发送完了，我才能发送<code>FIN报文</code>，因此不能一起发送。</p><h4 id="tcp-ip的并发限制"><a href="#tcp-ip的并发限制" class="headerlink" title="tcp/ip的并发限制"></a>tcp/ip的并发限制</h4><p>在 <code>HTTP/1.0</code> 中，一个服务器在发送完一个 <code>HTTP</code> 响应后，会断开 <code>TCP</code> 链接。但是这样每次请求都会重新建立和断开 <code>TCP</code> 连接，代价过大。</p><p>所以 <code>HTTP/1.1</code> 就把 Connection 头写进标准(<code>Connection: keep-alive</code>)，并且默认开启<code>持久连接</code>，除非请求中写明 <code>Connection: close</code>，那么浏览器和服务器之间是会维持一段时间的 <code>TCP</code> 连接，不会一个请求结束就断掉，这样 <code>SSL</code> 的开销也可以避免。 在 <code>chrome</code> 浏览器里通过 <code>network</code> 标签 -&gt; <code>connection ID</code>表示<code>TCP连接</code>的重用</p><p>在<code>HTTP/1.1</code>中，单个 <code>TCP连接</code> 在同一时刻只能处理一个请求，顺序处理多个请求； 在 <code>HTTP2</code> 中由于 <code>Multiplexing</code> 特点的存在，多个 <code>HTTP 请求</code> 可以在同一个 <code>TCP 连接</code> 中并行进行。</p><p>浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等），Chrome 最多允许对同一个 Host 建立六个 TCP 连接。</p><h4 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h4><p><code>get</code>和<code>post</code>虽然本质都是<code>tcp/ip</code>，但两者除了在<code>http</code>层面外，在<code>tcp/ip</code>层面也有区别。</p><p><code>get</code>会产生一个<code>tcp</code>数据包，<code>post</code>两个</p><p>具体就是：</p><ul><li><code>get</code>请求时，浏览器会把<code>headers</code>和<code>data</code>一起发送出去，服务器响应200（返回数据），</li><li><code>post</code>请求时，浏览器先发送<code>headers</code>，服务器响应<code>100 continue</code>， 浏览器再发送<code>data</code>，服务器响应200（返回数据）。</li></ul><p>再说一点，这里的区别是<code>specification</code>（规范）层面，而不是<code>implementation</code>（对规范的实现）</p><h4 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP/UDP的区别"></a>TCP/UDP的区别</h4><ul><li>TCP是面向连接的，UDP是面向无连接的。TCP在通信之前必须通过三次握手机制与对方建立连接，而UDP通信不必与对方建立连接，不管对方的状态就直接把数据发送给对方</li><li>TCP连接过程耗时，UDP不耗时</li><li>TCP连接过程中出现的延时增加了被攻击的可能，安全性不高，而UDP不需要连接，安全性较高</li><li>TCP是可靠的，保证数据传输的正确性，不易丢包;UDP是不可靠的，易丢包</li><li>TCP传输速率较慢，实时性差，udp传输速率较快。tcp建立连接需要耗时，并且tcp首部信息太多，每次传输的有用信息较少，实时性差</li><li>TCP是流模式，udp是数据包模式。tcp只要不超过缓冲区的大小就可以连续发送数据到缓冲区上，接收端只要缓冲区上有数据就可以读取，可以一次读取多个数据包，而udp一次只能读取一个数据包，数据包之间独立</li></ul><h4 id="TCP可靠性的四大手段"><a href="#TCP可靠性的四大手段" class="headerlink" title="TCP可靠性的四大手段"></a>TCP可靠性的四大手段</h4><ul><li><strong>顺序编号</strong>：tcp在传输文件的时候，会将文件拆分为多个tcp数据包，每个装满的数据包大小大约在1k左右，tcp协议为保证可靠传输，会将这些数据包顺序编号</li><li><strong>确认机制</strong>：当数据包成功的被发送方发送给接收方，接收方会根据tcp协议反馈给发送方一个成功接收的ACK信号，信号中包含了当前包的序号</li><li><strong>超时重传</strong>：当发送方发送数据包给接收方时，会为每一个数据包设置一个定时器，当在设定的时间内，发送方仍没有收到接收方的ACK信号，会再次发送该数据包，直到收到接收方的ACK信号或者连接已断开</li><li><strong>校验信息</strong>：tcp首部校验信息较多，udp首部校验信息较少</li></ul><h3 id="七层因特网协议栈（ISO）"><a href="#七层因特网协议栈（ISO）" class="headerlink" title="七层因特网协议栈（ISO）"></a>七层因特网协议栈（ISO）</h3><p><img src="http://cdn.flqin.com/p336-16.jpeg" alt="五层因特网协议栈"></p><p><strong>从客户端发出http请求到服务器接收，中间会经过一系列的流程。</strong></p><p>简括就是：<strong>从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。</strong></p><p>当然，服务端的接收就是反过来的步骤。</p><p>七层因特网协议栈其实就是：</p><ol><li>应用层(http,ftp) 这一层为操作系统或网络应用程序提供访问网络服务的接口,如DNS解析成IP并发送http请求</li><li>表示层(Telnet,SNMP) 主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</li><li>会话层(dns,SMTP) 这一层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话，如控制登陆和注销过程。 (QoS)</li><li>传输层(tcp,udp) 建立tcp连接（三次握手）,数据的单位称为数据段（segment）（四层交换机）</li><li>网络层(IP,ARP) IP寻址，数据的单位称为数据包（packet）（路由器、三层交换机）</li><li>数据链路层(PPP) 将bit流封装成frame帧（网桥、二层交换机）</li><li>物理层(传输bit流) 物理传输（然后传输的时候通过双绞线、电磁波、光纤、中继器和集线器 &amp; RJ-45(网线接口)等各种介质）</li></ol><h2 id="从服务器接收到请求到对应后台接收到请求"><a href="#从服务器接收到请求到对应后台接收到请求" class="headerlink" title="从服务器接收到请求到对应后台接收到请求"></a>从服务器接收到请求到对应后台接收到请求</h2><p>服务端在接收到请求时，内部会进行很多的处理</p><p>这里由于不是专业的后端分析，所以只是简单的介绍下，不深入</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡</p><p>当然了，负载均衡不止这一种实现方式，这里不深入…</p><p>简单的说：<strong>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户</strong></p><h3 id="后台的处理"><a href="#后台的处理" class="headerlink" title="后台的处理"></a>后台的处理</h3><p>一般后台都是部署到容器中的，所以一般为：</p><ul><li>先是容器接受到请求（如tomcat容器）</li><li>然后对应容器中的后台程序接收到请求（如java程序）</li><li>然后就是后台会有自己的统一处理，处理完后响应响应结果</li></ul><p>概括下：</p><ul><li>一般有的后端是有统一的验证的，如安全拦截，跨域验证</li><li>如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）</li><li>然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）</li><li>等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）</li><li>然后就是将这个包从后端发送到前端，完成交互</li></ul><h2 id="后台和前台的http交互"><a href="#后台和前台的http交互" class="headerlink" title="后台和前台的http交互"></a>后台和前台的http交互</h2><p>前后端交互时，http报文作为信息的载体，所以http是一块很重要的内容，这一部分重点介绍它</p><h3 id="http报文结构"><a href="#http报文结构" class="headerlink" title="http报文结构"></a>http报文结构</h3><p>报文一般包括了：<code>通用头部(General)</code>，<code>请求/响应头部</code>，<code>请求/响应体</code></p><h4 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h4><p>这也是开发人员见过的最多的信息，包括如下：</p><ul><li><code>Request Url</code>: 请求的web服务器地址</li><li><code>Request Method</code>: 请求方式（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）</li><li><code>Status Code</code>: 请求的返回状态码，如200代表成功</li><li><code>Remote Address</code>: 请求的远程服务器地址（会转为IP）</li><li><code>Referrer-Policy</code>: 控制请求头中referrer的内容<a href="https://juejin.im/post/5cd81b59518825686a06fd05" target="_blank" rel="noopener">查阅</a></li></ul><p>譬如，在跨域拒绝时，可能是<code>method</code>为<code>options</code>，状态码为<code>404/405</code>等（当然，实际上可能的组合有很多）</p><p>其中，<code>Method</code>的话一般分为两批次：</p><ul><li><code>HTTP1.0</code>定义了三种请求方法：<code>GET, POST 和 HEAD方法</code>。以及几种<code>Additional Request Methods：PUT、DELETE、LINK、UNLINK</code></li><li><code>HTTP1.1</code>定义了八种请求方法：<code>GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</code></li></ul><p>这里面最常用到的就是状态码，很多时候都是通过状态码来判断，如（列举几个最常见的）：</p><ul><li><code>200</code>——表明该请求被成功地完成，所请求的资源发送回客户端</li><li><code>304</code>——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存</li><li><code>400</code>——客户端请求有错（譬如可以是安全模块拦截）</li><li><code>401</code>——请求未经授权</li><li><code>403</code>——禁止访问（譬如可以是未登录时禁止）</li><li><code>404</code>——资源未找到</li><li><code>500</code>——服务器内部错误</li><li><code>503</code>——服务不可用</li></ul><p>再列举下大致不同范围状态的意义</p><ul><li><code>1xx</code>——指示信息，表示请求已接收，继续处理</li><li><code>2xx</code>——成功，表示请求已被成功接收、理解、接受</li><li><code>3xx</code>——重定向，要完成请求必须进行更进一步的操作</li><li><code>4xx</code>——客户端错误，请求有语法错误或请求无法实现</li><li><code>5xx</code>——服务器端错误，服务器未能实现合法的请求</li></ul><p><img src="http://cdn.flqin.com/p336-3.png" alt="http status"></p><p>总之，当请求出错时，状态码能帮助快速定位问题，完整版本的状态可以自行去互联网搜索</p><h4 id="请求-响应头部"><a href="#请求-响应头部" class="headerlink" title="请求/响应头部"></a>请求/响应头部</h4><p>请求和响应头部也是分析时常用到的</p><p>常用的请求头部（部分）：</p><ul><li><code>Accept</code>: 接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）</li><li><code>Accept-Encoding</code>：浏览器支持的压缩类型,如gzip等,超出类型不能接收</li><li><code>Content-Type</code>：客户端发送出去实体内容的类型</li><li><code>Cache-Control</code>: 指定请求和响应遵循的缓存机制，如no-cache</li><li><code>If-Modified-Since</code>：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中</li><li><code>Expires</code>：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间</li><li><code>Max-age</code>：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中</li><li><code>If-None-Match</code>：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中</li><li><code>Cookie</code>: 有cookie并且同域访问时会自动带上</li><li><code>Connection</code>: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive</li><li><code>Host</code>：请求的服务器URL</li><li><code>Origin</code>：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私</li><li><code>Referer</code>：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)</li><li><code>User-Agent</code>：用户客户端的一些必要信息，如UA头部等</li></ul><p>常用的响应头部（部分）：</p><ul><li><code>Access-Control-Allow-Headers</code>: 服务器端允许的请求Headers</li><li><code>Access-Control-Allow-Methods</code>: 服务器端允许的请求方法</li><li><code>Access-Control-Allow-Origin</code>: 服务器端允许的请求Origin头部（譬如为*）</li><li><code>Content-Type</code>：服务端返回的实体内容的类型</li><li><code>Date</code>：数据从服务器发送的时间</li><li><code>Cache-Control</code>：告诉浏览器或其他客户，什么环境可以安全的缓存文档</li><li><code>Last-Modified</code>：请求资源的最后修改时间</li><li><code>Expires</code>：应该在什么时候认为文档已经过期,从而不再缓存它</li><li><code>Max-age</code>：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效</li><li><code>ETag</code>：请求变量的实体标签的当前值</li><li><code>Set-Cookie</code>：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端</li><li><code>Keep-Alive</code>：如果客户端有keep-alive，服务端也会有响应（如timeout=38）</li><li><code>Server</code>：服务器的一些相关信息</li></ul><p>一般来说，请求头部和响应头部是匹配分析的。</p><p>譬如，请求头部的<code>Accept</code>要和响应头部的<code>Content-Type</code>匹配，否则会报错</p><p>譬如，跨域请求时，请求头部的<code>Origin</code>要匹配响应头部的<code>Access-Control-Allow-Origin</code>，否则会报跨域错误</p><p>譬如，在使用缓存时，请求头部的<code>If-Modified-Since、If-None-Match</code>分别和响应头部的<code>Last-Modified、ETag</code>对应</p><h4 id="请求-响应实体"><a href="#请求-响应实体" class="headerlink" title="请求/响应实体"></a>请求/响应实体</h4><p><code>http</code>请求时，除了头部，还有消息实体，一般来说:</p><ul><li><p>请求实体中会将一些需要的参数都放入进入（用于post请求）如实体中可以放参数的序列化形式（a=1&amp;b=2这种），或者直接放表单对象（Form Data对象，上传时可以夹杂参数以及文件）等等</p></li><li><p>响应实体中就是放服务端需要传给客户端的内容，一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。</p></li></ul><h4 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h4><p>CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在</p><p>请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔</p><p>一般来说（分隔符类别）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CRLF-&gt;Windows-style</span><br><span class="line">LF-&gt;Unix Style</span><br><span class="line">CR-&gt;Mac Style</span><br></pre></td></tr></table></figure><p>如下图是对某请求的http报文结构的简要分析:</p><p><img src="http://cdn.flqin.com/p336-4.png" alt="http报文结构"></p><h3 id="cookie以及优化"><a href="#cookie以及优化" class="headerlink" title="cookie以及优化"></a>cookie以及优化</h3><p><code>cookie</code>是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的<code>session</code>使用。</p><p>场景如下（简述）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在登陆页面，用户登陆了</span><br><span class="line">此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）</span><br><span class="line">然后会有一个sessionid（相当于是服务端的这个session对应的key）</span><br><span class="line">然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx</span><br><span class="line">然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。</span><br></pre></td></tr></table></figure><p>上述就是<code>cookie</code>的常用场景简述（当然了，实际情况下得考虑更多因素）</p><p>一般来说，<code>cookie</code>是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在<code>cookie</code>中设置<code>httponly</code>（这样就无法通过js操作了），另外可以考虑<code>rsa</code>等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全）</p><p>另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。</p><p>譬如以下场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端在域名A下有cookie（这个可以是登陆时由服务端写入的）</span><br><span class="line">然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有<span class="number">20</span>个静态资源）</span><br><span class="line">此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie</span><br><span class="line">也就是说，这<span class="number">20</span>个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证</span><br><span class="line">此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）</span><br></pre></td></tr></table></figure><p>当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是：</p><ul><li>将静态资源分组，分别放到不同的域名下（如<code>static.base.com</code>）</li><li>而<code>page.base.com</code>（页面所在域名）下请求时，是不会带上<code>static.base.com</code>域名的<code>cookie</code>的，所以就避免了浪费</li></ul><p>说到了多域名拆分，这里再提一个问题，那就是：</p><ul><li>在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）</li><li>此时就需要用到一种优化方案：<code>dns-prefetch</code>（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）</li></ul><p>关于cookie的交互，可以看下图总结:</p><p><img src="http://cdn.flqin.com/p336-5.png" alt="cookie交互"></p><h3 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h3><p>首先，明确<code>gzip</code>是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持）， 而且<code>gzip</code>压缩效率很好（高达70%左右）,一般是由<code>apache、tomcat</code>等<code>web</code>服务器开启</p><p>一般只需要在服务器上开启了<code>gzip</code>压缩，然后之后的请求就都是基于<code>gzip</code>压缩格式的，当然服务器除了<code>gzip</code>外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）</p><h3 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h3><p>首先看<code>tcp/ip</code>层面的定义：</p><ul><li>长连接：一个<code>tcp/ip</code>连接上可以连续发送多个数据包，在<code>tcp连接</code>保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li><li>短连接：通信双方有数据交互时，就建立一个<code>tcp连接</code>，数据发送完成后，则断开此<code>tcp连接</code></li></ul><p>然后在http层面：</p><ul><li><code>http1.0</code>中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li><li><code>http1.1</code>起，默认使用长连接，使用长连接会有这一行<code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输<code>http</code>的<code>tcp连接</code>不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li></ul><p>注意： <strong>keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效</strong></p><h3 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h3><p><code>http2.0</code>不是<code>https</code>，它相当于是<code>http</code>的下一代规范（譬如<code>https</code>的请求可以是<code>http2.0</code>规范的）</p><p>然后简述下<code>http2.0</code>与<code>http1.1</code>的显著不同点：</p><ul><li><code>http1.1</code>中，每请求一个资源，都是需要开启一个<code>tcp/ip</code>连接的，所以对应的结果是，每一个资源对应一个<code>tcp/ip</code>请求，由于<code>tcp/ip</code>本身有并发数限制，所以当资源一多，速度就显著慢下来</li><li><code>http2.0</code>中，一个<code>tcp/ip</code>请求可以请求多个资源，也就是说，只要一次<code>tcp/ip</code>请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li></ul><p>所以，如果<code>http2.0</code>全面应用，很多<code>http1.1</code>中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）</p><p>然后简述下<code>http2.0</code>的一些特性：</p><ul><li><strong>多路复用</strong>（即一个<code>tcp/ip</code>连接可以请求多个资源）</li><li><strong>首部压缩</strong>（<code>http</code>头部压缩，减少体积）</li><li><strong>二进制分帧</strong>（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li><li><strong>服务器端推送</strong>（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li><li><strong>请求优先级</strong>（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</li></ul><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p><code>https</code>就是安全版本的<code>http</code>，譬如一些支付等操作基本都是基于<code>https</code>的，因为<code>http</code>请求的安全系数太低了。</p><p>简单来看，<code>https</code>与<code>http</code>的区别就是： 在请求前，会建立<code>ssl链接</code>，确保接下来的通信都是加密的，无法被轻易截取分析。</p><p>一般来说，如果要将网站升级成<code>https</code>，需要后端支持（后端需要申请证书等），然后<code>https</code>的开销也比<code>http</code>要大（因为需要额外建立安全链接以及加密等），所以一般来说h<code>ttp2.0</code>配合<code>https</code>的体验更佳（因为<code>http2.0</code>更快了）</p><p>一般来说，主要关注的就是<code>SSL/TLS</code>的握手流程，如下（简述）：</p><ol><li>浏览器请求建立<code>SSL链接</code>，并向服务端发送一个随机数<code>Client random</code>和客户端支持的<code>加密方法</code>，比如<code>RSA加密</code>，此时是明文传输。</li><li>服务端从中选出一组<code>加密算法</code>与<code>Hash算法</code>，回复一个随机数<code>Server random</code>，并将自己的身份信息以<code>证书</code>的形式发回给浏览器 （证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</li><li>浏览器收到服务端的证书后<ul><li><strong>验证证书的合法性</strong>（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示</li><li>用户接收证书后（不管信不信任），浏览会生产新的随机数<code>Premaster secret</code>，然后证书中的公钥以及指定的加密方法加密<code>Premaster secret</code>，发送给服务器。</li><li>利用<code>Client random</code>、<code>Server random</code>和<code>Premaster secret</code>通过一定的算法生成HTTP链接数据传输的对称加密key-<code>session key</code></li><li>使用约定好的<code>HASH算法</code>计算握手消息，并使用生成的<code>session key</code>对消息进行加密，最后将之前生成的所有信息发送给服务端。</li></ul></li><li>服务端收到浏览器的回复<ul><li>利用已知的加解密方式与自己的私钥进行解密，获取<code>Premaster secret</code></li><li>和浏览器相同规则生成<code>session key</code></li><li>使用<code>session key</code>解密浏览器发来的握手消息，并验证<code>Hash</code>是否与浏览器发来的一致</li><li>使用<code>session key</code>加密一段握手消息，发送给浏览器</li></ul></li><li>浏览器解密并计算握手消息的<code>HASH</code>，如果与服务端发来的<code>HASH</code>一致，此时握手过程结束.</li></ol><p><strong>之后所有的https通信数据将由之前浏览器生成的session key并利用对称加密算法进行加密</strong></p><p>这里放一张图（来源：阮一峰-图解SSL/TLS协议）</p><p><img src="http://cdn.flqin.com/p336-6.png" alt="图解SSL/TLS协议"></p><h2 id="单独拎出来的缓存问题，http的缓存"><a href="#单独拎出来的缓存问题，http的缓存" class="headerlink" title="单独拎出来的缓存问题，http的缓存"></a>单独拎出来的缓存问题，http的缓存</h2><p>前后端的<code>http交互</code>中，使用缓存能很大程度上的提升效率，而且基本上对性能有要求的前端项目都是必用缓存的</p><h3 id="强缓存与弱缓存"><a href="#强缓存与弱缓存" class="headerlink" title="强缓存与弱缓存"></a>强缓存与弱缓存</h3><p>缓存可以简单的划分成两种类型：<code>强缓存（200 from cache）</code>与<code>协商缓存（304）</code></p><p>区别简述如下：</p><ul><li><code>强缓存（200 from cache）</code>时，浏览器如果判断本地缓存未过期，就直接使用，无需发起<code>http请求</code></li><li><code>协商缓存（304）</code>时，浏览器会向服务端发起<code>http请求</code>，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存</li></ul><p>对于协商缓存，使用<code>Ctrl + F5</code>强制刷新可以使得缓存无效</p><p>但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）</p><h3 id="缓存头部简述"><a href="#缓存头部简述" class="headerlink" title="缓存头部简述"></a>缓存头部简述</h3><p>上述提到了强缓存和协商缓存，那它们是怎么区分的呢？</p><p>答案是通过不同的http头部控制</p><p>先看下这几个头部：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match/E-tag、If-Modified-Since/Last-Modified、Cache-Control/Max-Age、Pragma/Expires</span><br></pre></td></tr></table></figure><p>这些就是缓存中常用到的头部，这里不展开。仅列举下大致使用。</p><p>属于强缓存控制的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    （http1.1）Cache-Control/Max-Age</span><br><span class="line">    （http1.0）Pragma/Expires</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">注意：`Max-Age`不是一个头部，它是`Cache-Control`头部的值</span><br><span class="line"></span><br><span class="line">属于协商缓存控制的：</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">    （http1.1）If-None-Match/E-tag</span><br><span class="line">    （http1.0）If-Modified-Since/Last-Modified</span><br></pre></td></tr></table></figure><p>可以看到，上述有提到<code>http1.1</code>和<code>http1.0</code>，这些不同的头部是属于不同<code>http</code>时期的</p><p>再提一点，其实HTML页面中也有一个<code>meta标签</code>可以控制缓存方案:<code>Pragma</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">"Pragma"</span> <span class="attr">CONTENT</span>=<span class="string">"no-cache"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过，这种方案还是比较少用到，因为支持情况不佳，譬如缓存代理服务器肯定不支持，所以不推荐</p><h3 id="头部的区别"><a href="#头部的区别" class="headerlink" title="头部的区别"></a>头部的区别</h3><p>首先明确，<code>http</code>的发展是从<code>http1.0</code>到<code>http1.1</code></p><p>而在<code>http1.1</code>中，出了一些新内容，弥补了<code>http1.0</code>的不足。</p><h3 id="http1-0中的缓存控制"><a href="#http1-0中的缓存控制" class="headerlink" title="http1.0中的缓存控制"></a>http1.0中的缓存控制</h3><ul><li><strong>Pragma</strong>：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）</li><li><strong>Expires</strong>：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41</li><li><strong>If-Modified-Since/Last-Modified</strong>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内</li></ul><h3 id="http1-1中的缓存控制"><a href="#http1-1中的缓存控制" class="headerlink" title="http1.1中的缓存控制"></a>http1.1中的缓存控制</h3><ul><li><strong>Cache-Control</strong>：缓存控制头部，有no-cache、max-age等多种取值</li><li><strong>Max-Age</strong>：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算</li><li><strong>If-None-Match/E-tag</strong>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</li></ul><h3 id="Max-Age相比Expires"><a href="#Max-Age相比Expires" class="headerlink" title="Max-Age相比Expires"></a>Max-Age相比Expires</h3><ul><li><p><strong>Expires</strong>: 使用的是服务器端的时间，但是有时候会有这样一种情况-客户端时间和服务端不同步，那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期，所以一般<code>http1.1</code>后不推荐使用<code>Expires</code></p></li><li><p><strong>Max-Age</strong>: 使用的是客户端本地时间的计算，因此不会有这个问题，因此推荐使用<code>Max-Age</code>。</p></li></ul><p>注意，如果同时启用了<code>Cache-Control</code>与<code>Expires</code>，<code>Cache-Control</code>优先级高。</p><h3 id="E-tag相比Last-Modified"><a href="#E-tag相比Last-Modified" class="headerlink" title="E-tag相比Last-Modified"></a>E-tag相比Last-Modified</h3><ul><li><p><strong>Last-Modified</strong>：表明服务端的文件最后何时改变的,它有一个缺陷就是只能精确到1s，而且有的服务端的文件会周期性的改变，导致缓存失效</p></li><li><p><strong>E-tag</strong>：是一种指纹机制，代表文件相关指纹，只有文件变才会变，也只要文件变就会变，也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了</p></li></ul><p>如果同时带有<code>E-tag</code>和<code>Last-Modified</code>，服务端会优先检查<code>E-tag</code></p><p>各大缓存头部的整体关系如下图:</p><p><img src="http://cdn.flqin.com/p336-7.png" alt="缓存"></p><h2 id="解析页面流程"><a href="#解析页面流程" class="headerlink" title="解析页面流程"></a>解析页面流程</h2><p>前面有提到<code>http交互</code>，那么接下来就是浏览器获取到<code>html</code>，然后解析，渲染</p><h3 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h3><p><code>浏览器内核</code>拿到内容后，渲染步骤大致可以分为以下几步：</p><ol><li>解析HTML，构建DOM树</li><li>解析CSS，生成CSS规则树</li><li>合并DOM树和CSS规则树，生成render树</li><li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li><li>绘制render树（paint），绘制页面像素信息</li><li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</li></ol><p>如下图：</p><p><img src="http://cdn.flqin.com/p336-8.png" alt="页面渲染"></p><h3 id="HTML解析，构建DOM树"><a href="#HTML解析，构建DOM树" class="headerlink" title="HTML解析，构建DOM树"></a>HTML解析，构建DOM树</h3><p>整个渲染步骤中，HTML解析是第一步。</p><p>简单的理解，这一步的流程是这样的：<strong>浏览器解析HTML，构建DOM树。</strong></p><p>解析HTML到构建出DOM当然过程可以简述如下：<code>Bytes → characters → tokens → nodes → DOM</code></p><p>譬如假设有这样一个HTML页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器的处理如下：</p><p><img src="http://cdn.flqin.com/p336-9.png" alt="构建DOM树1"></p><p>列举其中的一些重点过程：</p><ul><li><strong>Conversion转换</strong>：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</li><li><strong>Tokenizing分词</strong>：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</li><li><strong>Lexing词法分析</strong>：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</li><li><strong>DOM构建</strong>：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样 例如：body对象的父节点就是HTML对象，然后段落p对象的父节点就是body对象</li></ul><p>最后的DOM树如下：</p><p><img src="http://cdn.flqin.com/p336-10.png" alt="构建DOM树2"></p><h3 id="生成CSS规则树"><a href="#生成CSS规则树" class="headerlink" title="生成CSS规则树"></a>生成CSS规则树</h3><p>同理，CSS规则树的生成也是类似。简述为：<code>Bytes → characters → tokens → nodes → CSSOM</code></p><p>譬如style.css内容如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold &#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; <span class="attribute">display</span>: none &#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">float</span>: right &#125;</span><br></pre></td></tr></table></figure><p>那么最终的CSSOM树就是：</p><p><img src="http://cdn.flqin.com/p336-11.png" alt="CSSOM树"></p><h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><p>当<code>DOM树</code>和<code>CSSOM树</code>都有了后，就要开始构建渲染树了，一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应，因为有一些不可见的<code>DOM元素</code>不会插入到渲染树中，如<code>head</code>这种不可见的标签或者<code>display: none</code>等。</p><p>整体来说可以看图：</p><p><img src="http://cdn.flqin.com/p336-12.png" alt="构建渲染树"></p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>有了render树，接下来就是开始渲染，基本流程如下：</p><p><img src="http://cdn.flqin.com/p336-13.jpg" alt="渲染"></p><p>图中重要的四个步骤就是：</p><ol><li>计算CSS样式</li><li>构建渲染树</li><li><strong>布局</strong>，主要定位坐标和大小，是否换行，各种<code>position,overflow,z-index</code>属性</li><li><strong>绘制</strong>，将图像绘制出来</li></ol><p>然后，图中的线与箭头代表通过js动态修改了<code>DOM</code>或<code>CSS</code>，导致了<code>重新布局（Layout）</code>或<code>渲染（Repaint）</code></p><p>这里<code>Layout</code>和<code>Repaint</code>的概念是有区别的：</p><ul><li><code>Layout</code>，也称为<code>Reflow(重排)</code>，即<code>回流</code>。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树<ul><li>以下会触发回流：<ul><li>盒子模型相关属性会触发重布局(<code>width,height,padding,margin,display,border-width,border,min-height</code>)</li><li>定位属性及浮动也会触发重布局(<code>top,bottom,left,right,position,float,clear</code>)</li><li>改变节点内部文字结构也会触发重布局(<code>text-align,overflow-y,font-weight,overflow,font-family,line-height,vertival-align,white-space,font-size</code>)</li><li>获取某些属性也会引发回流，很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括：<ul><li><code>offset(Top/Left/Width/Height)</code></li><li><code>scroll(Top/Left/Width/Height)</code></li><li><code>cilent(Top/Left/Width/Height)</code></li><li><code>width,height</code></li><li>调用了<code>getComputedStyle()</code>或者IE的<code>currentStyle</code></li></ul></li></ul></li></ul></li><li><code>Repaint</code>，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（<code>color,border-style,border-radius,visibility,text-decoration,background,background-image,background-position,background-repeat,background-size,outline-color,outline,outline-style,outline-width,box-shadow</code>），此时只需要应用新样式绘制这个元素就可以了</li></ul><p><code>回流</code>一定伴随着<code>重绘</code>，<code>重绘</code>却可以单独出现。<code>回流</code>的成本开销要高于<code>重绘</code>，而且一个节点的<code>回流</code>往往回导致子节点以及同级节点的<code>回流</code>， 所以优化方案中一般都包括，尽量避免<code>回流</code>。</p><p>本身浏览器通过<code>队列化修改</code>和<code>批量显示</code>优化重排版过程。其他一般会有一些<strong>优化方案</strong>，如：</p><ul><li>减少逐项更改dom样式，最好一次性更改<code>style</code>，或者将样式定义为<code>class</code>并一次性更新</li><li>把<code>DOM</code>离线后修改<ul><li>使用<code>documentFragment</code> 对象在内存里操作<code>DOM</code></li><li>先把<code>DOM</code>给<code>display:none</code>(有一次<code>reflow</code>)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来</li><li><code>clone</code>一个<code>DOM</code>结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下</li></ul></li><li>不要把<code>DOM</code>结点的属性值(<code>offset</code>等)放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性,无法避免则将它们缓存到变量</li><li>尽可能的修改层级比较低的<code>DOM</code>。当然，改变层级比较底的<code>DOM</code>有可能会造成大面积的<code>reflow</code>，但是也可能影响范围很小</li><li>将复杂的元素绝对定位(<code>absolute</code>)或固定定位(<code>fixed</code>)，使得它脱离文档流，否则回流代价会很高</li><li>千万不要使用<code>table</code>布局。因为可能很小的一个小改动会造成整个<code>table</code>的重新布局</li></ul><p>再来看一个示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.body.style;</span><br><span class="line"></span><br><span class="line">s.padding = <span class="string">"2px"</span>; <span class="comment">// 回流+重绘</span></span><br><span class="line">s.border = <span class="string">"1px solid red"</span>; <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line">s.color = <span class="string">"blue"</span>; <span class="comment">// 再一次重绘</span></span><br><span class="line">s.backgroundColor = <span class="string">"#ccc"</span>; <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.fontSize = <span class="string">"14px"</span>; <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line"><span class="comment">// 添加node，再一次 回流+重绘</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'abc!'</span>));</span><br></pre></td></tr></table></figure><h3 id="了解层"><a href="#了解层" class="headerlink" title="了解层"></a>了解层</h3><p>在第6步：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.</span> 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</span><br></pre></td></tr></table></figure><h4 id="什么是-composite"><a href="#什么是-composite" class="headerlink" title="什么是 composite"></a>什么是 composite</h4><p>在 <code>DOM</code> 树中每个节点都会对应一个 <code>LayoutObject</code>，当他们的 <code>LayoutObject</code> 处于相同的坐标空间时，就会形成一个 <code>RenderLayers</code> ，也就是渲染层。<code>RenderLayers</code> 来保证页面元素以正确的顺序合成，这时候就会出现层合成（<code>composite</code>），从而正确处理透明元素和重叠元素的显示。</p><p><code>GPU</code>中，各个<code>复合图层</code>是单独绘制的，所以互不影响，可以通过<strong>硬件加速</strong>的方式，声明一个新的<code>复合图层</code>，它会单独分配资源。复合层是独立的，所以一般做动画推荐使用硬件加速。</p><p>调试方式 ：</p><ul><li><code>Chrome源码调试 -&gt; More Tools -&gt; Layers</code></li><li><code>Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders</code>,黄色的就是复合图层信息</li></ul><h4 id="RenderLayers-与-GraphicsLayers"><a href="#RenderLayers-与-GraphicsLayers" class="headerlink" title="RenderLayers 与 GraphicsLayers"></a>RenderLayers 与 GraphicsLayers</h4><p><img src="http://cdn.flqin.com/p336-18.png" alt="RenderLayers 与 GraphicsLayers"></p><p>chrome中：</p><ul><li><code>RenderLayers</code> 渲染层，这是负责对应 <code>DOM 子树</code></li><li><code>GraphicsLayers</code> 图形层，这是负责对应 <code>RenderLayers 子树</code></li></ul><p><code>RenderObjects</code> 保持了树结构，他通过向一个绘图上下文（<code>GraphicsContext</code>）发出必要的绘制调用来绘制 <code>nodes</code>。</p><p>每个 <code>GraphicsLayer</code> 都有一个 <code>GraphicsContext</code>，<code>GraphicsContext</code> 会负责输出该层的<code>位图</code>，<code>位图</code>是存储在共享内存中，作为纹理上传到 <code>GPU</code> 中，最后由 <code>GPU</code> 将多个位图进行合成，然后 <code>draw</code> 到屏幕上，此时，我们的页面也就展现到了屏幕上。</p><h4 id="影响-composite-因素"><a href="#影响-composite-因素" class="headerlink" title="影响 composite 因素"></a>影响 composite 因素</h4><p>以下情形浏览器会主动将渲染层提至合成层(硬件加速)：</p><ul><li>z-index</li><li>3D 或透视变换(perspective transform) CSS 属性</li><li>video, canvas, iframe, Flash等元素</li><li>opacity属性/过渡动画</li><li>position: fixed</li><li>will-change</li><li>filter</li><li>backface-visibility</li><li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li><li>元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li></ul><p>使用硬件加速时，尽可能的使用<strong>z-index</strong>，防止浏览器默认给后续的元素创建复合层渲染.因为在webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，<br>那么在这个元素的后面其它元素会默认变为复合层渲染，如果处理不当会极大的影响性能，即如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层。</p><h4 id="复合图层的优劣"><a href="#复合图层的优劣" class="headerlink" title="复合图层的优劣"></a>复合图层的优劣</h4><ul><li>优：合成层的位图，会交由 <code>GPU</code> 合成，比 <code>CPU</code> 处理要快</li><li>优：当需要 <code>repaint</code> 时，只需要 <code>repaint</code> 本身，不会影响到其他的层</li><li>优：元素提升为合成层后，<code>transform</code> 和 <code>opacity</code> 才不会触发 <code>paint</code>，如果不是合成层，则其依然会触发 <code>paint</code></li><li>劣：大量的合成层，这样会占用很多无辜的 <code>CPU</code> 和内存资源，严重影响了页面的性能</li><li>劣：层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象</li></ul><p>如果你已经把一个元素放到一个新的合成层里，那么可以使用 Timeline 来确认这么做是否真的改进了渲染性能。别盲目提升合成层，一定要分析其实际性能表现。</p><p>在内存资源有限的设备上，合成层带来的性能改善，可能远远赶不上过多合成层开销给页面性能带来的负面影响。同时，由于每个渲染层的纹理都需要上传到 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。</p><h3 id="Chrome中的调试"><a href="#Chrome中的调试" class="headerlink" title="Chrome中的调试"></a>Chrome中的调试</h3><p>Chrome的开发者工具中，Performance中可以看到详细的渲染过程：</p><p><img src="http://cdn.flqin.com/p336-14.png" alt="Chrome中的调试"></p><h3 id="资源外链的下载"><a href="#资源外链的下载" class="headerlink" title="资源外链的下载"></a>资源外链的下载</h3><p>上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了</p><p>简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：</p><ul><li>CSS样式资源</li><li>JS脚本资源</li><li>img图片类资源</li></ul><h4 id="遇到外链时的处理"><a href="#遇到外链时的处理" class="headerlink" title="遇到外链时的处理"></a>遇到外链时的处理</h4><p>当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）</p><h4 id="遇到CSS样式资源"><a href="#遇到CSS样式资源" class="headerlink" title="遇到CSS样式资源"></a>遇到CSS样式资源</h4><p>CSS资源的处理有几个特点：</p><ul><li>CSS下载时异步，不会阻塞浏览器构建<code>DOM树</code></li><li>但是会阻塞<code>渲染</code>，也就是在<code>构建render</code>时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</li><li>有例外，<code>media query</code>声明的CSS是不会阻塞渲染的</li></ul><h4 id="遇到JS脚本资源"><a href="#遇到JS脚本资源" class="headerlink" title="遇到JS脚本资源"></a>遇到JS脚本资源</h4><p>JS脚本资源的处理有几个特点：</p><ul><li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML</li><li>浏览器的优化在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li><li><code>defer</code>与<code>async</code>，普通的脚本是会阻塞浏览器解析的，但是可以加上<code>defer</code>或<code>async</code>属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li></ul><p>注意，<code>defer</code>和<code>async</code>是有区别的： <strong>defer是延迟执行，而async是异步执行。</strong></p><p>简单的说：</p><ul><li><code>async</code>是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在<code>onload</code>前，但不确定在<code>DOMContentLoaded</code>事件的前或后</li><li><code>defer</code>是延迟执行，在浏览器看起来的效果像是将脚本放在了body后面一样（虽然按规范应该是在<code>DOMContentLoaded</code>事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li></ul><h4 id="遇到img图片类资源"><a href="#遇到img图片类资源" class="headerlink" title="遇到img图片类资源"></a>遇到img图片类资源</h4><p>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</p><h3 id="loaded和domcontentloaded"><a href="#loaded和domcontentloaded" class="headerlink" title="loaded和domcontentloaded"></a>loaded和domcontentloaded</h3><p>简单的对比：</p><ul><li><code>DOMContentLoaded</code> 事件触发时，仅当<code>DOM加载</code>完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)</li><li><code>load</code> 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li></ul><h2 id="CSS的可视化格式模型"><a href="#CSS的可视化格式模型" class="headerlink" title="CSS的可视化格式模型"></a>CSS的可视化格式模型</h2><p>前面提到了整体的渲染概念，但实际上文档树中的元素是按什么渲染规则渲染的，是可以进一步展开的</p><p>先了解：</p><ul><li>CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）</li><li>然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局及相互作用</li></ul><p>说到底： <strong>CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树</strong></p><p>关键字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">包含块（Containing Block）</span><br><span class="line">控制框（Controlling Box）</span><br><span class="line">盒模型</span><br><span class="line">BFC（Block Formatting Context）</span><br><span class="line">IFC（Inline Formatting Context）</span><br><span class="line">定位体系</span><br><span class="line">浮动等</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>另外，CSS有三种定位机制：<code>普通流</code>，<code>浮动</code>，<code>绝对定位</code>，如无特别提及，下文中都是针对普通流中的</p><h3 id="包含块（Containing-Block）"><a href="#包含块（Containing-Block）" class="headerlink" title="包含块（Containing Block）"></a>包含块（Containing Block）</h3><p>一个元素的<code>box</code>的定位和尺寸，会与某一矩形框有关，这个框就称之为<code>包含块</code>。</p><p>元素会为它的子孙元素创建<code>包含块</code>，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系。</p><p>譬如：</p><ul><li>根元素是最顶端的元素，它没有父节点，它的包含块就是<code>初始包含块</code></li><li><code>static</code>和<code>relative</code>的包含块由它最近的<code>块级</code>、<code>单元格</code>或者<code>行内块祖先元素</code>的内容框（<code>content</code>）创建</li><li><code>fixed</code>的包含块是当前可视窗口</li><li><code>absolute的</code>包含块由它最近的<code>position</code>属性为<code>absolute</code>、<code>relative</code>或者<code>fixed</code>的祖先元素创建<ul><li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的<code>direction</code>特性</li><li>如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界</li></ul></li></ul><h3 id="控制框（Controlling-Box）"><a href="#控制框（Controlling-Box）" class="headerlink" title="控制框（Controlling Box）"></a>控制框（Controlling Box）</h3><p>块级元素和块框以及行内元素和行框的相关概念</p><h4 id="块框"><a href="#块框" class="headerlink" title="块框"></a>块框</h4><ul><li>块级元素会生成一个块框（<code>Block Box</code>），块框会占据一整行，用来包含子box和生成的内容</li><li>块框同时也是一个块包含框（<code>Containing Box</code>），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围</li></ul><p>关于<strong>匿名块框</strong>的生成，示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DIV</span>&gt;</span></span><br><span class="line">Some text</span><br><span class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span>More text</span><br><span class="line"><span class="tag">&lt;/<span class="name">DIV</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>div</code>生成了一个块框，包含了另一个块框<code>p</code>以及文本内容<code>Some text</code>，此时<code>Some text</code>文本会被强制加到一个匿名的块框里面，被<code>div</code>生成的块框包含（其实这个就是IFC中提到的行框，包含这些行内框的这一行匿名块形成的框，行框和行内框不同）</p><p>换句话说:<br><strong>如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）</strong></p><h4 id="行内框"><a href="#行内框" class="headerlink" title="行内框"></a>行内框</h4><ul><li>一个行内元素生成一个行内框</li><li>行内元素能排在一行，允许左右有其它元素</li></ul><p>关于匿名行内框的生成，示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span>Some <span class="tag">&lt;<span class="name">EM</span>&gt;</span>emphasized<span class="tag">&lt;/<span class="name">EM</span>&gt;</span> text<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br></pre></td></tr></table></figure><p>P元素生成一个块框，其中有几个行内框（如EM），以及文本Some ， text，此时会专门为这些文本生成匿名行内框</p><h4 id="display属性的影响"><a href="#display属性的影响" class="headerlink" title="display属性的影响"></a>display属性的影响</h4><p>display的几个属性也可以影响不同框的生成：</p><ul><li>block，元素生成一个<code>块框</code></li><li>inline，元素产生一个或多个的<code>行内框</code></li><li>inline-block，元素产生一个行<code>内级块框</code>，行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生BFC）</li><li>none，不生成框，不再格式化结构中，当然了，另一个visibility: hidden则会产生一个不可见的框</li></ul><p>总结：</p><ul><li>如果一个框里，有一个块级元素，那么这个框里的内容都会被当作<code>块框</code>来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）</li><li>如果一个框里，没有任何块级元素，那么这个框里的内容会被当成<code>行内框</code>来格式化，因为里面的内容是按照顺序成行的排列</li></ul><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p><code>CSS</code>盒模型本质上是一个盒子，封装周围的<code>HTML</code>元素，它包括：外边距（<code>margin</code>）、边框（b<code>order</code>）、内边距（<code>padding</code>）、实际内容（<code>content</code>）四个属性。</p><h4 id="标准盒子模型"><a href="#标准盒子模型" class="headerlink" title="标准盒子模型"></a>标准盒子模型</h4><p><img src="http://cdn.flqin.com/p336-19.jpg" alt="标准盒子模型"></p><p><code>padding</code>和<code>border</code>不被包含在定义的<code>width</code>和<code>height</code>之内。对象的实际宽度等于设置的<code>width</code>值和<code>border</code>、<code>padding</code>之和，即 <code>Element width = width + border + padding</code></p><h4 id="IE盒子模型-怪异盒模型"><a href="#IE盒子模型-怪异盒模型" class="headerlink" title="IE盒子模型(怪异盒模型)"></a>IE盒子模型(怪异盒模型)</h4><p><img src="http://cdn.flqin.com/p336-20.jpg" alt="IE盒子模型"></p><p><code>padding</code>和<code>border</code>被包含在定义的<code>width</code>和<code>height</code>之内。对象的实际宽度就等于设置的<code>width</code>值，即使定义有<code>border</code>和<code>padding</code>也不会改变对象的实际宽度，即 <code>Element width = width</code></p><h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><p><code>box-sizing</code> 用于指定盒子模型种类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span>; <span class="comment">/*默认值，对应标准盒子模型  */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>; <span class="comment">/* 对应IE盒子模型 */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">inherit</span>; <span class="comment">/* 规定应从父元素继承 box-sizing 属性 */</span></span><br></pre></td></tr></table></figure><h3 id="BFC-amp-IFC"><a href="#BFC-amp-IFC" class="headerlink" title="BFC &amp; IFC"></a>BFC &amp; IFC</h3><p>篇幅太长，详情跳转此处<a href="https://blog.flqin.com/224.html">BFC等Formatting Contexts浅析</a></p><h2 id="JS引擎解析过程"><a href="#JS引擎解析过程" class="headerlink" title="JS引擎解析过程"></a>JS引擎解析过程</h2><p>前面有提到遇到JS脚本时，会等到它的执行，实际上是需要引擎解析的，这里展开描述（介绍主干流程）</p><h3 id="JS的解释阶段"><a href="#JS的解释阶段" class="headerlink" title="JS的解释阶段"></a>JS的解释阶段</h3><p>首先得明确： <strong>JS是解释型语言，所以它无需提前编译，而是由解释器实时运行</strong></p><p>引擎对JS的处理过程可以简述如下：</p><ol><li>读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）</li><li>对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）</li><li>使用翻译器（translator），将代码转为字节码（bytecode）</li><li>使用字节码解释器（bytecode interpreter），将字节码转为机器码</li></ol><p>最终计算机执行的就是<code>机器码</code>。</p><p>为了提高运行速度，现代浏览器一般采用即时编译（JIT-Just In Time compiler），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache），这样整个程序的运行速度能得到显著提升。而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8）</p><p>总结起来可以认为是： <strong>核心的<code>JIT</code>编译器将源码编译成机器码运行。</strong></p><h3 id="JS的预处理阶段"><a href="#JS的预处理阶段" class="headerlink" title="JS的预处理阶段"></a>JS的预处理阶段</h3><p>上述将的是解释器的整体过程，这里再提下在正式执行JS前，还会有一个<code>预处理阶段</code> （譬如变量提升，分号补全等）</p><p><code>预处理阶段</code>会做一些事情，确保JS可以正确执行，这里仅提部分：</p><h4 id="分号补全"><a href="#分号补全" class="headerlink" title="分号补全"></a>分号补全</h4><p>JS执行是需要分号的，但为什么以下语句却可以正常运行呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure><p>原因就是JS解释器有一个<code>Semicolon Insertion</code>规则，它会按照一定规则，在适当的位置补充分号</p><p>譬如列举几条自动加分号的规则：</p><ul><li>当有换行符（包括含有换行符的多行注释），并且下一个token没法跟前面的语法匹配时，会自动补分号。</li><li>当有}时，如果缺少分号，会补分号。</li><li>程序源代码结束时，如果缺少分号，会补分号。</li></ul><p>于是，上述的代码就变成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br></pre></td></tr></table></figure><p>所以可以正常运行。</p><p>当然了，这里有一个经典的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#123;</span><br><span class="line">        a: <span class="string">'a'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于分号补全机制，所以它变成了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        a: <span class="string">'a'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以运行后是<code>undefined</code></p><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>一般包括<code>函数提升</code>和<code>变量提升</code></p><p>譬如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure><p>经过变量提升后，就变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure><p>这里没有展开，其实展开也可以牵涉到很多内容的，譬如可以提下变量声明，<a href="https://goddyzhao.tumblr.com/post/11273713920/functions" target="_blank" rel="noopener">函数声明</a>，形参，实参的优先级顺序，以及es6中let有关的<a href="https://blog.flqin.com/349.html">临时死区</a>等.</p><h3 id="JS的执行阶段"><a href="#JS的执行阶段" class="headerlink" title="JS的执行阶段"></a>JS的执行阶段</h3><p>相关概念中文文档<a href="https://goddyzhao.tumblr.com/JavaScript-Internal" target="_blank" rel="noopener">翻译查阅</a></p><p>解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：</p><ul><li>执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）</li><li>VO（变量对象）和AO（活动对象）</li><li>作用域链</li><li>this机制等</li></ul><p>这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性</p><h4 id="执行上下文简单解释"><a href="#执行上下文简单解释" class="headerlink" title="执行上下文简单解释"></a>执行上下文简单解释</h4><ul><li>JS有<code>执行上下文</code></li><li>浏览器首次载入脚本，它将创建<code>全局执行上下文</code>，并压入<code>执行栈</code>栈顶（不可被弹出）</li><li>然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的<code>顶部</code></li><li>一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈</li><li>这样依次执行（最终都会回到全局执行上下文）</li></ul><p>譬如，如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收</p><p><img src="http://cdn.flqin.com/p336-15.png" alt="执行上下文"></p><p>然后执行上下文与VO，作用域链，this的关系是：</p><p>每一个执行上下文，都有三个重要属性：</p><ul><li>变量对象(<code>Variable object</code>-<code>VO</code>)</li><li>作用域链(<code>Scope chain</code>)</li><li><code>this</code></li></ul><p><img src="http://cdn.flqin.com/p336-21.png" alt="execution context"></p><h4 id="VO与AO"><a href="#VO与AO" class="headerlink" title="VO与AO"></a>VO与AO</h4><p><code>VO</code>是执行上下文的属性（抽象概念），但是<strong>只有全局上下文的变量对象允许通过<code>VO</code>的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）</strong></p><p><code>AO（activation object)</code> 活动对象，当函数被调用者激活，<code>AO</code>就被创建了</p><p>可以理解为：</p><ul><li>在函数上下文中：<code>VO === AO</code></li><li>在全局上下文中：<code>VO === this === global</code></li></ul><p>总的来说，<code>VO</code>中会存放一些变量信息（如声明的变量，函数，arguments参数等等）</p><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>它是执行上下文中的一个属性，原理和原型链很相似，作用很重要。</p><p>譬如流程简述：</p><ul><li>在函数上下文中，查找一个变量<code>foo</code></li><li>如果函数的<code>VO</code>中找到了，就直接使用</li><li>否则去它的父级作用域链中（<strong>parent</strong>）找</li><li>如果父级中没找到，继续往上找</li><li>直到全局上下文中也没找到就报错</li></ul><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><p>这也是JS的核心知识之一，由于内容过多，这里就不展开，仅提及部分,更多<a href="https://blog.flqin.com/240.html">this介绍查询</a></p><p>注意：<strong>this是执行上下文环境的一个属性，而不是某个变量对象的属性</strong></p><p>因此:</p><ul><li><code>this</code>是没有一个类似搜寻变量的过程</li><li>当代码中使用了<code>this</code>，这个 <code>this</code>的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻</li><li><code>this</code>的值只取决中进入上下文时的情况</li></ul><p>所以经典的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baz = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">    baz: <span class="number">100</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.baz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = bar.foo;</span><br><span class="line"><span class="comment">// 进入环境：global</span></span><br><span class="line">foo(); <span class="comment">// 200，严格模式中会报错，Cannot read property 'baz' of undefined</span></span><br><span class="line"><span class="comment">// 进入环境：global bar</span></span><br><span class="line">bar.foo(); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>就要明白了上面<code>this</code>的介绍，上述例子很好理解.</p><h3 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h3><p>JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。</p><p>一般来说，垃圾处理器有自己的回收策略。譬如对于那些执行完毕的函数，如果没有<code>外部引用</code>（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）</p><p>常用的两种垃圾回收规则是：</p><ul><li>标记清除</li><li>引用计数</li></ul><p><code>Javascript</code>引擎基础<code>GC</code>方案是（simple GC）：<code>mark and sweep（标记清除）</code>，简单解释如下：</p><ul><li>遍历所有可访问的对象。</li><li>回收已不可访问的对象。</li></ul><p>譬如：（出自javascript高程）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。</span><br><span class="line">从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。</span><br><span class="line">而当变量离开环境时，则将其标记为“离开环境”。</span><br><span class="line">垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。</span><br><span class="line">然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。</span><br><span class="line">而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。</span><br><span class="line">最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</span><br></pre></td></tr></table></figure><p>关于引用计数，简单点理解：<strong>跟踪记录每个值被引用的次数，当一个值被引用时，次数+1，减持时-1，下次垃圾回收器会回收次数为0的值的内存（当然了，容易出循环引用的bug）</strong></p><h4 id="GC的缺陷"><a href="#GC的缺陷" class="headerlink" title="GC的缺陷"></a>GC的缺陷</h4><p>和其他语言一样，javascript的<code>GC策略</code>也无法避免一个问题： <strong>GC时，停止响应其他操作</strong>，这是为了安全考虑。而Javascript的<code>GC</code>在100ms甚至以上。</p><p>对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是引擎需要优化的点： <strong>避免GC造成的长时间停止响应。</strong></p><h4 id="GC优化策略"><a href="#GC优化策略" class="headerlink" title="GC优化策略"></a>GC优化策略</h4><p>这里介绍常用到的：<strong>分代回收（Generation GC）</strong></p><p>目的是通过区分“临时”与“持久”对象:</p><ul><li>多回收“临时对象”区（<code>young generation</code>）</li><li>少回收“持久对象”区（<code>tenured generation</code>）</li><li>减少每次需遍历的对象，从而减少每次GC的耗时。</li></ul><p>像node v8引擎就是采用的分代回收。</p><p>更多JavaScript垃圾回收<a href="https://blog.flqin.com/259.html">查阅</a></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="可以提到跨域"><a href="#可以提到跨域" class="headerlink" title="可以提到跨域"></a>可以提到跨域</h3><p>譬如发出网络请求时，会用AJAX，如果接口跨域，就会遇到跨域问题</p><p>可以参考：</p><p><a href="https://segmentfault.com/a/1190000012469713" target="_blank" rel="noopener">ajax跨域，这应该是最全的解决方案了</a></p><h3 id="可以提到web安全"><a href="#可以提到web安全" class="headerlink" title="可以提到web安全"></a>可以提到web安全</h3><p>譬如浏览器在解析HTML时，有XSSAuditor，可以延伸到web安全相关领域</p><p>可以参考：</p><p><a href="https://segmentfault.com/a/1190000012693772" target="_blank" rel="noopener">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系。</a></p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><ul><li>如可以提到viewport概念，讲讲物理像素，逻辑像素，CSS像素等概念<a href="https://blog.flqin.com/218.html">查阅</a></li><li>如熟悉Hybrid开发的话可以提及一下Hybrid相关内容以及优化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解“连等赋值”问题</title>
      <link href="/333.html"/>
      <url>/333.html</url>
      
        <content type="html"><![CDATA[<p>有这样一个热门问题：</p><pre><code>var a = {n: 1};var b = a;a.x = a = {n: 2};alert(a.x); // --&gt; undefinedalert(b.x); // --&gt; {n: 2}</code></pre><p>其实这个问题很好理解，关键要弄清下面两个知识点：</p><ul><li>JS引擎对赋值表达式的处理过程</li><li>赋值运算的右结合性</li></ul><h3 id="一-赋值表达式"><a href="#一-赋值表达式" class="headerlink" title="一. 赋值表达式"></a>一. 赋值表达式</h3><p>形如</p><pre><code>A = B</code></pre><p>的表达式称为<strong>赋值表达式</strong>。其中A和B又分别可以是表达式。B可以是任意表达式，但是A必须是一个<strong>左值</strong>。</p><p>所谓左值，就是可以被赋值的表达式，在ES规范中是用内部类型引用(Reference)描述的。例如：</p><ul><li>表达式foo.bar可以作为一个左值，表示对foo这个对象中bar这个名称的引用；</li><li>变量email可以作为一个左值，表示对当前执行环境中的环境记录项envRec中email这个名称的引用</li><li>同样地，函数名func可以做左值，然而函数调用表达式func(a, b)不可以。</li></ul><p>那么JS引擎是怎样计算一般的赋值表达式 A = B的呢？简单地说，按如下步骤：</p><ul><li>1.计算表达式A，得到一个引用refA；</li><li>2.计算表达式B，得到一个值valueB；</li><li>3.将valueB赋给refA指向的名称绑定；</li><li>4.返回valueB。</li></ul><h3 id="二-结合性"><a href="#二-结合性" class="headerlink" title="二. 结合性"></a>二. 结合性</h3><p>所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。 赋值表达式是右结合的。这意味着：</p><pre><code>A1 = A2 = A3 = A4</code></pre><p>等价于</p><pre><code>A1 = (A2 = (A3 = A4))</code></pre><h3 id="三-连等的解析"><a href="#三-连等的解析" class="headerlink" title="三. 连等的解析"></a>三. 连等的解析</h3><p>好了，有了上面两部分的知识。下面来看一下JS引擎是怎样运算连等赋值表达式的。</p><p>以下面的式子为例：</p><pre><code>Exp1 = Exp2 = Exp3 = Exp4</code></pre><p>首先根据右结合性，可以转换成</p><pre><code>Exp1 = (Exp2 = (Exp3 = Exp4))</code></pre><p>然后，我们已经知道对于单个赋值运算，JS引擎总是先计算左边的操作数，再计算右边的操作数。所以接下来的步骤就是：</p><ul><li>1.计算Exp1，得到Ref1；</li><li>2.计算Exp2，得到Ref2；</li><li>3.计算Exp3，得到Ref3；</li><li>4.计算Exp4，得到Value4。</li></ul><p>现在变成了这样的：</p><pre><code>Ref1 = (Ref2 = (Ref3 = Value4))</code></pre><p>接下来的步骤是：</p><ul><li>1.将Value4赋给Exp3；</li><li>2.将Value4赋给Exp2；</li><li>3.将Value4赋给Exp1；</li><li>4.返回表达式最终的结果Value4。</li></ul><p>注意：这几个步骤体现了右结合性。</p><p>总结一下就是：</p><blockquote><p>先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用。</p></blockquote><h3 id="四-问题的解决"><a href="#四-问题的解决" class="headerlink" title="四. 问题的解决"></a>四. 问题的解决</h3><p>现在回到文章开头的问题。</p><p>首先前两个var语句执行完后，a和b都指向同一个对象{n: 1}(为方便描述，下面称为对象N1)。然后来看</p><pre><code>a.x = a = {n: 2};</code></pre><p>根据前面的知识，首先依次计算表达式a.x和a，得到两个引用。其中a.x表示对象N1中的x，而a相当于envRec.a，即当前环境记录项中的a。所以此时可以写出如下的形式：</p><pre><code>[[N1]].x = [[encRec]].a = {n: 2};</code></pre><p>其中，[[]]表示引用指向的对象。</p><p>接下来，将{n: 2}赋值给[[encRec]].a，即将{n: 2}绑定到当前上下文中的名称a。</p><p>接下来，将同一个{n: 2}赋值给[[N1]].x，即将{n: 2}绑定到N1中的名称x。</p><p>由于b仍然指向N1，所以此时有</p><pre><code>b &lt;=&gt; N1 &lt;=&gt; {n: 1, x: {n: 2}}</code></pre><p>而a被重新赋值了，所以</p><pre><code>a &lt;=&gt; {n: 2}</code></pre><p>并且</p><pre><code>a === b.x</code></pre><h3 id="五-最后的最后"><a href="#五-最后的最后" class="headerlink" title="五. 最后的最后"></a>五. 最后的最后</h3><p>如果你明白了上面所有的内容，应该会明白a.x = a = {n:2};与b.x = a = {n:2};是完全等价的。因为在解析a.x或b.x的那个时间点。a和b这两个名称指向同一个对象，就像C++中同一个对象可以有多个引用一样。而在这个时间点之后，不论是a.x还是b.x，其实早就不存在了，它已经变成了那个内存中的对象.x了。</p><p>最后用一张图表示整个表达式的运算过程：</p><p><img src="http://cdn.flqin.com/p333-1.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端冷知识集锦</title>
      <link href="/331.html"/>
      <url>/331.html</url>
      
        <content type="html"><![CDATA[<p>前端已经被玩儿坏了！像console.log()可以向控制台输出图片等炫酷的玩意已经不是什么新闻了，像用||操作符给变量赋默认值也是人尽皆知的旧闻了，今天看到Quora上一个帖子，瞬间又GET了好多前端技能，一些属于技巧，一些则是闻所未闻的冷知识，一时间还消化不过来。现分类整理出来分享给大家，也补充了一些平时的积累和扩展了一些内容。</p><h2 id="HTML篇"><a href="#HTML篇" class="headerlink" title="HTML篇"></a>HTML篇</h2><h3 id="浏览器地址栏运行JavaScript代码"><a href="#浏览器地址栏运行JavaScript代码" class="headerlink" title="浏览器地址栏运行JavaScript代码"></a>浏览器地址栏运行JavaScript代码</h3><p>这个很多人应该还是知道的，在浏览器地址栏可以直接运行JavaScript代码，做法是以 javascript: 开头后跟要执行的语句。比如：</p><pre><code>javascript:alert(&apos;hello from address bar :)&apos;);</code></pre><p>将以上代码贴到浏览器地址栏回车后alert正常执行，一个弹窗神现。</p><p>需要注意的是如果是通过copy paste代码到浏览器地址栏的话，IE及Chrome会自动去掉代码开头的javascript:，所以需要手动添加起来才能正确执行，而Firefox中虽然不会自动去掉，但它根本就不支持在地址栏运行JS代码，sigh~</p><h3 id="浏览器地址栏运行HTML代码"><a href="#浏览器地址栏运行HTML代码" class="headerlink" title="浏览器地址栏运行HTML代码"></a>浏览器地址栏运行HTML代码</h3><p>如果说上面那条小秘密知道的人还算多的话，这条秘笈知道的人就要少一些了，在非IE内核的浏览器地址栏可以直接运行HTML代码！</p><p>比如在地址栏输入以下代码然后回车运行，会出现指定的页面内容。</p><pre><code>data:text/html,&lt;h1&gt;Hello, world!&lt;/h1&gt;</code></pre><h3 id="可以把浏览器当编辑器"><a href="#可以把浏览器当编辑器" class="headerlink" title="可以把浏览器当编辑器"></a>可以把浏览器当编辑器</h3><p>还是浏览器地址栏上做文章，将以下代码贴到地址栏运行后浏览器变成了一个原始而简单的编辑器，与Windows自带的notepad一样，吼吼。</p><pre><code>data:text/html, &lt;html contenteditable&gt;</code></pre><p>归根结底多亏了HTML5中新加的 contenteditable 属性，当元素指定了该属性后，元素的内容成为可编辑状态。</p><p>推而广之，将以下代码放到console执行后，整个页面将变得可编辑，随意践踏吧~</p><pre><code>document.body.contentEditable=&apos;true&apos;;</code></pre><h3 id="利用a标签自动解析URL"><a href="#利用a标签自动解析URL" class="headerlink" title="利用a标签自动解析URL"></a>利用a标签自动解析URL</h3><p>很多时候我们有从一个URL中提取域名，查询关键字，变量参数值等的需要，而万万没想到可以让浏览器方便地帮我们完成这一任务而不用我们写正则去抓取。方法就在JS代码里先创建一个 a 标签然后将需要解析的URL赋值给 a 的 href 属性，然后就得到了一切我们想要的了。</p><pre><code>var a = document.createElement(&apos;a&apos;);a.href = &apos;http://www.cnblogs.com/wayou/p/&apos;;console.log(a.host);</code></pre><h3 id="页面拥有ID的元素会创建全局变量"><a href="#页面拥有ID的元素会创建全局变量" class="headerlink" title="页面拥有ID的元素会创建全局变量"></a>页面拥有ID的元素会创建全局变量</h3><p>在一张HTML页面中，所有设置了ID属性的元素会在JavaScript的执行环境中创建对应的全局变量，这意味着 document.getElementById 像人的阑尾一样显得多余了。但实际项目中最好老老实实该怎么写就怎么写，毕竟常规代码出乱子的机会要小得多。</p><pre><code>&lt;div id=&quot;sample&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; console.log(sample);&lt;/script&gt;</code></pre><h3 id="加载CDN文件时，可以省掉HTTP标识"><a href="#加载CDN文件时，可以省掉HTTP标识" class="headerlink" title="加载CDN文件时，可以省掉HTTP标识"></a>加载CDN文件时，可以省掉HTTP标识</h3><p>现在很流行的CDN即从专门的服务器加载一些通用的JS和CSS文件，出于安全考虑有的CDN服务器使用HTTPS方式连接，而有的是传统的HTTP，其实我们在使用时可以忽略掉这个，将它从URL中省去。</p><pre><code>&lt;script src=&quot;//domain.com/path/to/script.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="利用script标签保存任意信息"><a href="#利用script标签保存任意信息" class="headerlink" title="利用script标签保存任意信息"></a>利用script标签保存任意信息</h3><p>将script标签设置为 type=’text’ 然后可以在里面保存任意信息，之后可以在JavaScript代码中很方便地获取。</p><pre><code>&lt;script type=&quot;text&quot; id=&quot;template&quot;&gt;&lt;h1&gt;This won&apos;t display&lt;/h1&gt;&lt;/script&gt;var text = document.getElementById(&apos;template&apos;).innerHTML</code></pre><h2 id="CSS篇"><a href="#CSS篇" class="headerlink" title="CSS篇"></a>CSS篇</h2><h3 id="关于CSS的恶作剧"><a href="#关于CSS的恶作剧" class="headerlink" title="关于CSS的恶作剧"></a>关于CSS的恶作剧</h3><p>相信你看完以下代码后能够预料到会出现什么效果。</p><pre><code>*{ cursor: none!important;}</code></pre><h3 id="简单的文字模糊效果"><a href="#简单的文字模糊效果" class="headerlink" title="简单的文字模糊效果"></a>简单的文字模糊效果</h3><p>以下两行简单的CSS3代码可达到将文字模糊化处理的目的，出来的效果有点像使用PS的滤镜，so cool!</p><pre><code>p { color: transparent; text-shadow: #111 0 0 5px;}</code></pre><h3 id="多重边框"><a href="#多重边框" class="headerlink" title="多重边框"></a>多重边框</h3><p>利用重复指定box-shadow来达到多个边框的效果</p><pre><code>/*CSS Border with Box-Shadow Example*/div { box-shadow: 0 0 0 6px rgba(0, 0, 0, 0.2), 0 0 0 12px rgba(0, 0, 0, 0.2), 0 0 0 18px rgba(0, 0, 0, 0.2), 0 0 0 24px rgba(0, 0, 0, 0.2); height: 200px; margin: 50px auto; width: 400px;}</code></pre><h3 id="实时编辑CSS"><a href="#实时编辑CSS" class="headerlink" title="实时编辑CSS"></a>实时编辑CSS</h3><p>通过设置style标签的 display:block 样式可以让页面的style标签显示出来，并且加上 contentEditable 属性后可以让样式成为可编辑状态，更改后的样式效果也是实时更新呈现的。此技巧在IE下无效。拥有此技能者，逆天也！</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt;    &lt;style style=&quot;display:block&quot; contentEditable&gt;      body { color: blue }    &lt;/style&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="创建长宽比固定的元素"><a href="#创建长宽比固定的元素" class="headerlink" title="创建长宽比固定的元素"></a>创建长宽比固定的元素</h3><p>通过设置父级窗口的 padding-bottom 可以达到让容器保持一定的长度比的目的，这在响应式页面设计中比较有用，能够保持元素不变形。</p><pre><code>&lt;div style=&quot;width: 100%; position: relative; padding-bottom: 20%;&quot;&gt; &lt;div style=&quot;position: absolute; left: 0; top: 0; right: 0; bottom: 0;background-color:yellow;&quot;&gt;     this content will have a constant aspect ratio that varies based on the width. &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="CSS中也可以做简单运算"><a href="#CSS中也可以做简单运算" class="headerlink" title="CSS中也可以做简单运算"></a>CSS中也可以做简单运算</h3><p>通过CSS中的calc方法可以进行一些简单的运算，从而达到动态指定元素样式的目的。</p><pre><code>.container{ background-position: calc(100% - 50px) calc(100% - 20px);}</code></pre><h2 id="JavaScript篇"><a href="#JavaScript篇" class="headerlink" title="JavaScript篇"></a>JavaScript篇</h2><h3 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h3><p>利用 Math.random 和 toString 生成随机字符串，来自前一阵子看到的一篇博文。这里的技巧是利用了 toString 方法可以接收一个基数作为参数的原理，这个基数从2到36封顶。如果不指定，默认基数是10进制。略屌！</p><pre><code>function generateRandomAlphaNum(len) { var rdmString = &quot;&quot;; for (; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2)); return rdmString.substr(0, len);}</code></pre><h3 id="整数的操作"><a href="#整数的操作" class="headerlink" title="整数的操作"></a>整数的操作</h3><p>JavaScript中是没有整型概念的，但利用好位操作符可以轻松处理，同时获得效率上的提升。</p><p>|0 和 ~~ 是很好的一个例子，使用这两者可以将浮点转成整型且效率方面要比同类的 parseInt , Math.round 要快。在处理像素及动画位移等效果的时候会很有用。性能比较见此。</p><pre><code>var foo = (12.4 / 4.13) | 0;//结果为3var bar = ~~(12.4 / 4.13);//结果为3</code></pre><p>顺便说句， !! 将一个值方便快速转化为布尔值 !!window===true 。</p><h3 id="重写原生浏览器方法以实现新功能"><a href="#重写原生浏览器方法以实现新功能" class="headerlink" title="重写原生浏览器方法以实现新功能"></a>重写原生浏览器方法以实现新功能</h3><p>下载的代码通过重写浏览器的 alert 让它可以记录弹窗的次数。</p><pre><code>(function() { var oldAlert = window.alert,      count = 0; window.alert = function(a) {     count++;     oldAlert(a + &quot;\n You&apos;ve called alert &quot; + count + &quot; times now. Stop, it&apos;s evil!&quot;); };})();alert(&quot;Hello World&quot;);</code></pre><h3 id="关于console的恶作剧"><a href="#关于console的恶作剧" class="headerlink" title="关于console的恶作剧"></a>关于console的恶作剧</h3><p>关于重写原生方法，这里有个恶作剧大家可以拿去寻开心。Chrome的 console.log 是支持对文字添加样式的，甚至log图片都可以。于是可以重写掉默认的log方法，把将要log的文字应用到CSS的模糊效果，这样当有人试图调用console.log()的时候，出来的是模糊不清的文字。好冷，我表示没有笑。</p><p>是从这篇G+帖子的评论里看到的。使用之后的效果是再次调用log会输出字迹模糊不清的文字。</p><pre><code>var _log = console.log;console.log = function() { _log.call(console, &apos;%c&apos; + [].slice.call(arguments).join(&apos; &apos;), &apos;color:transparent;text-shadow:0 0 2px rgba(0,0,0,.5);&apos;);};</code></pre><h3 id="不声明第三个变量的值交换"><a href="#不声明第三个变量的值交换" class="headerlink" title="不声明第三个变量的值交换"></a>不声明第三个变量的值交换</h3><p>我们都知道交换两个变量值的常规做法，那就是声明一个中间变量来暂存。但鲜有人去挑战不声明中间变量的情况，下面的代码给出了这种实现。蛮有创意 的。</p><pre><code>var a=1,b=2;a=[b,b=a][0];</code></pre><h3 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h3><p>在JavaScript的世界，万物皆对象。除了 null 和 undefined ，其他基本类型数字，字符串和布尔值都有对应有包装对象。对象的一个特征是你可以在它身上直接调用方法。对于数字基本类型，当试图在其身上调用 toString 方法会失败，但用括号括起来后再调用就不会失败了，内部实现是用相应的包装对象将基本类型转为对象。所以 (1).toString() 相当于 new Number(1).toString() 。因此，你的确可以把基本类型数字，字符串，布尔等当对象使用的，只是注意语法要得体。</p><p>同时我们注意到，JavaScript中数字是不分浮点和整形的，所有数字其实均是浮点类型，只是把小数点省略了而以，比如你看到的1可以写成1.，这也就是为什么当你试图1.toString()时会报错，所以正确的写法应该是这样：1..toString()，或者如上面所述加上括号，这里括号的作用是纠正JS解析器，不要把1后面的点当成小数点。内部实现如上面所述，是将1.用包装对象转成对象再调用方法。</p><h3 id="If语句的变形"><a href="#If语句的变形" class="headerlink" title="If语句的变形"></a>If语句的变形</h3><p>当你需要写一个if语句的时候，不妨尝试另一种更简便的方法，用JavaScript中的逻辑操作符来代替。</p><pre><code>var day=(new Date).getDay()===0;//传统if语句if (day) { alert(&apos;Today is Sunday!&apos;);};//运用逻辑与代替ifday&amp;&amp;alert(&apos;Today is Sunday!&apos;);</code></pre><p>比如上面的代码，首先得到今天的日期，如果是星期天，则弹窗，否则什么也不做。我们知道逻辑操作存在短路的情况，对于逻辑与表达式，只有两者都真才结果才为真，如果前面的day变量被判断为假了，那么对于整个与表达式来说结果就是假，所以就不会继续去执行后面的 alert 了，如果前面day为真，则还要继续执行后面的代码来确定整个表达式的真假。利用这点达到了if的效果。</p><p>对于传统的if语句，如果执行体代码超过了1 条语句，则需要加花括号，而利用逗号表达式，可以执行任意条代码而不用加花括号。</p><pre><code>if(conditoin) alert(1),alert(2),console.log(3);</code></pre><p>上面if语句中，如果条件成立则执行三个操作，但我们不需要用花括号将这三句代码括起来。当然，这是不推荐的，这里是冷知识课堂:)</p><h3 id="禁止别人以iframe加载你的页面"><a href="#禁止别人以iframe加载你的页面" class="headerlink" title="禁止别人以iframe加载你的页面"></a>禁止别人以iframe加载你的页面</h3><p>下面的代码已经不言自明了，没什么好多说的。</p><pre><code>if (window.location != window.parent.location) window.parent.location = window.location;</code></pre>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数节流（throttle）与函数去抖（debounce）</title>
      <link href="/325.html"/>
      <url>/325.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>以下场景往往由于事件频繁被触发，因而频繁执行 DOM 操作、资源加载等重行为，导致 UI 停顿甚至浏览器崩溃。</p><ul><li>window 对象的 resize、scroll 事件</li><li>拖拽时的 mousemove 事件</li><li>射击游戏中的 mousedown、keydown 事件</li><li>文字输入、自动完成的 keyup 事件</li></ul><p>实际上对于 window 的 resize 事件，实际需求大多为停止改变大小 n 毫秒后执行后续处理；而其他事件大多的需求是以一定的频率执行后续处理。针对这两种需求就出现了 debounce 和 throttle 两种解决办法。</p><h3 id="二、什么是-debounce"><a href="#二、什么是-debounce" class="headerlink" title="二、什么是 debounce"></a>二、什么是 debounce</h3><p><strong>1. 定义</strong></p><p>如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。</p><p>也就是说当调用动作 n 毫秒后，才会执行该动作，若在这 n 毫秒内又调用此动作则将重新计算执行时间。</p><pre><code>/*** 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 idle，action 才会执行* @param idle   {number}    空闲时间，单位毫秒* @param action {function}  请求关联函数，实际应用需要调用的函数* @return {function}    返回客户调用函数*/debounce(idle,action)</code></pre><p><strong>2. 简单实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">idle, action</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> last</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> ctx = <span class="keyword">this</span>, args = <span class="built_in">arguments</span></span><br><span class="line">clearTimeout(last)</span><br><span class="line">last = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">action.apply(ctx, args)</span><br><span class="line">&#125;, idle)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、什么是-throttle"><a href="#三、什么是-throttle" class="headerlink" title="三、什么是 throttle"></a>三、什么是 throttle</h3><p><strong>1. 定义</strong></p><p>如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。</p><p>也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p><pre><code>/*** 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay* @param delay  {number}    延迟时间，单位毫秒* @param action {function}  请求关联函数，实际应用需要调用的函数* @return {function}    返回客户调用函数*/throttle(delay,action)</code></pre><p><strong>2. 简单实现</strong></p><pre><code>var throttle = function(delay, action){  var last = 0return function(){    var curr = +new Date()    if (curr - last &gt; delay){      action.apply(this, arguments)      last = curr    }  }}</code></pre><p><strong>underscore 里有该实现，可以多多参考一下。</strong></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript闭包概念及用法梳理</title>
      <link href="/317.html"/>
      <url>/317.html</url>
      
        <content type="html"><![CDATA[<h3 id="函数内部的函数：私有函数"><a href="#函数内部的函数：私有函数" class="headerlink" title="函数内部的函数：私有函数"></a>函数内部的函数：私有函数</h3><p>首先，我们从这个内部函数去说开，因为这个是形式上的，如果一开始讲作用域，有点故意。闭包在形式上就是函数内部的函数，比如：</p><pre><code>function add(a) {  return function(b) {    return a + b;  }}var c = add(5)(10);</code></pre><p>这是一个很奇怪的用法，第一次看到有function()()这样的用法？请阅读这篇文章。当执行add(5)的时候，返回的结果其实是一个函数，而再执行这个函数，需要再传入一个参数，所以就有了add(5)(10)这样的用法。当然，这是一个极端的例子，出现的太早，我们来看下最常见的一种用法吧。</p><pre><code>jQuery(function($){  function message(msg) {    alert(msg);  }  if($(window).width() &gt; 1000) message(&apos;window宽度大于1000&apos;);});</code></pre><p>如果你用jquery，这段代码应该经常使用吧。如果你仔细去观察，就会发现，第一个function被作为参数，传给了jQuery()这个函数，而在function内，又有一个message()函数。所有的jQuery代码被放在第一个function中去处理。第二个函数就是函数体内部的函数，这个函数在函数体内声明，一旦外层函数执行完毕，那么这个函数就失去了作用，在jQuery()外无法使用message()，因此，message()是第一个函数内部的私有函数。</p><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>函数内部的变量有两种，一种是局部变量，一种是全局变量。局部变量只在当前函数体内有效，出了函数体，就回到全局变量的范围，局部变量无效。</p><pre><code>var age = 10;function a(age) {  return age + 1;}function b(_age) {  return age + _age;}function c(_age) {  var age = 11;  function add() {    return age + _age;  }  return add();}alert(a(9)); // 10 : 9 + 1alert(b(2)); // 12 : 10 + 2alert(c(5)); // 16 : 11 + 5</code></pre><p>在上面的代码中，我们看b和c函数。b函数中的age直接引用了全局变量age（10），而c函数中重新声明了局部变量age，因此，全局变量age在c函数中无效。</p><p>但是在c中，函数内部有一个函数add()，它的函数体内的age是指c中声明的局部变量，而非全局变量age。从这个例子里，反映出了变量的作用域，函数内的函数体里，如果没有声明局部变量，就会承认其父级甚至祖先级函数的变量，以及全局变量。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>怎么样才算是一个闭包呢？我们来看下面的代码：</p><pre><code>function a() {  var age = 10;  return function() {    return age;  }}var age = a();alert(age()); // 10</code></pre><p>按照我们前面说的作用域，在上面这段代码中age是a()的局部变量，按道理，出了函数，就不能被访问了。但是，a()返回了一个私有函数，个这个函数返回了age，这导致我们可以在a()外部，仍然可以访问到本来是局部变量的age，这个时候，我们就把这个内部函数称为闭包。它的原理就是，函数内部的函数，可以访问父函数的局部变量。</p><p>综合上面的阐述，我们要这样去理解闭包：</p><ul><li>闭包是一个函数，它使用了自己之外的变量。</li><li>闭包是一个作用域。</li><li>闭包是“由函数和与其相关的引用环境组合而成的实体”。</li><li>严格的讲，闭包常常表现为一个函数内部的函数，它使用了非自己定义的、自己所在作用域内的变量，并且使这些变量突破了作用域的限制。</li></ul><p>所以，我们文章最开头的那段代码，也有一个闭包。</p><p>一个典型的闭包：</p><ul><li><p>函数内的函数</p></li><li><p>这个内部函数引用了父函数的局部变量</p></li><li><p>这个内部函数使引用的变量突破了作用域限制</p><p>var a = 1;<br>function fun() {<br>   return a + 1;<br>}alert(fun());</p></li></ul><p>这也可以算作一个闭包，a()引用了它之外定义的变量。但是这不算严格的闭包，因为它没有在突破作用域的这个点上表现出来。</p><pre><code>var a = 1;function fun() {  var b = 2;  return function() {    return a + ++b;  };}var c = fun();alert(c()); // 4alert(c()); // 5</code></pre><p>这就是一个非常典型的闭包了。而且为什么alert(c())两次的值不同，我们还会在下面解释到。</p><p>为了让你更加明晰的和你曾经开发过的案例联系在一起，我们来看我们曾经做过的这样的事：</p><pre><code>define(function() {  var age = 10;  function getAge() {    return age;  }  function grow() {    age ++;  }  return {    age : getAge,    grow : grow  };});</code></pre><p>这是我们在require.js中的一种写法，把它还原为我们熟悉的闭包模式：</p><pre><code>function Cat() {  var age = 10;  function getAge() {    return age;  }  function grow() {    age ++;  }  return {    ageAge : getAge,    grow : grow  };};var cat = Cat();var age = cat.getAge();alert(age); // 10cat.grow();age = cat.getAge();alert(age); // 11</code></pre><h3 id="从内存看闭包"><a href="#从内存看闭包" class="headerlink" title="从内存看闭包"></a>从内存看闭包</h3><p>现在，我们就要来解释为什么上面的alert()两次的结果不同的原因了。</p><p>首先，我们来看下普通的函数声明和使用过程中内存的变化：</p><pre><code>function fun(a,b) {  return a+b;}alert(fun(1,2));alert(fun(3,4));</code></pre><p>上面是我们没有遇到闭包的情况，内存我们这样来画（注意，我这里只是抽象的画出内存变化，而不是真实的javascript内存机制。）</p><p><img src="http://cdn.flqin.com/p317-1.png" alt></p><p>在每一次执行完fun()之后，fun()函数的执行环境被释放（回收机制）。</p><p>接下来我们来看一个闭包：</p><pre><code>function fun(a) {  return function(b){return a + b;}}var add = fun(2);alert(add(2));alert(add(4));</code></pre><p>上面就出现闭包了，注意，我们这里出现了一个add变量。</p><p><img src="http://cdn.flqin.com/p317-2.png" alt></p><p>在后两步中，实际上fun(2)部分没有任何变化，所变的，则是在内部函数所对应的内存区域中有变化。细心的你，可能会发现这里面的问题所在，当执行完add(2)之后，fun对应的内存没有被释放掉，而它的内部函数，也就是function(2)被释放掉了，在执行add(4)的时候，仅仅重新运行了内部函数。如果连fun()对应的内存出现了变化怎么办？我们来看下面的例子：</p><pre><code>function fun() {  var b = 2;  return function(a) {    return a + ++b;  };}var c = fun();alert(c(1)); // 4alert(c(1)); // 5</code></pre><p>注意，这可是个非常典型的闭包的例子，它有一个局部变量b，我们来看它的内存图。</p><p><img src="http://cdn.flqin.com/p317-3.png" alt></p><p>注意第2、3、4步中内存的变化。第2步时，我们仅仅将fun()赋给变量c，这个时候，内部函数function(a)并没有被执行，所以++b也没有被执行，b的值还是2。但是第3步开始，++b被先执行，++b的意思是先自加，再进行运算，和b++是不同的，如果是b++，虽然c(1)的最终结果还是为4，但是在c(1)执行开始时，b应该为2，执行完之后才是3。</p><p>奇妙的事情发生了，在内部函数中，++b导致了局部变量值发生了变化，b从2变成了3，而且，内存并没有被释放，fun()的执行环境没有被销毁，b还被保存在内存中。到第4步时，b的初始值是3，经过++b 之后，变成了4。</p><p>这个内存分析非常形象的把闭包概念中，关于“突破作用域限制”这个点描述的非常清楚，原本按照作用域的限制，函数的局部变量不能被外部环境访问，更不能被修改，但是闭包却使得外部环境不仅可以读取到局部变量的内容，甚至可以修改它，深入一点就是：<strong>闭包会导致闭包函数所涉及到的非自身定义的变量一直保存在内存中，包括其父函数在内的相关环境都不会被销毁。</strong></p><h3 id="闭包到底有什么用？"><a href="#闭包到底有什么用？" class="headerlink" title="闭包到底有什么用？"></a>闭包到底有什么用？</h3><p>说了这么多，那闭包到底有什么用，我们为什么要使用闭包呢？从上面的阐述中，你应该已经知道了闭包的唯一作用：突破作用域限制。那如何使用这个作用为程序服务呢？</p><p>常驻内存，意味着读取速度快（，当然，内存花销也大，导致内存溢出）。常驻内存，意味着一旦初始化以后，就可以反复使用同一个内存中的某个对象，而无需再次运行程序。而这一点，是很多插件、模块的设计思想。</p><p>最好的例子就是上文我举得那个define()的例子，后面用我们今天所了解的形式去实践之后，你就会发现原来可以把function当做一个其他语言中的class来对待，cat.getAge(), cat.grow()这样的操作是不是很符合我们在编程中的使用习惯呢？一旦一个产生之后，这个cat就一直在内存中，随时可以拿出来就用，它就是一个实例化对象。</p><p>为了更形象，我们来创建一个简单的代码块：</p><pre><code>function Animal() {    this.age = 1;    this.weight = 10;    return {        getAge: function() {            return this.age;        },        getWeight: function() {            return this.weight;        },        grow: function() {            this.age++;            this.weight = this.age * 10 * 0.8;        }    };}function Cat() {    var cat = new Animal(); // 继承    cat.grow = function() {        cat.age++;        cat.weight = cat.age * 10 * 0.6;    }    return cat;}var cat1 = new Cat();alert(cat1.getAge());cat1.grow();alert(cat1.getAge());</code></pre><p>为什么要举这个例子呢，因为我想让你想象这样一种场景，如果没有闭包怎么办？</p><p>没有闭包是这样的一种状态：函数无法访问自己父级（祖先，全局）对象的变量。比如：</p><pre><code>var a = 1;function add() {  return ++a; // 如果没有闭包机制，会undefined报错}</code></pre><p>这种情况怎么办？必须以参数的形式传入到函数中：</p><pre><code>var a = 1;function add(a) {  return ++a;}alert(add(a)); // 2</code></pre><p>如果是这样，就很麻烦了，你需要在每一个函数中传入变量。而更麻烦的是，没有了作用域的突破，例如：</p><pre><code>function Cat() {  age = 1;  function getAge(age) {    return age;  }  function grow(age) {    age ++;  }  return {    getAge : getAge,    grow : grow  }}var cat = new Cat();cat.grow();alert(cat.getAge()); // 1，没有被修改</code></pre><p>这种情况下，我们无论如何都无法使用这种办法来实现我们的目的。唯一能够实现的，就是按照下面这种方法：</p><pre><code>var cat = {  age : 1,  weight : 10,  grow : function() {    this.age ++;    this.weight += 3;  }};var cat1 = cat;alert(cat1.age);cat1.grow();alert(cat1.age);</code></pre><p>我们聪明的使用到了this关键字，但是这样一个坏处是，age, weight这些属性直接暴露给外部，我们只需要执行 cat1.age = 12; 就可以马上让cat长到12岁，而体重却没任何变化。</p><p>总结而言，闭包可以带来这么几个方面的应用优势：</p><ul><li>常驻内存，加快运行速度</li><li>封装</li></ul><h3 id="闭包使用中的注意点"><a href="#闭包使用中的注意点" class="headerlink" title="闭包使用中的注意点"></a>闭包使用中的注意点</h3><p>除了上面提到的内存开销问题外，还有一个需要被注意的地方，就是闭包所引用的外部变量，在一些特殊情况下会存在与期望值不同的误差。</p><pre><code>function init() {       var pAry = document.getElementsByTagName(&quot;p&quot;);       for( var i=0; i&lt;pAry.length; i++ ) {          pAry[i].i = i;          pAry[i].onclick = function() {             alert(this.i);          }       }}</code></pre><p>在上面这段代码中，你希望通过一个循环，来为每一个p标签绑定一个click事件，然而不幸的是，for循环中使用的闭包函数没有让你如愿以偿，在闭包函数中，i被认作pAry.length，也就是循环到最后i的最终值。为什么会这样呢？ 原来，闭包引用变量，而非直接使用变量，“引用”的意思是将指针指向变量的内容。由于这个原因，当i=0的时候，闭包里面的i确实是0，但是当随着i的值变大的时候，闭包内的i并没有保存当前值，而是继续把指针指向i的内容，当你点击某个p标签的时候，i的内容实际上是for到最后i的值。</p><p>同样，这个问题会出现在setTimeout，setInterval，$.ajax等这类操作中，你只要记住，当你绑定操作时，和执行操作时，对应的变量是否已经变化就OK了。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用 GitLab CI 进行持续集成</title>
      <link href="/312.html"/>
      <url>/312.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>从 GitLab 8.0 开始，GitLab CI 就已经集成在 GitLab 中，我们只要在项目中添加一个 .gitlab-ci.yml 文件，然后添加一个 Runner，即可进行持续集成。 而且随着 GitLab 的升级，GitLab CI 变得越来越强大，本文将介绍如何使用 GitLab CI 进行持续集成。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>在介绍 GitLab CI 之前，我们先看看一些持续集成相关的概念。</p><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>一次 Pipeline 其实相当于一次构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。 任何提交或者 Merge Request 的合并都可以触发 Pipeline，如下图所示：</p><pre><code>+------------------+           +----------------+|                  |  trigger  |                ||   Commit / MR    +----------&gt;+    Pipeline    ||                  |           |                |+------------------+           +----------------+</code></pre><h3 id="Stages"><a href="#Stages" class="headerlink" title="Stages"></a>Stages</h3><p>Stages 表示构建阶段，说白了就是上面提到的流程。 我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点：</p><ul><li><p>所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始</p></li><li><p>只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功</p></li><li><p>如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败</p></li><li><p>因此，Stages 和 Pipeline 的关系就是：</p><p>+——————————————————–+<br>|                                                        |<br>|  Pipeline                                              |<br>|                                                        |<br>|  +———–+     +————+      +————+  |<br>|  |  Stage 1  |—-&gt;|   Stage 2  |—–&gt;|   Stage 3  |  |<br>|  +———–+     +————+      +————+  |<br>|                                                        |<br>+——————————————————–+</p></li></ul><h3 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h3><p>Jobs 表示构建工作，表示某个 Stage 里面执行的工作。 我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点：</p><ul><li>相同 Stage 中的 Jobs 会并行执行</li><li>相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功</li><li>如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 失败</li></ul><p>所以，Jobs 和 Stage 的关系图就是：</p><pre><code>+------------------------------------------+|                                          ||  Stage 1                                 ||                                          ||  +---------+  +---------+  +---------+   ||  |  Job 1  |  |  Job 2  |  |  Job 3  |   ||  +---------+  +---------+  +---------+   ||                                          |+------------------------------------------+</code></pre><h2 id="GitLab-Runner"><a href="#GitLab-Runner" class="headerlink" title="GitLab Runner"></a>GitLab Runner</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>理解了上面的基本概念之后，有没有觉得少了些什么东西 —— 由谁来执行这些构建任务呢？ 答案就是 GitLab Runner 了！</p><p>想问为什么不是 GitLab CI 来运行那些构建任务？ 一般来说，构建任务都会占用很多的系统资源 (譬如编译代码)，而 GitLab CI 又是 GitLab 的一部分，如果由 GitLab CI 来运行构建任务的话，在执行构建任务的时候，GitLab 的性能会大幅下降。</p><p>GitLab CI 最大的作用是管理各个项目的构建状态，因此，运行构建任务这种浪费资源的事情就交给 GitLab Runner 来做拉！ 因为 GitLab Runner 可以安装到不同的机器上，所以在构建任务运行期间并不会影响到 GitLab 的性能~</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 GitLab Runner 太简单了，按照着 <a href="https://gitlab.com/gitlab-org/gitlab-ci-multi-runner" target="_blank" rel="noopener">官方文档</a> 的教程来就好拉！ 下面是 Debian/Ubuntu/CentOS 的安装方法，其他系统去参考官方文档：</p><pre><code># For Debian/Ubuntu$ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.deb.sh | sudo bash$ sudo apt-get install gitlab-ci-multi-runner# For CentOS$ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash$ sudo yum install gitlab-ci-multi-runner</code></pre><h3 id="注册-Runner"><a href="#注册-Runner" class="headerlink" title="注册 Runner"></a>注册 Runner</h3><p>安装好 GitLab Runner 之后，我们只要启动 Runner 然后和 CI 绑定就可以了：</p><ul><li>打开你 GitLab 中的项目页面，在项目设置中找到 runners</li><li>运行 sudo gitlab-ci-multi-runner register</li><li>输入 CI URL</li><li>输入 Token</li><li>输入 Runner 的名字</li><li>选择 Runner 的类型，简单起见还是选 Shell 吧</li><li>完成</li></ul><p>当注册好 Runner 之后，可以用 sudo gitlab-ci-multi-runner list 命令来查看各个 Runner 的状态：</p><pre><code>$ sudo gitlab-runner listListing configured runners          ConfigFile=/etc/gitlab-runner/config.tomlmy-runner                           Executor=shell Token=cd1cd7cf243afb47094677855aacd3 URL=http://mygitlab.com/ci</code></pre><h2 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a>.gitlab-ci.yml</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>配置好 Runner 之后，我们要做的事情就是在项目根目录中添加 .gitlab-ci.yml 文件了。 当我们添加了 .gitlab-ci.yml 文件后，每次提交代码或者合并 MR 都会自动运行构建任务了。</p><p>还记得 Pipeline 是怎么触发的吗？Pipeline 也是通过提交代码或者合并 MR 来触发的！ 那么 Pipeline 和 .gitlab-ci.yml 有什么关系呢？ 其实 .gitlab-ci.yml 就是在定义 Pipeline 而已拉！</p><h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p>我们先来看看 .gitlab-ci.yml 是怎么写的：</p><pre><code># 定义 stagesstages:  - build  - test# 定义 jobjob1:  stage: test  script:    - echo &quot;I am job1&quot;    - echo &quot;I am in test stage&quot;# 定义 jobjob2:  stage: build  script:    - echo &quot;I am job2&quot;    - echo &quot;I am in build stage&quot;</code></pre><p>写起来很简单吧！用 stages 关键字来定义 Pipeline 中的各个构建阶段，然后用一些非关键字来定义 jobs。 每个 job 中可以可以再用 stage 关键字来指定该 job 对应哪个 stage。 job 里面的 script 关键字是最关键的地方了，也是每个 job 中必须要包含的，它表示每个 job 要执行的命令。</p><p>回想一下我们之前提到的 Stages 和 Jobs 的关系，然后猜猜上面例子的运行结果？</p><pre><code>I am job2I am in build stageI am job1I am in test stage</code></pre><p>根据我们在 stages 中的定义，build 阶段要在 test 阶段之前运行，所以 stage:build 的 jobs 会先运行，之后才会运行 stage:test 的 jobs。</p><h3 id="常用的关键字"><a href="#常用的关键字" class="headerlink" title="常用的关键字"></a>常用的关键字</h3><p>下面介绍一些常用的关键字，想要更加详尽的内容请前往 <a href="https://docs.gitlab.com/ce/ci/yaml/README.html" target="_blank" rel="noopener">官方文档</a></p><p><strong>stages</strong> 定义 Stages，默认有三个 Stages，分别是 build, test, deploy。</p><p><strong>types</strong> stages 的别名。</p><p><strong>before_script</strong> 定义任何 Jobs 运行前都会执行的命令。</p><p><strong>after_script</strong></p><blockquote><p>要求 GitLab 8.7+ 和 GitLab Runner 1.2+</p></blockquote><p>定义任何 Jobs 运行完后都会执行的命令。</p><p><strong>variables &amp;&amp; Job.variables</strong></p><blockquote><p>要求 GitLab Runner 0.5.0+</p></blockquote><p>定义环境变量。 如果定义了 Job 级别的环境变量的话，该 Job 会优先使用 Job 级别的环境变量。 <a href="https://docs.gitlab.com/ce/ci/variables/README.html" target="_blank" rel="noopener">查看更多</a></p><p><strong>cache &amp;&amp; Job.cache</strong> 要求 GitLab Runner 0.7.0+</p><p>定义需要缓存的文件。 每个 Job 开始的时候，Runner 都会删掉 .gitignore 里面的文件。 如果有些文件 (如 node_modules/) 需要多个 Jobs 共用的话，我们只能让每个 Job 都先执行一遍 npm install。 这样很不方便，因此我们需要对这些文件进行缓存。缓存了的文件除了可以跨 Jobs 使用外，还可以跨 Pipeline 使用。</p><p>具体用法请查看 <a href="http://docs.gitlab.com/ce/ci/yaml/README.html#cache" target="_blank" rel="noopener">官方文档</a>。</p><p><strong>Job.script</strong> 定义 Job 要运行的命令，必填项。</p><p><strong>Job.stage</strong> 定义 Job 的 stage，默认为 test。</p><p><strong>Job.artifacts</strong> 定义 Job 中生成的附件。 当该 Job 运行成功后，生成的文件可以作为附件 (如生成的二进制文件) 保留下来，打包发送到 GitLab，之后我们可以在 GitLab 的项目页面下下载该附件。 注意，不要把 artifacts 和 cache 混淆了。</p><h3 id="实用例子"><a href="#实用例子" class="headerlink" title="实用例子"></a>实用例子</h3><p>下面给出一个我自己在用的例子：</p><pre><code>stages:  - install_deps  - test  - build  - deploy_test  - deploy_productioncache:  key: ${CI_BUILD_REF_NAME}  paths:    - node_modules/    - dist/# 安装依赖install_deps:  stage: install_deps  only:    - develop    - master  script:    - npm install# 运行测试用例test:  stage: test  only:    - develop    - master  script:    - npm run test# 编译build:  stage: build  only:    - develop    - master  script:    - npm run clean    - npm run build:client    - npm run build:server# 部署测试服务器deploy_test:  stage: deploy_test  only:    - develop  script:    - pm2 delete app || true    - pm2 start app.js --name app# 部署生产服务器deploy_production:  stage: deploy_production  only:    - master  script:    - bash scripts/deploy/deploy.sh</code></pre><p>上面的配置把一次 Pipeline 分成五个阶段：</p><ul><li>安装依赖(install_deps)</li><li>运行测试(test)</li><li>编译(build)</li><li>部署测试服务器(deploy_test)</li><li>部署生产服务器(deploy_production)</li></ul><p>设置 Job.only 后，只有当 develop 分支和 master 分支有提交的时候才会触发相关的 Jobs。 注意，我这里用 GitLab Runner 所在的服务器作为测试服务器。</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Http和Https三次握手</title>
      <link href="/306.html"/>
      <url>/306.html</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP与TCP-IP区别？"><a href="#HTTP与TCP-IP区别？" class="headerlink" title="HTTP与TCP/IP区别？"></a>HTTP与TCP/IP区别？</h3><ul><li><p>TPC/IP协议是传输层协议，主要解决数据如何在网络中传输</p></li><li><p>HTTP是应用层协议，主要解决如何包装数据</p></li><li><p>WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。</p></li></ul><h3 id="CA证书是什么？"><a href="#CA证书是什么？" class="headerlink" title="CA证书是什么？"></a>CA证书是什么？</h3><p>CA（Certificate Authority）是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任的、认可的。</p><p>CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。</p><h3 id="HTTP三次握手"><a href="#HTTP三次握手" class="headerlink" title="HTTP三次握手"></a>HTTP三次握手</h3><p>HTTP（HyperText Transfer Protocol)超文本传输协议是互联网上应用最为广泛的一种网络协议。由于信息是明文传输，所以被认为是不安全的。而关于HTTP的三次握手，其实就是使用三次TCP握手确认建立一个HTTP连接。</p><p>如下图所示，SYN（synchronous）是TCP/IP建立连接时使用的握手信号、Sequence number（序列号）、Acknowledge number（确认号码），三个箭头指向就代表三次握手，完成三次握手，客户端与服务器开始传送数据。</p><p><img src="http://cdn.flqin.com/p306_1.png" alt></p><p>1.第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 2.第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 3.第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p><h3 id="HTTPS三次握手"><a href="#HTTPS三次握手" class="headerlink" title="HTTPS三次握手"></a>HTTPS三次握手</h3><p>HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。具体是如何进行加密，解密，验证的，且看下图，下面的称为一次握手。</p><p><img src="http://cdn.flqin.com/p306-2.png" alt></p><p>1.客户端发起HTTPS请求</p><p>2.服务端的配置</p><p>采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</p><p>3.传送证书</p><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。</p><p>4.客户端解析证书</p><p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。</p><p>5.传送加密信息</p><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><p>6.服务段解密信息</p><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一 起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><p>7.传输加密后的信息</p><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p><p>8.客户端解密信息</p><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。</p><p>PS: 整个握手过程第三方即使监听到了数据，也束手无策。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>为什么HTTPS是安全的？</strong></p><p>在HTTPS握手的第四步中，如果站点的证书是不受信任的，会显示出现下面确认界面，确认了网站的真实性。另外第六和八步，使用客户端私钥加密解密，保证了数据传输的安全。 [图片]</p><p><strong>HTTPS和HTTP的区别</strong></p><p>1.https协议需要到ca申请证书或自制证书。 2.http的信息是明文传输，https则是具有安全性的ssl加密。 3.http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443。 4.http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 5.HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电。 6.HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响。 7.谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><h3 id="6-附录"><a href="#6-附录" class="headerlink" title="6.附录"></a>6.附录</h3><p>HTTPS一般使用的加密与HASH算法如下：</p><p>非对称加密算法：RSA，DSA/DSS 对称加密算法：AES，RC4，3DES HASH算法：MD5，SHA1，SHA256</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>301、302、200、206、304、404等HTTP状态引见</title>
      <link href="/303.html"/>
      <url>/303.html</url>
      
        <content type="html"><![CDATA[<p>如果向您的服务器发出了某项请求要求显示您网站上的某个网页，那么，您的服务器会返回 HTTP 状态代码以响应该请求。 一些常见的状态代码为：</p><p>200 - 服务器成功返回网页 404 - 请求的网页不存在 503 - 服务器暂时不可用 以下提供了 HTTP 状态代码的完整列表。点击链接可了解详细信息。您也可以访问有关 HTTP 状态代码的 W3C 页来了解详细信息。</p><h3 id="1xx（临时响应）"><a href="#1xx（临时响应）" class="headerlink" title="1xx（临时响应）"></a>1xx（临时响应）</h3><p>用于表示临时响应并需要请求者执行操作才能继续的状态代码。</p><p><strong>100（继续）</strong> 请求者应当继续提出请求。服务器返回此代码则意味着，服务器已收到了请求的第一部分，现正在等待接收其余部分。 <strong>101（切换协议）</strong> 请求者已要求服务器切换协议，服务器已确认并准备进行切换。</p><h3 id="2xx（成功）"><a href="#2xx（成功）" class="headerlink" title="2xx（成功）"></a>2xx（成功）</h3><p>用于表示服务器已成功处理了请求的状态代码。</p><p><strong>200（成功）</strong> 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果您的 robots.txt 文件显示为此状态，那么，这表示 Googlebot 已成功检索到该文件。 <strong>201（已创建）</strong> 请求成功且服务器已创建了新的资源。 <strong>202（已接受）</strong> 服务器已接受了请求，但尚未对其进行处理。 <strong>203（非授权信息）</strong> 服务器已成功处理了请求，但返回了可能来自另一来源的信息。 <strong>204（无内容）</strong> 服务器成功处理了请求，但未返回任何内容。 <strong>205（重置内容）</strong> 服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。 <strong>206（部分内容）</strong> 服务器成功处理了部分 GET 请求。</p><h3 id="3xx（已重定向）"><a href="#3xx（已重定向）" class="headerlink" title="3xx（已重定向）"></a>3xx（已重定向）</h3><p>要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。Google 建议您在每次请求时使用的重定向要少于 5 个。您可以使用网站管理员工具来查看 Googlebot 在抓取您已重定向的网页时是否会遇到问题。诊断下的抓取错误页中列出了 Googlebot 由于重定向错误而无法抓取的网址。</p><p><strong>300（多种选择）</strong> 服务器根据请求可执行多种操作。服务器可根据请求者 (User agent) 来选择一项操作，或提供操作列表供请求者选择。 <strong>301（永久移动）</strong> 请求的网页已被永久移动到新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码通知 Googlebot 某个网页或网站已被永久移动到新位置。 <strong>302（临时移动）</strong> 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。 <strong>303（查看其他位置）</strong> 当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。 <strong>304（未修改）</strong> 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。由于服务器可以告诉 Googlebot 自从上次抓取后网页没有更改过，因此可节省带宽和开销。 <strong>305（使用代理）</strong> 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。 <strong>307（临时重定向）</strong> 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。</p><h3 id="4xx（请求错误）"><a href="#4xx（请求错误）" class="headerlink" title="4xx（请求错误）"></a>4xx（请求错误）</h3><p>这些状态代码表示，请求可能出错，已妨碍了服务器对请求的处理。</p><p><strong>400（错误请求）</strong> 服务器不理解请求的语法。 <strong>401（未授权）</strong> 请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。 <strong>403（已禁止）</strong> 服务器拒绝请求。如果在 Googlebot 尝试抓取您网站上的有效网页时显示此状态代码（您可在 Google 网站管理员工具中诊 断下的网络抓取页面上看到此状态代码），那么，这可能是您的服务器或主机拒绝 Googlebot 对其进行访问。 <strong>404（未找到）</strong> 服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具” 诊断”标签的 robots.txt 页上发现此状态，那么，这是正确的状态。然而，如果您有 robots.txt 文件而又发现了此状态，那么，这说明您的 robots.txt 文件可能是命名错误或位于错误的位置。（该文件应当位于顶级域名上，且应当名为 robots.txt）。如果您在 Googlebot 尝试抓取的网址上发现此状态（位于”诊断”标签的 HTTP 错误页上），那么，这表示 Googlebot 所追踪的可能是另一网页中的无效链接（旧链接或输入有误的链接）。 <strong>405（方法禁用）</strong> 禁用请求中所指定的方法。 <strong>406（不接受）</strong> 无法使用请求的内容特性来响应请求的网页。 <strong>407（需要代理授权）</strong> 此状态代码与 401（未授权）类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。 <strong>408（请求超时）</strong> 服务器等候请求时超时。 <strong>409（冲突）</strong> 服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。 <strong>410（已删除）</strong> 如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 404（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。 <strong>411（需要有效长度）</strong> 服务器不会接受包含无效内容长度标头字段的请求。 <strong>412（未满足前提条件）</strong> 服务器未满足请求者在请求中设置的其中一个前提条件。 <strong>413（请求实体过大）</strong> 服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。 <strong>414（请求的 URI 过长）</strong> 请求的 URI（通常为网址）过长，服务器无法进行处理。 <strong>415（不支持的媒体类型）</strong> 请求的格式不受请求页面的支持。 <strong>416（请求范围不符合要求）</strong> 如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。 <strong>417（未满足期望值）</strong> 服务器未满足”期望”请求标头字段的要求。</p><h3 id="5xx（服务器错误）"><a href="#5xx（服务器错误）" class="headerlink" title="5xx（服务器错误）"></a>5xx（服务器错误）</h3><p>这些状态代码表示，服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</p><p><strong>500（服务器内部错误）</strong> 服务器遇到错误，无法完成请求。 <strong>501（尚未实施）</strong> 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。 <strong>502（错误网关）</strong> 服务器作为网关或代理，从上游服务器收到了无效的响应。 <strong>503（服务不可用）</strong> 目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。 <strong>504（网关超时）</strong> 服务器作为网关或代理，未及时从上游服务器接收请求。 <strong>505（HTTP 版本不受支持）</strong></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 原型与原型链详解</title>
      <link href="/277.html"/>
      <url>/277.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-普通对象与函数对象"><a href="#一-普通对象与函数对象" class="headerlink" title="一. 普通对象与函数对象"></a>一. 普通对象与函数对象</h3><p>JavaScript 中，万物皆对象！但对象也是有区别的。分为<strong>普通对象</strong>和<strong>函数对象</strong>，Object 、Function 是 JS 自带的函数对象。下面举例说明</p><pre><code>var o1 = {}; var o2 =new Object();var o3 = new f1();function f1(){}; var f2 = function(){};var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;);console.log(typeof Object); //function console.log(typeof Function); //function  console.log(typeof f1); //function console.log(typeof f2); //function console.log(typeof f3); //function   console.log(typeof o1); //object console.log(typeof o2); //object console.log(typeof o3); //object</code></pre><p>在上面的例子中 o1 o2 o3 为普通对象，f1 f2 f3 为函数对象。怎么区分，其实很简单，<strong>凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。</strong> 一定要分清楚普通对象和函数对象，下面我们会常常用到它。</p><h3 id="二-构造函数"><a href="#二-构造函数" class="headerlink" title="二. 构造函数"></a>二. 构造函数</h3><p>我们先复习一下构造函数的知识：</p><pre><code>function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function() { alert(this.name) } }var person1 = new Person(&apos;Zaxlct&apos;, 28, &apos;Software Engineer&apos;);var person2 = new Person(&apos;Mick&apos;, 23, &apos;Doctor&apos;);</code></pre><p>上面的例子中 person1 和 person2 都是 Person 的<strong>实例</strong>。这两个实例都有一个 <code>constructor</code> （构造函数）属性，该属性（是一个指针）指向 Person。 即：</p><pre><code>console.log(person1.constructor == Person); //trueconsole.log(person2.constructor == Person); //true</code></pre><p>我们要记住两个概念（构造函数，实例）： <strong>person1 和 person2 都是 构造函数 Person 的实例。</strong> 一个公式： <strong>实例的构造函数属性（constructor）指向构造函数。</strong></p><h3 id="三-原型对象"><a href="#三-原型对象" class="headerlink" title="三. 原型对象"></a>三. 原型对象</h3><p>在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个<strong>函数对象</strong>都有一个<code>prototype</code> 属性，这个属性指向函数的<strong>原型对象</strong>。 （先用不管什么是<code>__proto__</code>第二节的课程会详细的剖析）</p><pre><code>function Person() {}Person.prototype.name = &apos;Zaxlct&apos;;Person.prototype.age  = 28;Person.prototype.job  = &apos;Software Engineer&apos;;Person.prototype.sayName = function() {  alert(this.name);}var person1 = new Person();person1.sayName(); // &apos;Zaxlct&apos;var person2 = new Person();person2.sayName(); // &apos;Zaxlct&apos;console.log(person1.sayName == person2.sayName); //true</code></pre><p>我们得到了本文第一个「<strong>定律</strong>」：</p><pre><code>每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性</code></pre><p>那什么是<strong>原型对象</strong>呢？ 我们把上面的例子改一改你就会明白了：</p><pre><code>Person.prototype = {   name:  &apos;Zaxlct&apos;,   age: 28,   job: &apos;Software Engineer&apos;,   sayName: function() {     alert(this.name);   }}</code></pre><p>原型对象，顾名思义，它就是一个普通对象（废话 = =!）。从现在开始你要牢牢记住原型对象就是 Person.prototype ，如果你还是害怕它，那就把它想想成一个字母 A： <code>var A = Person.prototype</code></p><p>在上面我们给 A 添加了 四个属性：name、age、job、sayName。其实它还有一个默认的属性：<code>constructor</code></p><blockquote><p>在默认情况下，所有的原型对象都会自动获得一个 <code>constructor</code>（构造函数）属性，这个属性（是一个指针）指向 <code>prototype</code> 属性所在的函数（Person）</p></blockquote><p>上面这句话有点拗口，我们「翻译」一下：A 有一个默认的 <code>constructor</code> 属性，这个属性是一个指针，指向 Person。即： <code>Person.prototype.constructor == Person</code></p><p>在上面第二小节《构造函数》里，我们知道实例的构造函数属性（constructor）指向构造函数 ：<code>person1.constructor == Person</code></p><p>这两个「公式」好像有点联系：</p><pre><code>person1.constructor == PersonPerson.prototype.constructor == Person</code></pre><p>person1 为什么有 constructor 属性？那是因为 person1 是 Person 的实例。 那 Person.prototype 为什么有 constructor 属性？？同理， Person.prototype （你把它想象成 A） 也是Person 的实例。 也就是在 Person 创建的时候，创建了一个它的实例对象并赋值给它的 prototype，基本过程如下：</p><pre><code>var A = new Person();Person.prototype = A;</code></pre><p><strong>结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。</strong></p><p>原型对象其实就是普通对象（但 Function.prototype 除外，它是函数对象，但它很特殊，他没有prototype属性（前面说道函数对象都有prototype属性））。看下面的例子：</p><pre><code>function Person(){};console.log(Person.prototype) //Person{}console.log(typeof Person.prototype) //Objectconsole.log(typeof Function.prototype) // Function，这个特殊console.log(typeof Object.prototype) // Objectconsole.log(typeof Function.prototype.prototype) //undefined</code></pre><p><code>Function.prototype</code> 为什么是函数对象呢？</p><pre><code>var A = new Function ();Function.prototype = A;</code></pre><p><strong>上文提到凡是通过 new Function( ) 产生的对象都是函数对象。因为 A 是函数对象，所以Function.prototype 是函数对象。</strong></p><p>那原型对象是用来做什么的呢？主要作用是用于继承。举个例子：</p><pre><code>var Person = function(name){  this.name = name; // tip: 当函数执行时这个 this 指的是谁？};Person.prototype.getName = function(){  return this.name;  // tip: 当函数执行时这个 this 指的是谁？}var person1 = new person(&apos;Mick&apos;);person1.getName(); //Mick</code></pre><p>从这个例子可以看出，通过给 <code>Person.prototype</code> 设置了一个函数对象的属性，那有 Person 的实例（person1）出来的普通对象就继承了这个属性。具体是怎么实现的继承，就要讲到下面的原型链了。</p><p>小问题，上面两个 this 都指向谁？</p><pre><code>var person1 = new person(&apos;Mick&apos;);person1.name = &apos;Mick&apos;; // 此时 person1 已经有 name 这个属性了person1.getName(); //Mick  </code></pre><p>故两次 this 在函数执行时都指向 person1。</p><h3 id="四-proto"><a href="#四-proto" class="headerlink" title="四. __proto__"></a>四. __proto__</h3><p>JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<code>__proto__</code>的内置属性，用于指向创建它的构造函数的原型对象。 对象 person1 有一个<code>__proto__</code>属性，创建它的构造函数是 Person，构造函数的原型对象是 Person.prototype ，所以： <code>person1.__proto__ == Person.prototype</code></p><p><img src="http://cdn.flqin.com/p277-1.jpg" alt></p><p>根据上面这个连接图，我们能得到：</p><pre><code>Person.prototype.constructor == Person;person1.__proto__ == Person.prototype;person1.constructor == Person;</code></pre><p><strong>不过，要明确的真正重要的一点就是，这个连接存在于实例（<code>person1</code>）与构造函数（<code>Person</code>）的原型对象（<code>Person.prototype</code>）之间，而不是存在于实例（<code>person1</code>）与构造函数（<code>Person</code>）之间。</strong></p><p>注意：因为绝大部分浏览器都支持<code>__proto__</code>属性，所以它才被加入了 ES6 里（ES5 部分浏览器也支持，但还不是标准）。</p><h3 id="五-构造器"><a href="#五-构造器" class="headerlink" title="五. 构造器"></a>五. 构造器</h3><p>熟悉 Javascript 的童鞋都知道，我们可以这样创建一个对象： <code>var obj = {}</code> 它等同于下面这样： <code>var obj = new Object()</code></p><p>obj 是构造函数（Object）的一个实例。所以： <code>obj.constructor === Object</code> <code>obj.__proto__ === Object.prototype</code></p><p>新对象 obj 是使用 new 操作符后跟一个<strong>构造函数</strong>来创建的。构造函数（Object）本身就是一个函数（就是上面说的函数对象），它和上面的构造函数 Person 差不多。只不过该函数是出于创建新对象的目的而定义的。所以不要被 Object 吓倒。</p><p>同理，可以创建对象的构造器不仅仅有 Object，也可以是 Array，Date，Function等。 所以我们也可以构造函数来创建 Array、 Date、Function</p><pre><code>var b = new Array();b.constructor === Array;b.__proto__ === Array.prototype;var c = new Date(); c.constructor === Date;c.__proto__ === Date.prototype;var d = new Function();d.constructor === Function;d.__proto__ === Function.prototype;</code></pre><p>Object,Function,Array,Date,Number,String,Boolean 这些构造器都是函数对象.</p><h3 id="六-原型链"><a href="#六-原型链" class="headerlink" title="六. 原型链"></a>六. 原型链</h3><p>小测试来检验一下你理解的怎么样：</p><p>1.<code>person1.__proto__</code> 是什么？ 2.<code>Person.__proto__</code> 是什么？ 3.<code>Person.prototype.__proto__</code> 是什么？ 4.<code>Object.__proto__</code> 是什么？ 5.<code>Object.prototype__proto__</code> 是什么？</p><p>答案： 第一题： 因为 <code>person1.__proto__ === person1 的构造函数.prototype</code> 因为 <code>person1的构造函数 === Person</code> 所以 <code>person1.__proto__ === Person.prototype</code></p><p>第二题： 因为 <code>Person.__proto__ === Person的构造函数.prototype</code> 因为 <code>Person的构造函数 === Function</code> 所以 <code>Person.__proto__ === Function.prototype</code></p><p>第三题： <code>Person.prototype</code> 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。 因为一个普通对象的构造函数 === Object 所以 <code>Person.prototype.__proto__ === Object.prototype</code></p><p>第四题，参照第二题，因为 Person 和 Object 一样都是构造函数</p><p>第五题： <code>Object.prototype</code> 对象也有proto属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端，这个只能记住。 <code>Object.prototype.__proto__ === null</code></p><h3 id="七-函数对象-（复习一下前面的知识点）"><a href="#七-函数对象-（复习一下前面的知识点）" class="headerlink" title="七. 函数对象 （复习一下前面的知识点）"></a>七. 函数对象 （复习一下前面的知识点）</h3><p><strong>所有函数对象的proto都指向Function.prototype，它是一个空函数（Empty function）</strong></p><pre><code>Number.__proto__ === Function.prototype  // trueNumber.constructor == Function //trueBoolean.__proto__ === Function.prototype // trueBoolean.constructor == Function //trueString.__proto__ === Function.prototype  // trueString.constructor == Function //true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Object.__proto__ === Function.prototype  // trueObject.constructor == Function // true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Function.__proto__ === Function.prototype // trueFunction.constructor == Function //trueArray.__proto__ === Function.prototype   // trueArray.constructor == Function //trueRegExp.__proto__ === Function.prototype  // trueRegExp.constructor == Function //trueError.__proto__ === Function.prototype   // trueError.constructor == Function //trueDate.__proto__ === Function.prototype    // trueDate.constructor == Function //true</code></pre><p>JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的<code>__proto__</code>是Object.prototype。如下</p><pre><code>Math.__proto__ === Object.prototype  // trueMath.construrctor == Object // trueJSON.__proto__ === Object.prototype  // trueJSON.construrctor == Object //true</code></pre><p>上面说的<strong>函数对象</strong>当然包括自定义的。如下</p><pre><code>// 函数声明function Person() {}// 函数表达式var Perosn = function() {}console.log(Person.__proto__ === Function.prototype) // trueconsole.log(Man.__proto__ === Function.prototype)    // true</code></pre><p>这说明什么呢？</p><p>** 所有的构造器都来自于 <code>Function.prototype</code>，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind**</p><p>（你应该明白第一句话，第二句话我们下一节继续说，先挖个坑：）） <code>Function.prototype</code>也是唯一一个typeof XXX.prototype为 function的prototype。其它的构造器的prototype都是一个对象（原因第三节里已经解释过了）。如下（又复习了一遍）：</p><pre><code>console.log(typeof Function.prototype) // functionconsole.log(typeof Object.prototype)   // objectconsole.log(typeof Number.prototype)   // objectconsole.log(typeof Boolean.prototype)  // objectconsole.log(typeof String.prototype)   // objectconsole.log(typeof Array.prototype)    // objectconsole.log(typeof RegExp.prototype)   // objectconsole.log(typeof Error.prototype)    // objectconsole.log(typeof Date.prototype)     // objectconsole.log(typeof Object.prototype)   // object</code></pre><p>噢，上面还提到它是一个空的函数，<code>console.log(Function.prototype)</code> 下看看（留意，下一节会再说一下这个）</p><p>知道了所有构造器（含内置及自定义）的<code>__proto__</code>都是<code>Function.prototype</code>，那<code>Function.prototype</code>的<code>__proto__</code>是谁呢？ 相信都听说过JavaScript中函数也是一等公民，那从哪能体现呢？如下 <code>console.log(Function.prototype.__proto__ === Object.prototype) // true</code> 这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。（你也应该明白第一句话，第二句话我们下一节继续说，不用挖坑了，还是刚才那个坑；））</p><p>最后Object.prototype的<code>__proto__</code>是谁？ <code>Object.prototype.__proto__ === null // true</code> 已经到顶了，为null。(读到现在，再回过头看第五章，能明白吗？)</p><h3 id="八-Prototype"><a href="#八-Prototype" class="headerlink" title="八. Prototype"></a>八. Prototype</h3><blockquote><p>在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 <code>prototype</code> 属性了。对于 ECMAScript 中的引用类型而言，prototype 是保存着它们所有实例方法的真正所在。换句话所说，诸如 toString()和 valuseOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。</p></blockquote><p>我们知道 JS 内置了一些方法供我们使用，比如： 对象可以用 <code>constructor/toString()/valueOf()</code> 等方法; 数组可以用 <code>map()/filter()/reducer()</code> 等方法； 数字可用用 <code>parseInt()/parseFloat()</code>等方法； Why ？？？</p><p><strong>当我们创建一个函数时：</strong> <code>var Person = new Object()</code> <code>Person</code> 是 <code>Object</code> 的实例，所以 Person 继承了Object 的原型对象Object.prototype上所有的方法。</p><p><strong>Object 的每个实例都具有Object.prototype的属性和方法。</strong> 所以我可以用 <code>Person.constructor</code> 也可以用 <code>Person.hasOwnProperty</code>。</p><p><strong>当我们创建一个数组时：</strong></p><p><code>var num = new Array()</code> <code>num</code> 是 <code>Array</code> 的实例，所以 <code>num</code> <strong>继承</strong>了Array 的原型对象Array.prototype上所有的方法。 <code>Array.prototype =&gt; []</code> Are you f***ing kidding me? 这尼玛怎么是一个空数组？？？</p><p>我们可以用一个 ES5 提供的新方法：<code>Object.getOwnPropertyNames</code> 获取所有<strong>（包括不可枚举的属性）</strong>的属性名<strong>不包括 <code>prototy</code> 中的属性</strong>，返回一个数组：</p><pre><code>var arrayAllKeys = Array.prototype; // [] 空数组// 只得到 arrayAllKeys 这个对象里所有的属性名(不会去找 arrayAllKeys.prototype 中的属性)console.log(Object.getOwnPropertyNames(arrayAllKeys)); /* 输出：[&quot;length&quot;, &quot;constructor&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;join&quot;, &quot;pop&quot;, &quot;push&quot;, &quot;concat&quot;, &quot;reverse&quot;, &quot;shift&quot;, &quot;unshift&quot;, &quot;slice&quot;, &quot;splice&quot;, &quot;sort&quot;, &quot;filter&quot;, &quot;forEach&quot;, &quot;some&quot;, &quot;every&quot;, &quot;map&quot;, &quot;indexOf&quot;, &quot;lastIndexOf&quot;, &quot;reduce&quot;, &quot;reduceRight&quot;, &quot;entries&quot;, &quot;keys&quot;, &quot;copyWithin&quot;, &quot;find&quot;, &quot;findIndex&quot;, &quot;fill&quot;]*/</code></pre><p>这样你就明白了随便声明一个数组，它为啥能用那么多方法了。</p><p>细心的你肯定发现了<code>Object.getOwnPropertyNames(arrayAllKeys)</code>输出的数组里并没有 <code>constructor/hasOwnPrototype</code>等<strong>对象</strong>的方法（你肯定没发现）。 但是随便定义的数组也能用这些方法</p><pre><code>var num = [1];console.log(num.hasOwnPrototype()) // false (输出布尔值而不是报错)</code></pre><p>Why ？？？</p><p>因为<code>Array.prototype</code>虽然没这些方法，但是它有原型对象（__proto__）：</p><pre><code>// 上面我们说了 Object.prototype 就是一个普通对象。Array.prototype.__proto__ == Object.prototype</code></pre><p>所以 <code>Array.prototype</code> 继承了对象的所有方法，当你用num.hasOwnPrototype()时，JS 会先查一下它的构造函数 （Array） 的原型对象 Array.prototype 有没有有hasOwnPrototype()方法，没查到的话继续查一下 Array.prototype 的原型对象 <code>Array.prototype.__proto__</code>有没有这个方法。</p><p><strong>当我们创建一个函数时：</strong></p><pre><code>var f = new Function(&quot;x&quot;,&quot;return x*x;&quot;);//当然你也可以这么创建 f = function(x){ return x*x }console.log(f.arguments) // arguments 方法从哪里来的？console.log(f.call(window)) // call 方法从哪里来的？console.log(Function.prototype) // function() {} （一个空的函数）console.log(Object.getOwnPropertyNames(Function.prototype)); /* 输出[&quot;length&quot;, &quot;name&quot;, &quot;arguments&quot;, &quot;caller&quot;, &quot;constructor&quot;, &quot;bind&quot;, &quot;toString&quot;, &quot;call&quot;, &quot;apply&quot;]*/</code></pre><p>我们再复习第八小节这句话：</p><blockquote><p>所有<strong>函数对象proto</strong>都指向 <code>Function.prototype</code>，它是一个空函数（Empty function）</p></blockquote><p>嗯，我们验证了它就是空函数。不过不要忽略前半句。我们枚举出了它的所有的方法，所以所有的<strong>函数对象</strong>都能用。</p><p>如果你还没搞懂啥是函数对象？</p><p>还有，我建议你可以再复习下为什么：</p><blockquote><p><code>Function.prototype</code> 是唯一一个typeof XXX.prototype为 “function”的prototype</p></blockquote><h3 id="九-复习一下"><a href="#九-复习一下" class="headerlink" title="九. 复习一下"></a>九. 复习一下</h3><p>第八小节我们总结了：</p><pre><code>所有函数对象的 __proto__ 都指向 Function.prototype，它是一个空函数（Empty function）</code></pre><p>但是你可别忘了在第三小节我们总结的：</p><pre><code>所有对象的 __proto__ 都指向其构造器的 prototype</code></pre><p>先看看 JS 内置构造器：</p><pre><code>var obj = {name: &apos;jack&apos;}var arr = [1,2,3]var reg = /hello/gvar date = new Datevar err = new Error(&apos;exception&apos;)console.log(obj.__proto__ === Object.prototype) // trueconsole.log(arr.__proto__ === Array.prototype)  // trueconsole.log(reg.__proto__ === RegExp.prototype) // trueconsole.log(date.__proto__ === Date.prototype)  // trueconsole.log(err.__proto__ === Error.prototype)  // true</code></pre><p>再看看自定义的构造器，这里定义了一个 <code>Person</code>：</p><pre><code>function Person(name) {  this.name = name;}var p = new Person(&apos;jack&apos;)console.log(p.__proto__ === Person.prototype) // true</code></pre><p><code>p</code> 是 <code>Person</code> 的实例对象，p 的内部原型总是指向其构造器 Person 的原型对象 prototype。</p><p>每个对象都有一个 <code>constructor</code> 属性，可以获取它的构造器，因此以下打印结果也是恒等的：</p><pre><code>function Person(name) {    this.name = name}var p = new Person(&apos;jack&apos;)console.log(p.__proto__ === p.constructor.prototype) // true</code></pre><p>上面的<code>Person</code>没有给其原型添加属性或方法，这里给其原型添加一个getName方法：</p><pre><code>function Person(name) {    this.name = name}// 修改原型Person.prototype.getName = function() {}var p = new Person(&apos;jack&apos;)console.log(p.__proto__ === Person.prototype) // trueconsole.log(p.__proto__ === p.constructor.prototype) // true</code></pre><p>可以看到<code>p.__proto__</code>与<code>Person.prototype</code>，<code>p.constructor.prototype</code>都是恒等的，即都指向同一个对象。</p><p>如果换一种方式设置原型，结果就有些不同了：</p><pre><code>function Person(name) {    this.name = name}// 重写原型Person.prototype = {    getName: function() {}}var p = new Person(&apos;jack&apos;)console.log(p.__proto__ === Person.prototype) // trueconsole.log(p.__proto__ === p.constructor.prototype) // false</code></pre><p>这里直接重写了 <code>Person.prototype</code>（注意：上一个示例是修改原型）。输出结果可以看出<code>p.__proto__</code>仍然指向的是<code>Person.prototype</code>，而不是p.constructor.prototype。</p><p>这也很好理解，给<code>Person.prototype</code>赋值的是一个对象直接量<code>{getName: function(){}}</code>，使用对象直接量方式定义的对象其构造器（constructor）指向的是根构造器Object，Object.prototype是一个空对象{}，{}自然与{getName: function(){}}不等。如下：</p><pre><code>var p = {}console.log(Object.prototype) // 为一个空的对象{}console.log(p.constructor === Object) // 对象直接量方式定义的对象其constructor为Objectconsole.log(p.constructor.prototype === Object.prototype) // 为true，不解释(๑ˇ3ˇ๑)</code></pre><h3 id="十-原型链（再复习一下：）"><a href="#十-原型链（再复习一下：）" class="headerlink" title="十. 原型链（再复习一下：）"></a>十. 原型链（再复习一下：）</h3><p>下面这个例子你应该能明白了！</p><pre><code>function Person(){}var person1 = new Person();console.log(person1.__proto__ === Person.prototype); // trueconsole.log(Person.prototype.__proto__ === Object.prototype) //trueconsole.log(Object.prototype.__proto__) //nullPerson.__proto__ == Function.prototype; //trueconsole.log(Function.prototype)// function(){} (空函数)var num = new Array()console.log(num.__proto__ == Array.prototype) // trueconsole.log( Array.prototype.__proto__ == Object.prototype) // trueconsole.log(Array.prototype) // [] (空数组)console.log(Object.prototype.__proto__) //nullconsole.log(Array.__proto__ == Function.prototype)// true</code></pre><p>疑点解惑：</p><p>1.<code>Object.__proto__ === Function.prototype // true</code> <code>Object</code> 是函数对象，是通过<code>new Function()</code>创建的，所以<code>Object.__proto__</code>指向<code>Function.prototype</code>。（参照第八小节：「所有函数对象的<code>__proto__</code>都指向<code>Function.prototype</code>」）</p><p>2.<code>Function.__proto__ === Function.prototype // true</code> <code>Function</code> 也是对象函数，也是通过<code>new Function()</code>创建，所以<code>Function.__proto__</code>指向<code>Function.prototype</code>。</p><blockquote><p>自己是由自己创建的，好像不符合逻辑，但仔细想想，现实世界也有些类似，你是怎么来的，你妈生的，你妈怎么来的，你姥姥生的，……类人猿进化来的，那类人猿从哪来，一直追溯下去……，就是无，（NULL生万物） 正如《道德经》里所说“无，名天地之始”。</p></blockquote><p>3.<code>Function.prototype.__proto__ === Object.prototype //true</code></p><blockquote><p>其实这一点我也有点困惑，不过也可以试着解释一下。 <code>Function.prototype</code>是个函数对象，理论上他的<code>__proto__</code>应该指向 <code>Function.prototype</code>，就是他自己，自己指向自己，没有意义。 JS一直强调万物皆对象，函数对象也是对象，给他认个祖宗，指向<code>Object.prototype</code>。<code>Object.prototype.__proto__ === null</code>，保证原型链能够正常结束。</p></blockquote><h3 id="十一-总结"><a href="#十一-总结" class="headerlink" title="十一.总结"></a>十一.总结</h3><ul><li>原型和原型链是JS实现继承的一种模型。</li><li>原型链的形成是真正是靠<code>__proto__</code>而非<code>prototype</code></li></ul><p>要深入理解这句话，我们再举个例子，看看前面你真的理解了吗？</p><pre><code>var animal = function(){};var dog = function(){};animal.price = 2000;dog.prototype = animal;var tidy = new dog();console.log(dog.price) //undefinedconsole.log(tidy.price) // 2000</code></pre><p>这里解释一下：</p><pre><code>var dog = function(){};dog.prototype.price = 2000;var tidy = new dog();console.log(tidy.price); // 2000console.log(dog.price); //undefinedvar dog = function(){};var tidy = new dog();tidy.price = 2000;console.log(dog.price); //undefined</code></pre><p>这个明白吧？想一想我们上面说过这句话：</p><blockquote><p>实例（<code>tidy</code>）和 原型对象（<code>dog.prototype</code>）存在一个连接。不过，要明确的真正重要的一点就是，这个连接存在于实例（<code>tidy</code>）与构造函数的原型对象（<code>dog.prototype</code>）之间，而不是存在于实例（<code>tidy</code>）与构造函数（<code>dog</code>）之间。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>同一台电脑关于多个SSH KEY管理</title>
      <link href="/273.html"/>
      <url>/273.html</url>
      
        <content type="html"><![CDATA[<p><strong>1.比如有 aaa,bbb,ccc 三个帐号需要生成不同的 PUBLIC KEY</strong></p><pre><code>$ ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa):/root/.ssh/id_rsa_aaaEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa_aaa.Your public key has been saved in /root/.ssh/id_rsa_aaa.pub.The key fingerprint is:9b:92:f6:1f:d2:72:bd:72:19:45:42:5f:e4:65:33:64 root@AY140122145815620396ZThe key&apos;s randomart image is:+--[ RSA 2048]----+|           .. .E=||            ..o++||             o. .||              .  ||        S    .   ||       . + ..    ||      + = + .o   ||     . o +..o.   ||        ...o.    |+-----------------+</code></pre><p>我们在 /root/.ssh/ 目录下创建 id_rsa_aaa 私钥 和 id_rsa_aaa.pub 公钥.</p><pre><code>Enter file in which to save the key (/root/.ssh/id_rsa):/root/.ssh/id_rsa_aaa  #设置路径,如果不设置默认生成 id_rsa  和  id_rsa.pub</code></pre><p><strong>2.按照上面的步骤逐个生成 bbb 和 ccc 对应的公钥和私钥</strong></p><p><strong>3.查看系统 ssh-key 代理,执行如下命令</strong></p><pre><code>$ ssh-add -lCould not open a connection to your authentication agent.</code></pre><p>如果发现上面的提示,说明系统代理里没有任何 key,执行如下操作</p><pre><code>exec ssh-agent bash</code></pre><p>如果系统已经有 ssh-key 代理 ,执行下面的命令可以删除</p><pre><code>$ ssh-add -D</code></pre><p><strong>4.把 .ssh 目录下的 3 个私钥添加的 ssh-agent</strong></p><pre><code>$ ssh-add ~/.ssh/id_rsa_aaa$ ssh-add ~/.ssh/id_rsa_bbb$ ssh-add ~/.ssh/id_rsa_ccc</code></pre><p>依次执行上面三条 shell 把三个私钥添加到 ssh-key 代理里面。</p><p><strong>5.打开 github 或者 开源中国 ssh 管理页面把 对应的公钥提交保存到代码管理服务器 (.pub 结尾)</strong></p><p><strong>6.在 .ssh 目录创建 config 配置文件</strong></p><pre><code>nano ~/.ssh/config</code></pre><p>输入如下配置信息:</p><pre><code>#aaa  (github 配置)Host aaa    HostName github.com    User git    IdentityFile ~/.ssh/id_rsa_aaa#bbb  (开源中国 配置)Host bbb    HostName git.oschina.net    User git    IdentityFile ~/.ssh/id_rsa_bbb#ccc........</code></pre><p><strong>7.记住上面一步 Host 里设置的别名,开始克隆项目,以开源中国为例</strong></p><pre><code>git clone git@git.oschina.net:userName/projectName.git</code></pre><p>到此为止多个 ssh-key 已经可以同时使用.</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 垃圾回收</title>
      <link href="/259.html"/>
      <url>/259.html</url>
      
        <content type="html"><![CDATA[<p>根据 Wiki 的定义，垃圾回收是一种自动的内存管理机制。当计算机上的动态内存不再需要时，就应该予以释放，以让出内存。直白点讲，就是程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量、函数等只有产生没有消亡的过程，那迟早内存有被完全占用的时候。这个时候，不仅自己的程序无法正常运行，连其他程序也会受到影响。好比生物只有出生没有死亡，地球总有被撑爆的一天。所以，在计算机中，我们需要垃圾回收。需要注意的是，定义中的“自动”的意思是语言可以帮助我们回收内存垃圾，但并不代表我们不用关心内存管理，如果操作失当，JavaScript 中依旧会出现内存溢出的情况。</p><p>垃圾回收基于两个原理：</p><ul><li>考虑某个变量或对象在未来的程序运行中将不会被访问</li><li>向这些对象要求归还内存</li></ul><p>而这两个原理中，最主要的也是最艰难的部分就是找到“所分配的内存确实已经不再需要了”。</p><h2 id="垃圾回收方法"><a href="#垃圾回收方法" class="headerlink" title="垃圾回收方法"></a>垃圾回收方法</h2><p>下面我们看看在 JavaScript 中是如何找到不再使用的内存的。主要有两种方式：引用计数和标记清除。</p><h3 id="引用计数（reference-counting）"><a href="#引用计数（reference-counting）" class="headerlink" title="引用计数（reference counting）"></a>引用计数（reference counting）</h3><p>在内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收。上例子：</p><pre><code>let obj1 = { a: 1 }; // 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1 let obj2 = obj1; // A 的引用个数变为 2obj1 = 0; // A 的引用个数变为 1obj2 = 0; // A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了</code></pre><p>但是引用计数有个最大的问题： 循环引用。</p><pre><code>function func() {    let obj1 = {};    let obj2 = {};    obj1.a = obj2; // obj1 引用 obj2    obj2.a = obj1; // obj2 引用 obj1}</code></pre><p>当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。</p><p>要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。上面的例子可以这么做：</p><pre><code>obj1 = null;obj2 = null;</code></pre><h3 id="标记-清除（mark-and-sweep）"><a href="#标记-清除（mark-and-sweep）" class="headerlink" title="标记-清除（mark and sweep）"></a>标记-清除（mark and sweep）</h3><p>这是 JavaScript 中最常见的垃圾回收方式。为什么说这是种最常见的方法，因为从 2012 年起，所有现代浏览器都使用了标记-清除的垃圾回收方法，除了低版本 IE…它们采用的是引用计数方法。</p><p>那什么叫标记清除呢？JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象…对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。</p><p>标记－清除法的一个问题就是不那么有效率，因为在标记－清除阶段，整个程序将会等待，所以如果程序出现卡顿的情况，那有可能是收集垃圾的过程。</p><p>2012 年起，所有现代浏览器都使用了这个方法，所有的改进也都是基于这个方法，比如标记-整理方法。</p><p>标记清除有一个问题，就是在清除之后，内存空间是不连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。不过可以想象，这种做法的效率没有标记-清除高。计算机中的很多做法都是互相妥协的结果，哪有什么十全十美的事儿呢。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>在谈什么是良好实践（这里指有益于内存管理）之前，我想先谈谈内存泄漏，也就是差的实践。内存泄漏是指计算机可用的内存越来越少，主要是因为程序不能释放那些不再使用的内存。</p><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>这个没什么好说的，上面已经介绍了。</p><p>需要强调的一点就是，一旦数据不再使用，最好通过将其值设为 null 来释放其引用，这个方法被称为“解除引用”。</p><h3 id="无意的全局变量"><a href="#无意的全局变量" class="headerlink" title="无意的全局变量"></a>无意的全局变量</h3><pre><code>function foo(arg) {    const bar = &quot;&quot;;}foo();</code></pre><p>当 foo 函数执行后，变量 bar 就会被标记为可回收。因为当函数执行时，函数创造了一个作用域来让函数里的变量在里面声明。进入这个作用域后，浏览器就会为变量 bar 创建一个内存空间。当这个函数结束后，其所创建的作用域里的变量也会被标记为垃圾，在下一个垃圾回收周期到来时，这些变量将会被回收。</p><p>但事情并不会那么顺利。</p><pre><code>function foo(arg) {    bar = &quot;&quot;;}foo();</code></pre><p>上面的代码就无意中声明了一个全局变量，会得到 window 的引用，bar 实际上是 window.bar，它的作用域在 window 上，所以 foo 函数执行结束后，bar 也不会被内存收回。</p><p>另外一种无意的全局变量的情况是：</p><pre><code>function foo() {    this.bar = &quot;&quot;;}</code></pre><p>在 foo 函数中，this 指的是 window，犯的错误跟上面类似。</p><h3 id="被遗忘的计时器和回调函数"><a href="#被遗忘的计时器和回调函数" class="headerlink" title="被遗忘的计时器和回调函数"></a>被遗忘的计时器和回调函数</h3><pre><code>let someResource = getData();setInterval(() =&gt; {    const node = document.getElementById(&apos;Node&apos;);    if(node) {        node.innerHTML = JSON.stringify(someResource));    }}, 1000);</code></pre><p>上面的例子中，我们每隔一秒就将得到的数据放入到文档节点中去。但在 setInterval 没有结束前，回调函数里的变量以及回调函数本身都无法被回收。那什么才叫结束呢？就是调用了 clearInterval。如果回调函数内没有做什么事情，并且也没有被 clear 掉的话，就会造成内存泄漏。不仅如此，如果回调函数没有被回收，那么回调函数内依赖的变量也没法被回收。上面的例子中，someResource 就没法被回收。同样的，setTiemout 也会有同样的问题。所以，当不需要 interval 或者 timeout 时，最好调用 clearInterval 或者 clearTimeout。</p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>在 IE8 以下的版本里，DOM 对象经常会跟 JavaScript 之间产生循环引用。看一个例子：</p><pre><code>function setHandler() {    const ele = document.getElementById(&apos;id&apos;);    ele.onclick = function() {};}</code></pre><p>在这个例子中，DOM 对象通过 onclick 引用了一个函数，然而这个函数通过外部的词法环境引用了这个 DOM 对象，形成了循环引用。不过现在不必担心，因为所有现代浏览器都采用了标记－整理方法，避免了循环引用的问题。</p><p>除了这种情况，我们现在还会在其他时候在使用 DOM 时出现内存泄漏的问题。当我们需要多次访问同一个 DOM 元素时，一个好的做法是将 DOM 元素用一个变量存储在内存中，因为访问 DOM 的效率一般比较低，应该避免频繁地反问 DOM 元素。所以我们会这样写：</p><pre><code>const button = document.getElementById(&apos;button&apos;);</code></pre><p>当删除这个按钮时：</p><pre><code>document.body.removeChild(document.getElementById(&apos;button&apos;));</code></pre><p>虽然这样看起来删除了这个 DOM 元素，但这个 DOM 元素仍然被 button 这个变量引用，所以在内存上，这个 DOM 元素是没法被回收的。所以在使用结束后，还需要将 button 设成 null。</p><p>另外一个值得注意的是，代码中保存了一个列表 ul 的某一项 li 的引用，将来决定删除整个列表时，我们自觉上会认为内存仅仅会保留那个特定的 li，而将其他列表项都删除。但事实并非如此，因为 li 是 ul 的子元素，子元素与父元素是引用关系，所以如果代码保存 li 的引用，那么整个 ul 将会继续呆在内存里。</p><h2 id="良好实践"><a href="#良好实践" class="headerlink" title="良好实践"></a>良好实践</h2><p>1、优化内存的一个最好的衡量方式就是只保留程序运行时需要的数据，对于已经使用的或者不需要的数据，应该将其值设为 null，这上面说过，叫“解除引用”。需要注意的是，解除一个值的引用不代表垃圾回收器会立即将这段内存回收，这样做的目的是让垃圾回收器在下一个回收周期到来时知道这段内存需要回收。</p><p>在内存泄漏部分，我们讨论了无意的全局变量会带来无法回收的内存垃圾。但有些时候，我们会有意识地声明一些全局变量，这个时候需要注意，如果声明的变量占用大量的内存，那么在使用完后将变量声明为 null。</p><p>2、减少内存垃圾的另一个方法就是避免创建对象。new Object() 是一个比较明显的创建对象的方式，另外 const arr = [];、const obj = {};也会创建新的对象。另外下面这种写法在每次调用函数时都会创建一个新的对象：</p><pre><code>function func() {    return function() {};}</code></pre><p>另外，当清空一个数组时，我们通常的做法是 array = []，但这种做法的背后是新建了一个新的数组然后将原来的数组当作内存垃圾。建议的做法是 array.length = 0，这样做不仅可以重用原来的变量，而且还避免创建了新的数组。</p><p>因为时间关系，关于垃圾回收的内容将在接下来1-2周内更新完毕，内容涉及更加详细的内存管理、V8 引擎中的垃圾回收等。另外对本文其他内容还有建议的也欢迎留言，我也会一并更新。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js数组去重</title>
      <link href="/257.html"/>
      <url>/257.html</url>
      
        <content type="html"><![CDATA[<p><strong>1.嵌套循环比较</strong></p><p>两层 for 循环，for 循环中每次从原数组中取出一个元素，用这个元素循环与结果数组对比。若结果数组中没有该元素，则存到结果数组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique_towFor = Array.prototype.unique_towFor || function()&#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    if(this.length &lt;= 0) return result;</span><br><span class="line">    result.push(this[0]);</span><br><span class="line">    for(var i = 1; i &lt; this.length; i++)&#123;</span><br><span class="line">        var notIn = true;</span><br><span class="line">        for(var你，m&apos;m j = 0; j &lt; result.length; j++)&#123;</span><br><span class="line">            if(this[i] == result[j])&#123;</span><br><span class="line">                notIn = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(notIn)&#123;</span><br><span class="line">            result.push(this[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.临时数组保存</strong></p><p>算法的基本思想，就是，把去重后的结果放在一个临时数组中，对原来数组的元素与临时数组元素比较，临时数组中不存在这个元素的，放入临时数组。</p><pre><code>Array.prototype.unique_tempArray = Array.prototype.unique_tempArray || function(){    var result = [];//临时数组    for(var i = 0; i &lt; this.length; i++){        if(result.indexOf(this[i]) == -1){            result.push(this[i]);        }    }    return result;}</code></pre><p><strong>3.利用对象去重(基础常用)</strong></p><p>创建一个新的数组存放结果，和一个空对象。for 循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值，存入到对象中。这个方法用作统计也很方便。</p><pre><code>Array.prototype.unique_objectArray = Array.prototype.unique_objectArray || function(){    var result = [];    var obj = {};    for(var i = 0; i &lt; this.length; i++){        if(!obj[this[i]]){            obj[this[i]] = 1;            result.push(this[i]);        }else{            obj[this[i]] ++;        }    }    return result;}</code></pre><p><strong>4.先排序，后去重</strong></p><p>先把数组排序，然后比较相邻的两个值。 排序的时候用的 JS 原生的 sort 方法，JS 引擎内部用的是快速排序，此方法速度比较快！无语中。</p><pre><code>Array.prototype.unique_sortArray = Array.prototype.unique_sortArray || function(){    this.sort();    var result = [this[0]];    for(var i = 1; i &lt; this.length; i++){        if(this[i] !== result[result.length - 1] ){            result.push(this[i]);        }    }    return result;}</code></pre><p><strong>5.利用 ES6 的 Set 对象和 Array.from 方法</strong></p><ul><li><p>Set 对象可以是任何类型的单个值的集合。它是 ES6 新增的有序列表集合，它不会包含重复项。之前我们通常用对象(Object)或者数组(Array)来实现没有重复项的集合。</p></li><li><p>Array.from()方法可以将一个类数组对象或可遍历对象转换成真正的数组。</p></li></ul><pre><code>Array.prototype.unique_es6SetArray = Array.prototype.unique_esSetArray || function(){    return Array.from(new Set(this));}</code></pre><p><strong>6.利用 filter 和 Map 对象</strong></p><p>filter()方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。</p><pre><code>Array.prototype.unique_filterArray = Array.prototype.unique_filterArray || function(){    return this.filter(function(item, index, arr){        return arr.indexOf(item) === index;    });}</code></pre><p>既然可以使用 filter 的方法，那么也可以使用 filter 加 object 的方法，这里使用 Map 对象。</p><pre><code>Array.prototype.unique_es6MapArray = Array.prototype.unique_es6MapArray || function(){    const seen = new Map();    return this.filter(function(item, index, arr){        !seen.has(item) &amp;&amp; seen.set(item, 1);    });}</code></pre><p>这里的 filter 函数可以简化，当然也有人这样写</p><pre><code>Array.prototype.unique_es6MapArray = Array.prototype.unique_es6MapArray || function(){    const seen = new Map();    return this.filter(        (a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1)    );}</code></pre><p><strong>7.使用第三方</strong></p><p>最后，可以使用第三方库函数 jquery 和 underscore 或者 lodash 下面以 lodash 和 underscore 为例</p><pre><code>Array.prototype.unique_3partyArray = Array.prototype.unique_3partyArray || function(){    return _.uniq(arr);//要先引入lodash.js或者underscore.js}</code></pre>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js判断变量是否是dom对象</title>
      <link href="/254.html"/>
      <url>/254.html</url>
      
        <content type="html"><![CDATA[<p>我们在写js代码时有时需要判断某个对象是不是DOM对象，然后再进行后续的操作，这里我给出一种兼容各大浏览器，同时又算是比较稳妥的一种方法。</p><p>要判断一个对象是否DOM对象，首先想到的无非就是它是否具有DOM对象的各种属性或特征，比如是否有nodeType属性，有tagName属性，等等。判断的特征越多，也就越可靠，因为毕竟我们自定义的js对象也可以有那些属性。还有其他方法吗?</p><p>在DOM Level2标准中定义了一个HTMLElement对象，它规定所有的DOM对象都是HTMLElement的实例，所以我们可以利用这点来判断一个对象是不是DOM对象:如果该对象是HTMLElement的实例，则它肯定是一个DOM对象。在不支持HTMLElement的浏览器中我们则还是使用特征检测法。</p><p>//首先要对HTMLElement进行类型检查，因为即使在支持HTMLElement的浏览器中，类型却是有差别的，在Chrome,Opera中HTMLElement的类型为function，此时就不能用它来判断了</p><pre><code>var isDOM = (typeof HTMLElement === &apos;object&apos;) ?    function (obj) {        return obj instanceof HTMLElement;    } :    function (obj) {        return obj &amp;&amp; typeof obj === &apos;object&apos; &amp;&amp; obj.nodeType === 1 &amp;&amp; typeof obj.nodeName === &apos;string&apos;;    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何用 JavaScript 下载文件</title>
      <link href="/244.html"/>
      <url>/244.html</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>我们知道，下载文件是一个非常常见的需求，但由于浏览器的安全策略的限制，我们通常只能通过一个额外的页面，访问某个文件的 url 来实现下载功能，但是这种用户体验非常不好。 幸好，HTML 5 里面为 <a> 标签添加了一个 download 的属性，我们可以轻易的利用它来实现下载功能，再也不需要用以前的笨办法了。</a></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们先看看 download 的使用方法：</p><pre><code>&lt;a href=&quot;http://somehost/somefile.zip&quot; download=&quot;filename.zip&quot;&gt;Download file&lt;/a&gt;</code></pre><p>看看上面的代码，只要为 <a> 标签添加 download 属性，我们点击这个链接的时候就会自动下载文件了~ 顺便说下，download 的属性值是可选的，它用来指定下载文件的文件名。像上面的例子中，我们下载到本地的文件名就会是 filename.zip 拉，如果不指定的话，它就会是 somefile.zip 这个名字拉！</a></p><p>看到这里，你可能会说，坑爹啊，这明明是用 HTML 5 的新特性来实现下载文件嘛，说好的用 JavaScript 下载文件呢？</p><p>事实上，用 JavaScript 来下载文件也是利用这一特性来实现的，我们的 JavaScript 代码不外乎就是：</p><ul><li>用 JavaScript 创建一个隐藏的 <a> 标签</a></li><li>设置它的 href 属性</li><li>设置它的 download 属性</li><li>用 JavaScript 来触发这个它的 click 事件</li></ul><p>翻译成 JavaScript 代码就是：</p><pre><code>var a = document.createElement(&apos;a&apos;);var url = window.URL.createObjectURL(blob);var filename = &apos;what-you-want.txt&apos;;a.href = url;a.download = filename;a.click();window.URL.revokeObjectURL(url);</code></pre><p>好拉，是不是看到有个陌生的东东呢？</p><h3 id="window-URL"><a href="#window-URL" class="headerlink" title="window.URL"></a>window.URL</h3><p>window.URL 里面有两个方法：</p><ul><li><strong>createObjectURL</strong> 用 blob 对象来创建一个 object URL(它是一个 DOMString)，我们可以用这个 object URL 来表示某个 blob 对象，这个 object URL 可以用在 href 和 src 之类的属性上。</li><li><strong>revokeObjectURL</strong> 释放由 createObjectURL 创建的 object URL，当该 object URL 不需要的时候，我们要主动调用这个方法来获取最佳性能和内存使用。</li></ul><p>知道了这两个方法之后，我们再回去看看上面的例子就很容易理解了吧！只是用 blob 对象来创建一条 URL，然后让 <a> 标签引用该 URL，然后触发个点击事件，就可以下载文件了！</a></p><p>那么问题来了，blob 对象哪里来？</p><h3 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h3><p>Blob 全称是 Binary large object，它表示一个类文件对象，可以用它来表示一个文件。根据 MDN 上面的说法，File API 也是基于 blob 来实现的。</p><p>由于本文的主题是讲 JavaScript 下载文件，那我们构建 blob 的方式就是通过服务器返回的文件来创建 blob 拉！</p><p>而最简单的方式就是用 fetch API 了，我们可以整合上面的例子：</p><pre><code>fetch(&apos;http://somehost/somefile.zip&apos;).then(res =&gt; res.blob().then(blob =&gt; {    var a = document.createElement(&apos;a&apos;);    var url = window.URL.createObjectURL(blob);    var filename = &apos;myfile.zip&apos;;    a.href = url;    a.download = filename;    a.click();    window.URL.revokeObjectURL(url);}))</code></pre><p>很简单对吧！</p><p>你可能会问，何必这么麻烦呢？直接写成下面这样不就好了：</p><pre><code>&lt;a href=&quot;http://somehost/somefile.zip&quot; download=&quot;myfile.zip&quot;&gt;Download file&lt;/a&gt;</code></pre><p>嗯，对于这种写法，我只能说，你做的太正确了！如果你要下载的是已经存在服务器上面的静态文件的话，那么写成这样是最方便的。浏览器会帮你处理整个下载过程，不需要你干涉。如果你用 blob 的方式来下载文件的话，会有下面这些限制的：</p><h4 id="限制一：不同浏览器对-blob-对象有不同的限制"><a href="#限制一：不同浏览器对-blob-对象有不同的限制" class="headerlink" title="限制一：不同浏览器对 blob 对象有不同的限制"></a>限制一：不同浏览器对 blob 对象有不同的限制</h4><p>具体看看下面这个表格（出自 <a href="https://github.com/eligrey/FileSaver.js#supported-browsers" target="_blank" rel="noopener">FileSaver.js</a>）</p><p>Browser</p><p>Constructs as</p><p>Filenames</p><p>Max Blob Size</p><p>Dependencies</p><p>Firefox 20+</p><p>Blob</p><p>Yes</p><p>800 MiB</p><p>None</p><p>Firefox &lt; 20</p><p>data: URI</p><p>No</p><p>n/a</p><p><a href="https://github.com/eligrey/Blob.js" target="_blank" rel="noopener">Blob.js</a></p><p>Chrome</p><p>Blob</p><p>Yes</p><p>[500 MiB][3]</p><p>None</p><p>Chrome for Android</p><p>Blob</p><p>Yes</p><p>[500 MiB][3]</p><p>None</p><p>Edge</p><p>Blob</p><p>Yes</p><p>?</p><p>None</p><p>IE 10+</p><p>Blob</p><p>Yes</p><p>600 MiB</p><p>None</p><p>Opera 15+</p><p>Blob</p><p>Yes</p><p>500 MiB</p><p>None</p><p>Opera &lt; 15</p><p>data: URI</p><p>No</p><p>n/a</p><p><a href="https://github.com/eligrey/Blob.js" target="_blank" rel="noopener">Blob.js</a></p><p>Safari 6.1+*</p><p>Blob</p><p>No</p><p>?</p><p>None</p><p>Safari &lt; 6</p><p>data: URI</p><p>No</p><p>n/a</p><p><a href="https://github.com/eligrey/Blob.js" target="_blank" rel="noopener">Blob.js</a></p><p>Safari 10.1+  </p><p>Blob        </p><p>Yes        </p><p>n/a          </p><p>None</p><h4 id="限制二：构建完-blob-对象后才会转换成文件"><a href="#限制二：构建完-blob-对象后才会转换成文件" class="headerlink" title="限制二：构建完 blob 对象后才会转换成文件"></a>限制二：构建完 blob 对象后才会转换成文件</h4><p>这一点限制对小文件(几十kb)可能没什么影响，但对稍微大一点的文件影响就很大了。试想，用户要下载一个 100mb 的文件，如果他点击了下载按钮之后没看到下载提示的话，他肯定会继续按，等他按了几次之后还没看到下载提示时，他就会抱怨我们的网站，然后离开了。</p><p>然而事实上下载的的确确发生了，只是要等到下载完文件之后才能构建 blob 对象，再转化成文件。而且，用户再触发多几次下载就会造成一些资源上的浪费。</p><p>因此，如果是要下载大文件的话，还是推荐直接创建一个 <a> 标签拉~</a></p><p>写 html 也好，写 JavaScript 动态创建也好，用自己喜欢的方式去创建就好了。</p><h3 id="为什么要用-JavaScript-下载文件"><a href="#为什么要用-JavaScript-下载文件" class="headerlink" title="为什么要用 JavaScript 下载文件"></a>为什么要用 JavaScript 下载文件</h3><p>好拉，说了半天，其实我们一直说的都是：「不要用 JavaScript 下载文件拉，限制多多，又不好用，直接用 html 就好拉，简单方便又快捷」这个论调。</p><p>事实上也确实如此，但有些时候我们确实需要通过 JavaScript 来做一些预处理。</p><h4 id="权限校验"><a href="#权限校验" class="headerlink" title="权限校验"></a>权限校验</h4><p>有些时候，我们需要对下载做一些限制，最常见的就是权限校验了，如检查该用户是否有下载的权限，是否有高速下载的权限等等。</p><p>这时候，我们可以利用 JavaScript 做一些预处理。如：</p><pre><code>fetch(&apos;http://somehost/check-permission&apos;, options).then(res =&gt; {    if (res.code === 0) {        var a = document.createElement(&apos;a&apos;);        var url = res.data.url;        var filename = &apos;myfile.zip&apos;;        a.href = url;        a.download = filename;        a.click();    } else {        alert(&apos;You have no permission to download the file!&apos;);    }});</code></pre><p>在这个例子里面，我们没有用 blob 来构建 URL，而是通过后端服务器来计算出用户的下载链接，然后再利用之前提到的动态创建 <a> 标签的方式来实现下载，很简单吧！</a></p><h4 id="动态文件"><a href="#动态文件" class="headerlink" title="动态文件"></a>动态文件</h4><p>动态生成文件然后返回给客户端也是一个很常见的需求，譬如我们有时候需要做导出数据的功能，把数据库中的某些数据导出到 Excel 中，然后再返回客户端。</p><p>这时候我们就不能简单的指定 href 属性，因为对应的 URL 并不存在。</p><p>我们只能通过 JavaScript 对服务器发出一个请求，通知它去生成某个文件，然后把对应的 URL 返回给客户端。</p><p>有没有感觉这个过程和上面「权限校验」一节很像？肯定拉，因为我们只是对 URL 做了一些预处理而已嘛~</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于 download 属性是 HTML 5 的新特性，因此它不支持旧版本的浏览器。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HTML 5 新的 download 特性真的很好用，结合 JavaScript 的动态能力我们可以很方便的做出复杂的下载功能~</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 中神奇的 this</title>
      <link href="/240.html"/>
      <url>/240.html</url>
      
        <content type="html"><![CDATA[<h2 id="误以为-this-指向函数自身"><a href="#误以为-this-指向函数自身" class="headerlink" title="误以为 this 指向函数自身"></a>误以为 this 指向函数自身</h2><p>根据 this 的英语语法，很容易将函数中出现的 <strong>this</strong> 理解为函数自身。在 javascript 当中函数作为一等公民，确实可以在调用的时候将属性值存储起来。但是如果使用方法不对，就会发生与实际预期不一致的情况。具体情况，请看下面代码:</p><pre><code>function fn(num){    this.count++;}fn.count = 0;for(var i=0;i&lt;3;i++){    fn(i);}console.log(fn.count); // 0</code></pre><p>如果 fn 函数里面的 this 指向自身函数，那么 count 属性的属性值就应该产生变化，但实际上却是纹丝不动。对于这个问题，有些人会利用作用域来解决，比如这么写:</p><pre><code>var data = {    count:0};function fn(num){    data.count++;}for(var i=0;i&lt;3;i++){    fn(i);}console.log(data.count);    //3</code></pre><p>又或者更直接的这么写:</p><pre><code>function fn(num){    fn.count++;}fn.count = 0;for(var i=0;i&lt;3;i++){    fn(i);}console.log(fn.count);//3</code></pre><p>虽然这两种方式都输出了正确的结果，但是却避开了 this 到底绑定在哪里的问题。如果对一个事物的工作原理不清晰，就往往会产生头痛治头，脚痛治脚的问题，从而导致代码变得的丑陋，而且维护性也会变得很差。</p><h2 id="this神奇的绑定规则"><a href="#this神奇的绑定规则" class="headerlink" title="this神奇的绑定规则"></a>this神奇的绑定规则</h2><h3 id="1-默认绑定规则"><a href="#1-默认绑定规则" class="headerlink" title="1.默认绑定规则"></a>1.默认绑定规则</h3><p>1.1 全局环境中，this默认绑定到window</p><pre><code>console.log(this === window);//true</code></pre><p>1.2 函数独立调用时，this默认绑定到window</p><pre><code>function fn(){    console.log(window === this); //浏览器环境}fn(); //true</code></pre><p>函数 fn 是直接在全局作用域下调用的，没有带其他任何修饰，这种情况下，函数调用的时候使用了 this 的默认绑定，指向了全局对象。</p><p>fn 函数中的 this 指向了全局变量，所以 this.count++ 相当于 window.count++(浏览器环境下)，当然不会对 fn 函数的count属性产生影响。</p><p>有一点要说明的是，上面种情况只能在非严格模式(strict mode)下才能发生，在严格模式下，会将 this 默认绑定为 undefined。以避免全局变量的污染。</p><p>1.3 被嵌套的函数独立调用时，this默认绑定到window</p><pre><code>//虽然test()函数被嵌套在obj.foo()函数中，但test()函数是独立调用，而不是方法调用。所以this默认绑定到windowvar a = 0;var obj = {    a : 2,    foo:function(){            function test(){                console.log(this.a);            }            test();    }}obj.foo();//0</code></pre><p>1.4 IIFE(立即执行函数)实际上是函数声明后直接调用执行</p><pre><code>var a = 0;function foo(){    (function test(){        console.log(this.a);    })()};var obj = {    a : 2,    foo:foo}obj.foo();//0//等价于上例var a = 0;var obj = {    a : 2,    foo:function(){            function test(){                console.log(this.a);            }            test();    }}obj.foo();//0</code></pre><p>1.5 [闭包]类似地，test()函数是独立调用，而不是方法调用，所以this默认绑定到window</p><pre><code>var a = 0;function foo(){    function test(){        console.log(this.a);    }    return test;};var obj = {    a : 2,    foo:foo}obj.foo()();//0</code></pre><h3 id="2-隐式绑定规则"><a href="#2-隐式绑定规则" class="headerlink" title="2.隐式绑定规则"></a>2.隐式绑定规则</h3><p>如果函数在以对象为上下文进行调用，那么 this 的绑定就会产生变化。this 会绑定到调用这个函数的对象，查看下面代码：</p><pre><code>var obj = {    a:1,    fn:function(){        console.log(this.a);    }}obj.fn(); //1</code></pre><p>即使函数声明不在对象当中，this 指向仍会产生变化:</p><pre><code>function fn(){    console.log(this.a);}var obj = {    a:1,    fn:fn}obj.fn(); //1</code></pre><p>由此可见，this 的绑定，不与函数定义的位置有关，而是与调用者和调用方式有关。</p><p>在隐式的绑定规则下，有一些特殊的地方，需要注意。</p><p><strong>2.1 多层对象调用 this 的指向</strong></p><pre><code>function fn(){    console.log(this.a);}var obj3 = {    a:3,    fn:fn}var obj2 = {    a:2,    obj3:obj3}var obj = {    a:1,    obj2:obj2}obj.obj2.obj3.fn(); //3</code></pre><p>在多层对象引用下，this 指向的是调用的函数的那个对象。</p><p><strong>2.2 隐式赋值可能存在丢失现象</strong></p><p>2.2.1 [函数别名]</p><pre><code>var a = 0;function foo(){    console.log(this.a);};var obj = {    a : 2,    foo:foo}//把obj.foo赋予别名bar，造成了隐式丢失，因为只是把foo()函数赋给了bar，而bar与obj对象则毫无关系var bar = obj.foo;bar();//0//等价于var a = 0;var bar = function foo(){    console.log(this.a);}bar();//0</code></pre><p>虽然 bar 引用了 obj.foo ，但是函数的调用方式，仍是不带任何修饰的，所以 this 还是绑定在了 window 上。</p><p>2.2.2 [参数传递]</p><pre><code>var a = 0;function foo(){    console.log(this.a);};function bar(fn){    fn();}var obj = {    a : 2,    foo:foo}//把obj.foo当作参数传递给bar函数时，有隐式的函数赋值fn=obj.foo。与上例类似，只是把foo函数赋给了fn，而fn与obj对象则毫无关系bar(obj.foo);//0//等价于var a = 0;function bar(fn){    fn();}bar(function foo(){    console.log(this.a);});</code></pre><p>2.2.3 [内置函数]</p><pre><code>var a = 0;function foo(){    console.log(this.a);};var obj = {    a : 2,    foo:foo}setTimeout(obj.foo,100);//0//等价于var a = 0;setTimeout(function foo(){    console.log(this.a);},100);//0</code></pre><p>隐式绑定 this 不是一种很推荐的方式，因为很有可能就发生丢失的情况，如果业务当中对 this 的绑定有要求，建议还是使用显示绑定的方式。</p><h3 id="3-显式绑定规则"><a href="#3-显式绑定规则" class="headerlink" title="3.显式绑定规则"></a>3.显式绑定规则</h3><p>显示绑定就是利用函数原型上的 apply 与 call 方法来对 this 进行绑定。用法就是把想要绑定的对象作为第一个参数传进去。</p><pre><code>function fn(){    console.log(this);}var obj = {};fn.call(obj); //{}    </code></pre><p>有些时候会想将函数的 this 绑定在某个对象上，但是不需要立即调用，这样的话，直接利用 call 或者 apply 是无法做的。</p><pre><code>function fn(){    console.log(this);}function bind(fn){    fn();}var obj = {    fn:fn}bind.call(obj,fn); //window</code></pre><p>上面这个例子，看似好像可以，但实际上是 bind 函数的 this 绑定到了 obj 这个对象，但是 fn 仍然是没有任何修饰的调用，所以 fn 仍然是默认的绑定方式。</p><pre><code>function fn(){    console.log(this);}function bind(fn,obj){    return function(){        fn.apply(obj,arguments);    }}var obj = {    fn:fn}var fun = bind(fn,obj);fun(); //obj</code></pre><p>这样调用，就可以将灵活多变的 this ，牢牢的控制住了，因为 fn 的调用方式为 apply 调用。所以，this 就被绑定在传入的 obj 对象上，在 ES5 当中，函数的原型方法上多了一个 bind。效果与上面的函数基本一致，具体用法限于篇幅就不多说了。</p><h3 id="4-new-绑定"><a href="#4-new-绑定" class="headerlink" title="4.new 绑定"></a>4.new 绑定</h3><p>new 是一个被很多人误解的一个关键字，但实际上 javascript 的 new 与传统面向对象的语言完全不同。 个人把 new 理解为一种特殊的函数调用，当使用 new 关键字来调用函数的时候，会执行下面操作:</p><ol><li><p>创建一个全新的对象</p></li><li><p>将空对象的 <strong>proto</strong> 指向构造函数的 prototype</p></li><li><p>将新对象的 this 绑定到调用的函数上.</p></li><li><p>如果函数返回值为基本类型或者为 this又或者不返回任何值，那么将会返回这个创建的新对象，如果返回了一个对象，那么则会返回这个对象，而不会返回创建的新对象。</p><p>function fn(a){</p><pre><code>this.a = a;</code></pre><p>}fn.prototype.hi = function(){</p><pre><code>console.log(&apos;hi&apos;)</code></pre><p>}</p><p>var obj = new fn(2);</p><p>console.log(obj);</p></li></ol><h3 id="5-特殊的传参"><a href="#5-特殊的传参" class="headerlink" title="5.特殊的传参"></a>5.特殊的传参</h3><p>null 和 undefined 也是可以作为 this 的绑定对象的，但是实际上应用的是默认的绑定。 但是这种传参的实际效用是什么呢？ 常见的用法是将一个数组展开，作为参数传入参数。比如</p><pre><code>function fn(a,b){    console.log(&apos;a:&apos;,a,&apos;b:&apos;,b);}fn.apply(null,[1,2]); // a: 1 b: 2</code></pre><p>但是这种用法会有一个坑，那就是如果函数存在了 this ，那么就会应用默认的绑定规则，将 this 绑定在全局对象上，发生于预期不一致的情况。为了代码更加稳健，可以使创建一个比空对象更空的对象。</p><pre><code>var obj = Object.create(null);console.log(obj.__proto__); //undefinedvar obj2 = {}console.log(obj2.__proto__); //Object {}</code></pre><p>Object原型上有一个 create 方法，这个方法会创建一个对象，然后将对象的原型指向传入的参数，所以传入 null 的话，产生一个没有 prototype 的对象，所以会比空对象更加”空”。</p><p>所以传入这个对象，会比传入 null 更加安全。</p><pre><code>var obj = Object.create(null);fn.apply(obj,[1,2]);</code></pre><h3 id="6-根据作用域来决定-this-的绑定"><a href="#6-根据作用域来决定-this-的绑定" class="headerlink" title="6.根据作用域来决定 this 的绑定"></a>6.根据作用域来决定 this 的绑定</h3><p>在 ES6 当中，出现了一个新的函数类型，箭头函数。</p><p>如果使用箭头函数，那么就不会使用上面提到的四种 this 绑定方式，而是根据作用域来决定</p><p>比较常见的是用于事件函数和定时器的情况。</p><p>下面是比较常见的传统 this 写法:</p><pre><code>function fn(){    var _this = this;    setTimeout(function(){        console.log(_this.a);    },100)}var obj = {    a:2}fn.call(obj); //2</code></pre><p>如果使用箭头函数则可以这么写:</p><pre><code>function fn(){    setTimeout(()=&gt;{        //this 来源于 fn 函数的作用域        console.log(this.a);    },100)}var obj = {    a:2}fn.call(obj); //2</code></pre><h3 id="7-事件函数当中-this-的绑定机制"><a href="#7-事件函数当中-this-的绑定机制" class="headerlink" title="7.事件函数当中 this 的绑定机制"></a>7.事件函数当中 this 的绑定机制</h3><p>如果是在事件函数当中，this 的绑定是指向触发事件的 DOM 元素的，</p><pre><code>$(&apos;body&apos;)[0].addEventListener(&apos;click&apos;,function(){    console.log(this);},false);</code></pre><p>点击 body 元素之后，控制台则会显示 body 元素。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果想判断一个函数的 this 绑定在哪里，首先是找到函数的调用位置，之后是按照规则来判断。</p><ul><li>如果函数调用时没有任何修饰条件，那么在严格模式下则会绑定到 undefined ，非严格模式下会绑定到全局。</li><li>如果是用对象做上下文，来对函数进行调用，那么则会绑定到调用的这个对象上。</li><li>如果是用 call 或者 apply 方法来进行调用的，则会绑定到第一个传入参数上。</li><li>如果是使用 new 关键字来调用函数的，则会绑定到新创建的那个对象上.</li><li>如果是在事件函数内，则会绑定到触发事件的那个DOM元素上。</li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript类型识别</title>
      <link href="/237.html"/>
      <url>/237.html</url>
      
        <content type="html"><![CDATA[<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><blockquote><p>javascript 类型系统可以分为标准类型和对象类型，进一步标准类型又可以分为原始类型和引用类型，而对象类型又可以分为内置对象类型、普通对象类型、自定义对象类型。</p></blockquote><p><img src="http://cdn.flqin.com/p237-1.jpeg" alt></p><h3 id="类型转化表"><a href="#类型转化表" class="headerlink" title="类型转化表"></a>类型转化表</h3><p><img src="http://cdn.flqin.com/p237-2.png" alt></p><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><ul><li>typeof</li><li>instanceof</li><li>Object.prototype.toString</li><li>constructor</li></ul><p><strong>typeof</strong></p><ul><li><p>可以识别标准类型(null除外)</p></li><li><p>不可识别具体的对象类型(Function除外)</p><p>//1. 可以识别标准类型(<code>null</code>除外)<br>typeof(1);//“number”<br>typeof(“”);//“string”<br>typeof(undefined);//“undefined”<br>typeof(true);//“boolean”<br>typeof(null);//“object”</p><p>//2. 不可识别具体的对象类型(<code>Function</code>除外)<br>typeof([]);//“object”<br>typeof({});//“object”<br>typeof(function(){});//“function”</p></li></ul><p><strong>instanceof</strong></p><blockquote><p>instanceof左侧为查询变量,右侧为标识对象的类</p></blockquote><ul><li><p>能够判别内置对象类型</p></li><li><p>不能判别原始类型</p></li><li><p>能够判别自定义类型</p><p>//1. 能够判别内置对象类型<br>[] instanceof Array;//true<br>/\d/ instanceof RegExp;//true</p><p>//2. 不能判别原始类型<br>1 instanceof Number;//false<br>“xiaohong” instanceof String;//false</p><p>//3. 能够判别自定义类型<br>function Point(x, y) {</p><pre><code>this.x = x;this.y = y;</code></pre><p>}var c = new Point(2,3);</p><p>c instanceof Point;//true</p></li></ul><p><strong>Object.prototype.toString.call()方法</strong></p><ul><li><p>可以识别标准类型,及内置对象类型</p></li><li><p>不能识别自定义类型</p><p>//1. 可以识别标准类型,及内置对象类型<br>Object.prototype.toString.call(21);//“[object Number]”<br>Object.prototype.toString.call([]);//“[object Array]”<br>Object.prototype.toString.call(/[A-Z]/);//“[object RegExp]”</p><p>//2. 不能识别自定义类型<br>function Point(x, y) {</p><pre><code>this.x = x;this.y = y;</code></pre><p>}</p><p>var c = new Point(2,3);//c instanceof Point;//true<br>Object.prototype.toString.call(c);//“[object Object]”</p></li></ul><p>为了方便使用,使用函数封装如下:</p><pre><code>function typeProto(obj) {    return Object.prototype.toString.call(obj).slice(8,-1);}typeProto(&quot;guo&quot;);//&quot;String&quot;typeProto({});//&quot;Object&quot;</code></pre><p><strong>constructor</strong></p><blockquote><p>constructor指向构造这个对象的构造函数本身..</p></blockquote><ul><li><p>可识别原始类型</p></li><li><p>可识别内置对象类型</p></li><li><p>可识别自定义类型</p><p>//1. 可识别原始类型<br>“guo”.constructor === String;//true<br>(1).constructor === Number;//true<br>true.constructor === Boolean;//true<br>({}).constructor === Object;//true</p><p>//2. 可识别内置对象类型<br>new Date().constructor === Date;//true<br>[].constructor === Array;//true</p><p>//3. 可识别自定义类型<br>function People(x, y) {</p><pre><code>this.x = x;this.y = y;</code></pre><p>}var c = new People(2,3);<br>c.constructor===People;//true</p></li></ul><p>为了方便使用,使用函数封装如下:</p><pre><code>function getConstructorName(obj) {    return obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor.toString().match(/function\s*([^(]*)/)[1];}getConstructorName(new Date());//&quot;Date&quot;getConstructorName(null);//nullgetConstructorName(12);//&quot;Number&quot;</code></pre><h2 id="类型判断对比表"><a href="#类型判断对比表" class="headerlink" title="类型判断对比表"></a>类型判断对比表</h2><p>其中红色的单元格表示该判断方式不支持的类型。</p><p><img src="http://cdn.flqin.com/p237-3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈JavaScript中的接口</title>
      <link href="/235.html"/>
      <url>/235.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>接口是面向对象JavaScript程序员的工具箱中最有用的工具之一。在设计模式中提出的可重用的面向对象设计的原则之一就是“针对接口编程而不是实现编程”，即我们所说的面向接口编程，这个概念的重要性可见一斑。但问题在于，在JavaScript的世界中，没有内置的创建或实现接口的方法，也没有可以判断一个对象是否实现了与另一个对象相同的一套方法，这使得对象之间很难互换使用，好在JavaScript拥有出色的灵活性，这使得模拟传统面向对象的接口，添加这些特性并非难事。接口提供了一种用以说明一个对象应该具有哪些方法的手段，尽管它可以表明这些方法的含义，但是却不包含具体实现。有了这个工具，就能按对象提供的特性对它们进行分组。例如，假如A和B以及接口I，即便A对象和B对象有极大的差异，只要他们都实现了I接口，那么在A.I(B)方法中就可以互换使用A和B，如B.I(A)。还可以使用接口开发不同的类的共同性。如果把原本要求以一个特定的类为参数的函数改为要求以一个特定的接口为参数的函数，那么所有实现了该接口的对象都可以作为参数传递给它，这样一来，彼此不相关的对象也可以被相同地对待。</p><h3 id="接口的利与弊"><a href="#接口的利与弊" class="headerlink" title="接口的利与弊"></a>接口的利与弊</h3><p>既定的接口具有自我描述性，并能够促进代码的重用性，接口可以提供一种信息，告诉外部一个类需要实现哪些方法。还有助于稳定不同类之间的通信方式，减少了继承两个对象的过程中出现的问题。这对于调试也是有帮助的，在JavaScript这种弱类型语言中，类型不匹配很难追踪，使用接口时，如果出现了问题，会有更明确的错误提示信息。当然接口并非完全没有缺点，如果大量使用接口会一定程度上弱化其作为弱类型语言的灵活性，另一方面，JavaScript并没有对接口的内置的支持，只是对传统的面向对象的接口进行模拟，这会使本身较为灵活的JavaScript变得更加难以驾驭。此外，任何实现接口的方式都会对性能造成影响，某种程度上归咎于额外的方法调用开销。接口使用的最大的问题在于，JavaScript不像是其他的强类型语言，如果不遵守接口的约定，就会编译失败，其灵活性可以有效地避开上述问题，如果是在协同开发的环境下，其接口很有可能被破坏而不会产生任何错误，也就是不可控性。</p><p>在面向对象的语言中，使用接口的方式大体相似。接口中包含的信息说明了类需要实现的方法以及这些方法的签名。类的定义必须明确地声明它们实现了这些接口，否则是不会编译通过的。显然在JavaScript中我们不能如法炮制，因为不存在interface和implement关键字，也不会在运行时对接口是否遵循约定进行检查，但是我们可以通过辅助方法和显式地检查模仿出其大部分特性。</p><h3 id="在JavaScript中模仿接口"><a href="#在JavaScript中模仿接口" class="headerlink" title="在JavaScript中模仿接口"></a>在JavaScript中模仿接口</h3><p>在JavaScript中模仿接口主要有三种方式：通过注释、属性检查和鸭式辩型法，以上三种方式有效结合，就会产生类似接口的效果。</p><p>注释是一种比较直观地把与接口相关的关键字（如interface、implement等）与JavaScript代码一同放在注释中来模拟接口，这是最简单的方法，但是效果最差。代码如下：</p><pre><code>//以注释的形式模仿描述接口/*interface Composite{    function add(child);    function remove(child);    function getName(index);}interface FormItem{    function save();}*///以注释的形式模仿使用接口关键字var CompositeForm =function(id , method,action) { //implements Composite , FormItem    // do something}//模拟实现具体的接口方法 此处实现Composite接口CompositeForm.prototype.Add=function(){    // do something}CompositeForm.prototype.remove=function(){    // do something}CompositeForm.prototype.getName=function(){    // do something}//模拟实现具体的接口方法 此处实现FormItem接口Composite.prototype.save=function(){    // do something}</code></pre><p>这种方式其实并不是很好，因为这种模仿还只停留在文档规范的范畴，开发人员是否会严格遵守该约定有待考量，对接口的遵守完全依靠开发人员的自觉性。另外，这种方式并不会去检查某个函数是否真正地实现了我们约定的“接口”。尽管如此，这种方式也有优点，它易于实现而不需要额外的类或者函数，可以提高代码的可重用性，因为类实现的接口都有注释说明。这种方式不会影响到文件占用的空间或执行速度，因为注释的代码可以在部署的时候轻松剔除。但是由于不会提供错误消息，它对测试和调试没什么帮助。下面的一种方式会对是否实现接口进行检查，代码如下：</p><pre><code>//以注释的形式模仿使用接口关键字var CompositeForm =function(id , method,action) { //implements Composite , FormItem    // do something    this.implementsinterfaces=[&apos;Composite&apos;,&apos;FormItem&apos;]; //显式地把接口放在implementsinterfaces中}//检查接口是否实现function implements(Object){    for(var i=0 ;i&lt; arguments.length;i++){        var interfaceName=arguments[i];        var interfaceFound=false;        for(var j=0;j&lt;Object.implementsinterfaces.length;j++){            if(Object.implementsinterfaces[j]==interfaceName){                interfaceFound=true;                break;            }        }        if(!interfaceFound){            return false;        }else{            return true;        }    }}function AddForm(formInstance){    if(!implements(formInstance,&apos;Composite&apos;,&apos;FormItem&apos;)){         throw new Error(&apos;Object does not implements required interface!&apos;);    }}</code></pre><p>上述代码是在方式一的基础上进行完善，在这个例子中，CompositeForm宣称自己实现了Composite和FormItem这两个接口，其做法是把这两个接口的名称加入一个implementsinterfaces的数组。显式地声明自己支持什么接口。任何一个要求其参数属性为特定类型的函数都可以对这个属性进行检查，并在所需要的接口未在声明之中时抛出错误。这种方式相对于上一种方式，多了一个强制性的类型检查。但是这种方法的缺点在于它并未保证类真正地实现了自称实现的接口，只是知道它声明自己实现了这些接口。其实类是否声明自己支持哪些接口并不重要，只要它具有这些接口中的方法就行。鸭式辩型（像鸭子一样走路并且嘎嘎叫的就是鸭子）正是基于这样的认识，它把对象实现的方法集作为判断它是不是某个类的实例的唯一标准。这种技术在检查一个类是否实现了某个接口时也可以大显身手。这种方法的背后观点很简单：如果对象具有与接口定义的方法同名的所有方法，那么就可以认为它实现了这个接口。可以使用一个辅助函数来确保对象具有所有必需的方法，代码如下：</p><pre><code>//interfacevar Composite =new Interface(&apos;Composite&apos;,[&apos;add&apos;,&apos;remove&apos;,&apos;getName&apos;]);var FormItem=new Interface(&apos;FormItem&apos;,[&apos;save&apos;]);//classvar Composite=function(id,method,action){}//Common Methodfunction AddForm(formInstance){    ensureImplements(formInstance,Composite,FormItem);    //如果该函数没有实现指定的接口，这个函数将会报错}</code></pre><p>与另外两种方式不同，这种方式无需注释，其余的各个方面都是可以强制实施的。EnsureImplements函数需要至少两个参数。第一个参数是想要检查的对象，其余的参数是被检查对象的接口。该函数检查器第一个参数代表的对象是否实现了那些接口所声明的方法，如果漏掉了任何一个，就会抛错，其中会包含被遗漏的方法的有效信息。这种方式不具备自我描述性，需要一个辅助类和辅助函数来帮助实现接口检查，而且它只关心方法名称，并不检查参数的名称、数目或类型。</p><h3 id="Interface类"><a href="#Interface类" class="headerlink" title="Interface类"></a>Interface类</h3><p>在下面的代码中，对Interface类的所有方法的参数都进行了严格的控制，如果参数没有验证通过，那么就会抛出异常。加入这种检查的目的就是，如果在执行过程中没有抛出异常，那么就可以肯定接口得到了正确的声明和实现。</p><pre><code>var Interface = function(name ,methods){    if(arguments.length!=2){        throw new Error(&apos;2 arguments required!&apos;);    }    this.name=name;    this.methods=[];    for(var i=0;len=methods.length;i&lt;len;i++){        if(typeof(methods[i]!==&apos;String&apos;)){            throw new Error(&apos;method name must be String!&apos;);        }        this.methods.push(methods[i]);    }}Interface.ensureImplements=function(object){    if(arguments.length&lt;2){        throw new Error(&apos;2 arguments required at least!&apos;);    }    for(var i=0;len=arguments.length;i&lt;len;i++){        var interface=arguments[i];        if(interface.constructor!==Interface){            throw new Error(&apos;instance must be Interface!&apos;);        }        for(var j=0;methodLength=interface.methods.length;j&lt;methodLength;j++){            var method=interface.methods[j];            if(!object[method]||typeof(object[method])==&apos;function&apos;)){                throw new Error(&apos;object does not implements method!&apos;);            }            }    }}</code></pre><p>其实多数情况下，接口并不是经常被使用的，严格的类型检查并不总是明智的。但是在设计复杂的系统的时候，接口的作用就体现出来了，这看似降低了灵活性，却同时也降低了耦合性，提高了代码的重用性。这在大型系统中是比较有优势的。在下面的例子中，声明了一个displayRoute方法，要求其参数具有三个特定的方法，通过Interface对象和ensureImplements方法来保证这三个方法的实现，否则将会抛出错误。</p><pre><code>//声明一个接口，描述该接口包含的方法 var DynamicMap=new Interface{&apos;DynamicMap&apos;,[&apos;centerOnPoint&apos;,&apos;zoom&apos;,&apos;draw&apos;]}; //声明一个displayRoute方法 function displayRoute(mapInstance){    //检验该方法的map    //检验该方法的mapInsstance是否实现了DynamicMap接口，如果未实现则会抛出    Interface.ensureImplements(mapInstance,DynamicMap);    //如果实现了则正常执行    mapInstance.centerOnPoint(12,22);    mapInstance.zoom(5);    mapInstance.draw(); }</code></pre><p>下面的例子会将一些数据以网页的形式展现出来，这个类的构造器以一个TestResult的实例作为参数。该类会对TestResult对象所包含的数据进行格式化（Format）后输出，代码如下：</p><pre><code>var ResultFormatter=function(resultObject){     //对resultObject进行检查，保证是TestResult的实例     if(!(resultObject instanceof TestResult)){         throw new Error(&apos;arguments error!&apos;);     }     this.resultObject=resultObject; } ResultFormatter.prototype.renderResult=function(){     var dateOfTest=this.resultObject.getData();     var resultArray=this.resultObject.getResults();     var resultContainer=document.createElement(&apos;div&apos;);     var resultHeader=document.createElement(&apos;h3&apos;);     resultHeader.innerHTML=&apos;Test Result from &apos;+dateOfTest.toUTCString();     resultContainer.appendChild(resultHeader);     var resultList=document.createElement(&apos;ul&apos;);     resultContainer.appendChild(resultList);     for(var i=0;len=resultArray.length;i&lt;len;i++){         var listItem=document.createElement(&apos;li&apos;);         listItem.innerHTML=resultArray[i];         resultList.appendChild(&apos;listItem&apos;);     }     return resultContainer; }</code></pre><p>该类的构造器会对参数进行检查，以确保其的确为TestResult的类的实例。如果参数达不到要求，构造器将会抛出一个错误。有了这样的保证，在编写renderResult方法的时候，就可以认定有getData和getResult两个方法。但是，构造函数中，只对参数的类型进行了检查，实际上这并不能保证所需要的方法都得到了实现。TestResult类会被修改，致使其失去这两个方法，但是构造器中的检查依旧会通过，只是renderResult方法不再有效。</p><p>此外，构造器中的这个检查施加了一些不必要的限制。它不允许使用其他的类的实例作为参数，否则会直接抛错，但是问题来了，如果有另一个类也包含并实现了getData和getResult方法，它本来可以被ResultFormatter使用，却因为这个限制而无用武之地。</p><p>解决问题的办法就是删除构造器中的校验，并使用接口代替。我们采用这个方案对代码进行优化：</p><pre><code>//接口的声明var resultSet =new Interface(&apos;ResultSet&apos;,[&apos;getData&apos;,&apos;getResult&apos;]);//修改后的方案 var ResultFormatter =function(resultObject){     Interface.ensureImplements(resultObject,resultSet);     this.resultObject=resultObject; }</code></pre><p>上述代码中，renderResult方法保持不变，而构造器却采用的ensureImplements方法，而不是typeof运算符。现在的这个构造器可以接受任何符合接口的类的实例了。</p><h3 id="依赖于接口的设计模式"><a href="#依赖于接口的设计模式" class="headerlink" title="依赖于接口的设计模式"></a>依赖于接口的设计模式</h3><p><strong>&lt;1&gt;工厂模式：</strong>对象工厂所创建的具体对象会因具体情况而不同。使用接口可以确保所创建的这些对象可以互换使用，也就是说对象工厂可以保证其生产出来的对象都实现了必需的方法；</p><p><strong>&lt;2&gt;组合模式：</strong>如果不使用接口就不可能使用这个模式，其中心思想是可以将对象群体与其组成对象同等对待。这是通过接口来做到的。如果不进行鸭式辩型或类型检查，那么组合模式就会失去大部分意义;</p><p><strong>&lt;3&gt;装饰者模式：</strong>装饰者通过透明地为另一个对象提供包装而发挥作用。这是通过实现与另外那个对象完全一致的接口实现的。对于外界而言，一个装饰者和它所包装的对象看不出有什么区别，所以使用Interface来确保所创建的装饰者实现了必需的方法;</p><p><strong>&lt;4&gt;命令模式：</strong>代码中所有的命令对象都有实现同一批方法（如run、ecxute、do等）通过使用接口，未执行这些命令对象而创建的类可以不必知道这些对象具体是什么，只要知道他们都正确地实现了接口即可。借此可以创建出模块化程度很高的、耦合度很低的API。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数声明、函数表达式等浅析</title>
      <link href="/230.html"/>
      <url>/230.html</url>
      
        <content type="html"><![CDATA[<p>javascript和其他编程语言相比比较随意，所以javascript代码中充满各种奇葩的写法，有时雾里看花，当然，能理解各型各色的写法也是对javascript语言特性更进一步的深入理解。</p><h3 id="函数基本概念"><a href="#函数基本概念" class="headerlink" title="函数基本概念"></a>函数基本概念</h3><ul><li><strong>函数声明(function declaration)</strong> function fnName () {…};使用function关键字声明一个函数，再指定一个函数名，叫函数声明。</li><li><strong>匿名函数(Anonymous Function)</strong> function () {}; 使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数。</li><li><strong>函数表达式(function expression)</strong> var fnName = function () {…};将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。</li></ul><p><strong>匿名函数</strong></p><p>匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。</p><p><strong>函数声明和函数表达式区别</strong></p><p>1.Javascript引擎在解析javascript代码时会‘函数声明提升’（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式。</p><pre><code>fnName();function fnName(){    ...}//正常，因为‘提升&apos;了函数声明，函数调用可在函数声明之前fnName();var fnName=function(){    ...}//报错，变量fnName还未保存对函数的引用，函数调用必须在函数表达式之后</code></pre><p>2.函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用 。</p><pre><code>var fnName=function(){    alert(&apos;Hello World&apos;);}();//函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数function fnName(){    alert(&apos;Hello World&apos;);}();//不会报错，但是javascript引擎只解析函数声明，忽略后面的括号，函数声明不会被调用function(){    console.log(&apos;Hello World&apos;);    }();//语法错误，虽然匿名函数属于函数表达式，但是未进行赋值操作，//所以javascript引擎将开头的function关键字当做函数声明，报错：要求需要一个函数名</code></pre><p><strong>立即执行函数(IIFE)</strong></p><p>函数体后面加括号就能立即调用，则这个函数必须是函数表达式，不能是函数声明。 在理解了一些函数基本概念后，回头看看：</p><pre><code>( function(){…} )() ( function (){…} () ) </code></pre><p>这是两种立即执行函数的写法，一个括号包裹匿名函数，并直接在①匿名函数的后面或者②包含匿名函数括号的后面加个括号 就可以立即调用函数。</p><p>在function前面加（）、！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符，都将函数声明转换成函数表达式，消除了javascript引擎识别函数表达式和函数声明的歧义，告诉javascript引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码。</p><p>加括号是最安全的做法，因为！、+、-等运算符还会和函数的返回值进行运算，有时造成不必要的麻烦。</p><pre><code>(function(a){    console.log(a);   //firebug输出123,使用（）运算符})(123);(function(a){    console.log(a);   //firebug输出1234，使用（）运算符}(1234));!function(a){    console.log(a);   //firebug输出12345,使用！运算符}(12345);+function(a){    console.log(a);   //firebug输出123456,使用+运算符}(123456);-function(a){    console.log(a);   //firebug输出1234567,使用-运算符}(1234567);var fn=function(a){    console.log(a);   //firebug输出12345678，使用=运算符}(12345678)</code></pre><p><strong>匿名函数的作用</strong></p><p>匿名函数可以有效的保证在页面上写入Javascript，而不会造成全局变量的污染。 这在给一个不是很熟悉的页面增加Javascript时非常有效，也很优美。</p><p>javascript中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据javascript函数作用域链的特性，可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈使用 promise 时候的一些反模式</title>
      <link href="/226.html"/>
      <url>/226.html</url>
      
        <content type="html"><![CDATA[<p>各位 JavaScript 程序员，是时候承认了，我们在使用 promise 的时候，会写出许多有问题的 promise 代码。 当然并不是 promise 本身的问题，A+ spec 规范定义的 promise 非常棒。 在过去的几年中，笔者看到了很多程序员在调用 PouchDB 或者其他 promise 化的 API 时遇到了很多困难。这让笔者认识到，在 JavaScript 程序员之中，只有少数人是真正理解了 promise 规范的。如果这个事实让你难以接受，那么思考一下我在 Twitter 上出的题：</p><p>问：下面四个使用 promise 的语句之间的不同点在哪儿？</p><pre><code>doSomething().then(function () {    return doSomethingElse();})；doSomethin().then(functiuoin () {    doSomethingElse();});doSomething().then(doSomethingElse());doSomething().then(doSomethingElse);</code></pre><p>如果你知道这个问题的答案，那么恭喜你，你已经是一个 promise 大师并且可以直接关闭这个网页了。</p><p>但是对于不能回答这个问题的程序员中 99.9% 的人，别担心，你们不是少数派。没有人能够在笔者的 tweet 上完全正确的回答这个问题，而且对于 #3 最终答案也令我感到震惊，即便我是出题人。</p><p>答案在本文的底部，但是首先，笔者必须先探究一下 promise 为何如此复杂，为什么不管是新手还是专家都有被 promise 折磨的经历。同时，笔者也会给出自认为能够快速、准确理解 promise 的方法。而且笔者确信读过这篇文章之后，理解 promise 不会那么难了。</p><p>在此之前，我们先了解一下有关 promise 的一些常识。</p><h3 id="Promise-的起源"><a href="#Promise-的起源" class="headerlink" title="Promise 的起源"></a>Promise 的起源</h3><p>如果你读过有关 promise 的文章，你会发现文章中一定会提到 Callback hell，不说别的，在视觉上，回调金字塔会让你的代码最终超过屏幕的宽度。</p><p>promise 是能够解决这个问题的，但是它解决的问题不仅仅是缩进。在讨论到如何 解决 Callback hell 问题 的时候，我们遇到真正的难题是回调函数剥夺了程序员使用 return 和 throw 的能力。而程序的执行流程的基础建立于一个函数在执行过程中调用另一个函数时产生的副作用。(译者注：个人对这里副作用的理解是，函数调用函数会产生函数调用栈，而回调函数是不运行在栈上的，因此不能使用 return 和 throw)。</p><p>事实上，回调函数还有更恼人的——剥夺我们在栈上执行代码的能力，而在其他语言当中，我们始终都能够在栈上执行代码。编写不在栈上运行的代码就像开没有刹车的车一样，在你真正需要它的时候，才明白它有多么的重要。</p><p>promise 被设计为能够让我们重新使用那些编程语言的基本要素：return，throw，栈。在想要使用 promise 之前，我们首先要学会正确使用它。</p><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>一些人尝试使用 漫画 的方式解释 promise，或者是像是解释名词一样解释它：它表示同步代码中的值，并且能在代码中被传递。</p><p>笔者并没有觉得这些解释对理解 promise 有用。笔者自己的理解是：promise 是关于代码结构和代码运行流程的。因此，笔者认为展示一些常见错误，并告诉大家如何修正它才是王道。</p><p>扯远一点，对于 promise，不同的人有不同的理解，为了本文的最终目的，我在这里只讨论 promise 的官方 规范，在较新版本的浏览器会作为 window 对象的一个属性被暴露出来。然而并不是所有的浏览器都支持这一特性，但是到目前为止有许多 polyfill，比如这个名字很大胆并且实现非常简洁的 promise 库：Lie。</p><p><strong>新手错误 No.1：Callback hell</strong></p><p>PouchDB 有许多 promise 风格的API，程序员在写有关 PouchDB 的代码的时候，常常将 promise 用的一塌糊涂。下面给出一种很常见的糟糕写法。</p><pre><code>remote.allDocs({    include_docs: true,    attachment: true}).then(functionb (result) {    var docs = result.rows;    docs.forEach(function(element) {        localdb.put(element.doc).then(function(response){            alert(&apos;pulled doc with id&apos; + element.doc._id + &apos;and added to local db.&apos;);}).catch(function (err) {        if (err.status == 409) {            localdb.get(element.doc._id).then(function (resp) {             localdb.remove(resp._id, resp._rev).then(function (resp) {// et cetera...</code></pre><p>你确实可以将 promise 当做回调函数来使用，但这却是一种杀鸡用牛刀的行为。不过这么做也是可行的。 你可能会认为这种错误是那些刚入行的新手才会犯的。但是笔者在黑莓的 开发者博客 上曾经看到类似的代码。过去的书写回调函数的习惯是很难改变的。</p><p>下面给出一种代码风格更好的实现：</p><pre><code>remotedb.allDocs(...).then(functioin (resultofAllDocs) {    return localdb.put(...);}).then(function (resultOfPut) {    return localdb.get(...);}).then(function (resultOfGet) {    return localdb.put(...);}).catch(function (err) {    console.log(err);});</code></pre><p>这就是 promise 的链式调用，它体现 promise 的强大之处，每个函数在上一个 promise 的状态变为 resolved 的时候才会被调用，并且能够得到上一个 promise 的输出结果。稍后还有详细的解释。</p><p><strong>新手错误 2：怎样用 forEach() 处理 promise</strong></p><p>这个问题是大多数人掌握 promise 的绊脚石，当这些人想在代码中使用他们熟悉的 forEach() 方法或者是写一个 for 循环，抑或是 while 循环的时候，都会为如何使用 promise 而疑惑不已。他们会写下这样的代码：</p><pre><code>// I want to remove() all docsdb.allDocs({include_docs: true}).then(function (result) {    result.rows.forEach(function (row) {        db.remove(row.doc);    });}).then(function () {    // I naively believe all docs have been removed() now!});</code></pre><p>这段代码的问题在于第一个回调函数实际上返回的是 undefined，也就意味着第二个函数并不是在所有的 db.remove() 执行结束之后才执行。事实上，第二个函数的执行不会有任何延时，它执行的时候被删除的 doc 数量可能为任意整数。</p><p>这段代码看起来是能够正常工作的，因此这个 bug 也具有一定的隐藏性。写这代码的人以为 PouchDB 已经删除了这些 docs，可以更新 UI 了。这个 bug 会在一定几率下出现，或者是特定的浏览器。而一旦出现，这种 bug 是很难调试的。</p><p>一言以蔽之，你需要的不是 forEach()/for/while 而是 Promise.all()：</p><pre><code>db.allDocs({include_docs: true}).then(function (result) {    return Promise.all(result.rows.map(function (row) {        return db.remove(row.doc);    }));}).then(function (arrayObject) {    // All docs have really been removed() now!})</code></pre><p>从根本上说，Promise.all() 以一个 promise 对象组成的数组为输入，返回另一个 promise 对象。这个对象的状态只会在数组中所有的 promise 对象的状态都变为 resolved 的时候才会变成 resolved。可以将其理解为异步的 for 循环。</p><p>Promise.all() 还会将计算结果以数组的形式传递给下一个函数，这一点十分有用。举例来说，如果你想用 get() 方法从 PouchDB 得到多个值的时候，就可以利用这个特性。同时，作为输入的一系列 promise 对象中，如果有一个的状态变为 rejected，那么 all()返回的 promise 对象的状态也会变为 rejected。</p><p><strong>新手错误 3：忘记添加 catch() 方法</strong></p><p>这是一个很常见的错误。很多程序员对他们代码中的 promise 调用十分自信，觉得代码永远不会抛出一个 error，也可能他们只是简单的忘了加 catch() 方法。不幸的是，不加 catch() 方法会让回调函数中抛出的异常被吞噬，在你的控制台是看不到相应的错误的，这对调试来说是非常痛苦的。</p><p>为了避免这种糟糕的情况，我已经养成了在自己的 promise 调用链最后添加如下代码的习惯：</p><pre><code>somePromise().then(function () {    return anotherPromise();}).then(function () {    return yetAnotherPromise();}).catch(console.log.bind(console)); // &lt;-- this is badass</code></pre><p>即使你并不打算在代码中处理异常，在代码中添加 catch() 也是一个谨慎的编程风格的体现。在某种情况下你原先的假设出错的时候，这会让你的调试工作轻松一些。</p><p><strong>新手错误 4：使用 “deferred”</strong></p><p>这类型 错误 笔者经常看到，在这里我也不想重复它了。简而言之，promise 经过了很长一段时间的发展，有一定的历史包袱。JavaScript 社区用了很长的时间才纠正了发展道路上的一些错误。jQuery 和 Angular 早期都在使用 ‘deferred’ 类型的 promise。而在最新的 ES6 的 Promise 标准中，这种实现方式已经被替代了，同时，一些 Promise 的库，比如 Q，bluebid，Lie 也是参照 ES6 的标准来实现的。</p><p>如果你还在代码中使用 ‘deferred’ 的话，那么你就是走在错误的道路上了，这里笔者给出一些修正的办法。</p><p>首先，绝大多数的库都给出了将第三方库的方法包装成 promise 对象的方法。举例来说，Angular 的 (q 模块可以使用 <code>\)q.when()</code> 完成这一包装过程。因此，在 Angular 中，包装 PouchDB 的 promise API的代码如下：</p><pre><code>$q.when(db.put(doc)).then(...) // &lt;-- this is all the code you need</code></pre><p>另一种方法就是使用暴露给程序员的 构造函数。promise 的构造函数能够包装那些非 promise 的 API。下面给出一个例子，在该例中将 Node.js 提供的 fs.readFile() 方法包装成 promise。</p><pre><code>new Promise(function (resolve, reject) {    fs.readFile(&apos;myfile.txt&apos;, function (err, file) {        if (err) {            return reject(err);        }        resolve(file);    });}).then(...)</code></pre><p>齐活！</p><p>如果你想更多的了解为什么这样的写法是一个反模式，猛戳这里 <a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern" target="_blank" rel="noopener">the Bluebird wiki page on promise anti-patterns</a></p><p><strong>新手错误 5：不显式调用 return</strong></p><p>下面这段代码的问题在哪里？</p><pre><code>somePromise().then(function () {    someOtherPromise();}).then(function () {    // Gee, I hope someOtherPromise() has resolved    // Spoiler alert: it hasn&apos;t});</code></pre><p>现在该讨论所有需要了解的关于 promise 的知识点了。理解了这一个知识点，笔者提到的一些错误你都不会犯了。</p><p>正如笔者前面所说的，promise 的神奇之处在于让我们能够在回调函数里面使用 return 和 throw。但是实践的时候是什么样子呢？</p><p>每一个 promise 对象都会提供一个 then 方法或者是 catch 方法：</p><pre><code>somePromise().then(function () {    // I&apos;m inside a then() function!});</code></pre><p>在 then 方法内部，我们可以做三件事：</p><ul><li>return 一个 promise 对象</li><li>return 一个同步的值或者是 undefined</li><li>同步的 throw 一个错误</li></ul><p>理解这三种情况之后，你就会理解 promise 了。</p><p><strong>返回另一个 promise 对象</strong></p><p>在有关 promise 的相关文章中，这种写法很常见，就像上文提到的构成 promise 链的一段代码：</p><pre><code>getUserByName(&apos;nolan&apos;).then(function (user) {    return getUserAccountById(user.id);}).then(funcxtion (userAccount) {});</code></pre><p>这段代码里面的 return 非常关键，没有这个 return 的话，getUserAccountById 只是一个普通的被别的函数调用的函数。下一个回调函数会接收到 undefined 而不是 userAccount</p><p><strong>返回一个同步的值或者是 undefined</strong></p><p>返回一个 undefined 大多数情况下是错误的，但是返回一个同步的值确实是一个将同步代码转化成 promise 风格代码的好方法。举个例子，现在在内存中有 users。我们可以：</p><pre><code>getUserByName(&apos;nolan&apos;).then(fcuntion (user) {    if (inMemoryCache[user.id]) {        return inMemoryCache[user.id];  // returning a synchronous value!    }    return inMemoryCache[user.id]; // returning a promise}).then(function (userAccount) {    // I got a user account})</code></pre><p>第二个回调函数并不关心 userAccount 是通过同步的方式得到的还是异步的方式得到的，而第一个回调函数即可以返回同步的值又可以返回异步的值。</p><p>不幸的是，如果不显式调用 return 语句的话，JavaScript 里的函数会返回 undefined。这也就意味着在你想返回一些值的时候，不显式调用 return 会产生一些副作用。</p><p>鉴于以上原因，笔者养成了一个在 then 方法内部永远显式的调用 return 或者 throw 的习惯。建议你也这样做。</p><p><strong>抛出一个同步的错误</strong></p><p>说到 throw，这又体现了 promise 的功能强大。在用户退出的情况下，我们的代码中会采用抛出异常的方式进行处理：</p><pre><code>getUserByName(&apos;nolan&apos;).then(function (user) {  if (user.isLoggedOut()) {    throw new Error(&apos;user logged out!&apos;); // throwing a synchronous error!  }  if (inMemoryCache[user.id]) {    return inMemoryCache[user.id];       // returning a synchronous value!  }  return getUserAccountById(user.id);    // returning a promise!}).then(function (userAccount) {  // I got a user account!}).catch(function (err) {  // Boo, I got an error!});</code></pre><p>如果用户已经登出的话，catch() 会收到一个同步的错误，如果有 promise 对象的状态变为 rejected 的话，它还会收到一个异步的错误。catch() 的回调函数不用关心错误是异步的还是同步的。</p><p>在使用 promise 的时候抛出异常在开发阶段很有用，它能帮助我们定位代码中的错误。比方说，在 then 函数内部调用 JSON.parse（），如果 JSON 对象不合法的话，可能会抛出异常，在回调函数中，这个异常会被吞噬，但是在使用 promise 之后，我们就可以捕获到这个异常了。</p><h3 id="进阶错误"><a href="#进阶错误" class="headerlink" title="进阶错误"></a>进阶错误</h3><p>接下来我们讨论一下使用 promise 的边界情况。</p><p>下面的错误笔者将他们归类为 “进阶错误”，因为这些错误发生在那些已经相对熟练使用 promise 的程序员身上。但是为了解决本文开头提出的问题，还是有必要对其进行讨论。</p><p><strong>进阶错误 1：不了解 Promise.resolve()</strong></p><p>就像之前所说的，promise 能够将同步代码包装成异步的形式。然而，如果你经常写出如下的代码：</p><pre><code>new Promise(function (resolve, reject) {  resolve(someSynchronousValue);}).then(...);</code></pre><p>你可以使用 Promise.resolve() 将上述代码精简。</p><pre><code>Promise.resolve(someSynchronousValue).then(...);</code></pre><p>在捕获同步异常的时候这个做法也是很有效的。我在编写 API 的时候已经养成了使用 Promise.resolve() 的习惯：</p><pre><code>function somePromiseAPI() {  return Promise.resolve().then(function () {    doSomethingThatMayThrow();    return &apos;foo&apos;;  }).then(...);}</code></pre><p>记住，有可能抛出错误的代码都有可能因为错误被吞噬而对你的工作造成困扰。但是如果你用 Promise.resolve() 包装了代码的话，你永远都可以在代码后面加上 catch()。</p><p>相同的，使用 Promise.reject() 可以立即返回一个状态为 rejected 的 promise 对象。</p><pre><code>Promise.reject(new Error(&apos;some awful error&apos;));</code></pre><p><strong>进阶错误 2：cacth() 和 then(null, …) 并不完全相同</strong></p><p>笔者提到过 cacth() 是 then(null, …) 的语法糖，因此下面两个代码片段是等价的</p><pre><code>somePromise().catch(function (err) {  // handle error});somePromise().then(null, function (err) {  // handle error});</code></pre><p>但是，这并不意味着下面的两个代码片段是等价的</p><pre><code>somePromise().then(function () {  return someOtherPromise();}).catch(function (err) {  // handle error});somePromise().then(function () {  return someOtherPromise();}, function (err) {  // handle error});</code></pre><p>如果你不理解的话，那么请思考一下如果第一个回调函数抛出一个错误会发生什么？</p><pre><code>somePromise().then(function () {  throw new Error(&apos;oh noes&apos;);}).catch(function (err) {  // I caught your error! :)});somePromise().then(function () {  throw new Error(&apos;oh noes&apos;);}, function (err) {  // I didn&apos;t catch your error! :(});</code></pre><p>结论就是，当使用 then(resolveHandler, rejectHandler)，rejectHandler 不会捕获在 resolveHandler 中抛出的错误。</p><p>因为，笔者的个人习惯是从不使用 then 方法的第二个参数，转而使用 catch() 方法。但是也有例外，就是在笔者写异步的 Mocha 的测试用例的时候，如果想确认一个错误被抛出的话，代码是这样的：</p><pre><code>it(&apos;should throw an error&apos;, function () {  return doSomethingThatThrows().then(function () {    throw new Error(&apos;I expected an error!&apos;);  }, function (err) {    should.exist(err);  });});</code></pre><p>说到测试，将 mocha 和 Chai 联合使用是一种很好的测试 promise API 的方案。</p><p><strong>进阶错误 3：promise vs promise factories</strong></p><p>某些情况下你想一个接一个的执行一系列 promise，这时候你想要一个类似于 Promise.all() 的方法，但是 Proimise.all() 是并行执行的，不符合要求。你可能一时脑抽写下这样的代码：</p><pre><code>function executeSequentially(promises) {  var result = Promise.resolve();  promises.forEach(function (promise) {    result = result.then(promise);  });  return result;}</code></pre><p>不幸的是，这段代码不会按照你所想的那样执行，那些 promise 对象里的异步调用还是会并行的执行。原因是你根本不应当在 promise 对象组成的数组这个层级上操作。对于每个 promise 对象来说，一旦它被创建，相关的异步代码就开始执行了。因此，这里你真正想要的是一个 promise 工厂。</p><pre><code>function executeSequentially(promiseFactories) {  var result = Promise.resolve();  promiseFactories.forEach(function (promiseFactory) {    result = result.then(promiseFactory);  });  return result;}</code></pre><p>一个 promise 工厂非常简单，它就是一个返回 promise 对象的函数</p><pre><code>function myPromiseFactory() {  return somethingThatCreatesAPromise();}</code></pre><p>为什么采用 promise 对象就可以达到目的呢？因为 promise 工厂只有在调用的时候才会创建 promise 对象。它和 then() 方法的工作方式很像，事实上，它们就是一样的东西。</p><p><strong>进阶错误 4：如果我想要两个 promise 的结果应当如何做呢？</strong></p><p>很多时候，一个 promise 的执行是依赖另一个 promise 的。但是在某些情况下，我们想得到两个 promise 的执行结果，比方说：</p><pre><code>getUserByName(&apos;nolan&apos;).then(function (user) {  return getUserAccountById(user.id);}).then(function (userAccount) {  // dangit, I need the &quot;user&quot; object too!});</code></pre><p>为了避免金字塔问题，我们可能会在外层作用域存储 user 对象。</p><pre><code>var user;getUserByName(&apos;nolan&apos;).then(function (result) {  user = result;  return getUserAccountById(user.id);}).then(function (userAccount) {  // okay, I have both the &quot;user&quot; and the &quot;userAccount&quot;});</code></pre><p>上面的代码能够到达想要的效果，但是这种显得不够专业，我建议抛开成见，拥抱金字塔：</p><pre><code>getUserByName(&apos;nolan&apos;).then(function (user) {  return getUserAccountById(user.id).then(function (userAccount) {    // okay, I have both the &quot;user&quot; and the &quot;userAccount&quot;  });});</code></pre><p>至少，是暂时拥抱金字塔。如果缩进真的成为了你代码中的一个大问题，那么你可以像每一个 JavaScript 程序员从开始写代码起就被教导的一样，将其中的部分抽出来作为一个单独的函数。</p><pre><code>function onGetUserAndUserAccount(user, userAccount) {  return doSomething(user, userAccount);}function onGetUser(user) {  return getUserAccountById(user.id).then(function (userAccount) {    return onGetUserAndUserAccount(user, userAccount);  });}getUserByName(&apos;nolan&apos;)  .then(onGetUser)  .then(function () {  // at this point, doSomething() is done, and we are back to indentation 0});</code></pre><p>随着你的 promise 代码越来越复杂，你会将越来越多的代码作为函数抽离出来。笔者发现这会促进代码风格变得优美：</p><pre><code>putYourRightFootIn()  .then(putYourRightFootOut)  .then(putYourRightFootIn)  .then(shakeItAllAbout);</code></pre><p>这就是 promise 的最终目的。</p><p><strong>进阶错误 5：promise 穿透</strong></p><p>这个错误我在前文中提到的问题中间接的给出了。这是个非常令人费解的案例，或许你永远不会写出这样的代码，但是这种写法还是让笔者感到震惊。 你认为下面的代码会输出什么？</p><pre><code>Promise.resolve(&apos;foo&apos;).then(Promise.resolve(&apos;bar&apos;)).then(function (result) {  console.log(result);});</code></pre><p>如果你认为输出的是 bar，那么你就错了。实际上它输出的是 foo！</p><p>产生这样的输出是因为你给 then 方法传递了一个非函数（比如 promise 对象）的值，代码会这样理解：then(null)，因此导致前一个 promise 的结果产生了坠落的效果。你可以自己测试一下：</p><pre><code>Promise.resolve(&apos;foo&apos;).then(null).then(function (result) {  console.log(result);});</code></pre><p>随便添加任意多个 then(null)，结果都是不变的</p><p>让我们回到之前讲解 promise vs promise factoriesde 的地方。简而言之，如果你直接给 then 方法传递一个 promise 对象，代码的运行是和你所想的不一样的。then 方法应当接受一个函数作为参数。因此你应当这样书写代码：</p><pre><code>Promise.resolve(&apos;foo&apos;).then(function () {  return Promise.resolve(&apos;bar&apos;);}).then(function (result) {  console.log(result);});</code></pre><p>这样就会如愿输出 bar。</p><h3 id="答案来了！"><a href="#答案来了！" class="headerlink" title="答案来了！"></a>答案来了！</h3><p>下面给出前文题目的解答</p><p>#1</p><pre><code>doSomething().then(function () {  return doSomethingElse();}).then(finalHandler);</code></pre><p>答案：</p><pre><code>doSomething|-----------------|                  doSomethingElse(undefined)                  |------------------|                                     finalHandler(resultOfDoSomethingElse)                                     |------------------|</code></pre><p>#2</p><pre><code>doSomething().then(function () {  doSomethingElse();}).then(finalHandler);</code></pre><p>答案：</p><pre><code>doSomething|-----------------|                  doSomethingElse(undefined)                  |------------------|                  finalHandler(undefined)                  |------------------|</code></pre><p>#3</p><pre><code>doSomething().then(doSomethingElse())  .then(finalHandler);</code></pre><p>答案</p><pre><code>doSomething|-----------------|doSomethingElse(undefined)|---------------------------------|                  finalHandler(resultOfDoSomething)                  |------------------|</code></pre><p>#4</p><pre><code>doSomething().then(doSomethingElse)  .then(finalHandler);</code></pre><p>答案</p><pre><code>doSomething|-----------------|                  doSomethingElse(resultOfDoSomething)                  |------------------|                                     finalHandler(resultOfDoSomethingElse)                                     |------------------|</code></pre><p>需要说明的是，在上述的例子中，我都假设 doSomething() 和 doSomethingElse() 返回一个 promise 对象，这些 promise 对象都代表了一个异步操作，这样的操作会在当前 event loop 之外结束，比如说有关 IndexedDB，network 的操作，或者是使用 setTimeout。这里给出 <a href="http://jsbin.com/tuqukakawo/1/edit?js,console,output" target="_blank" rel="noopener">JSBin</a> 上的示例。</p><h3 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h3><p>promise 是个好东西。如果你还在使用传统的回调函数的话，我建议你迁移到 promise 上。这样你的代码会更简洁，更优雅，可读性也更强。</p><p>有这样的观点：promise 是不完美的。promise 确实比使用回调函数好，但是，如果你有别的选择的话，这两种方式最好都不要用。</p><p>尽管相比回调函数有许多优点，promise 仍然是难于理解的，并且使用起来很容易出错。新手和卖家都会经常将 promise 用的乱七八糟。不过这并不是他们的错。问题在于 promise 和我们写的同步代码非常相似，但仅此而已，并不尽然。</p><p>在同步环境下，你无需学习这些晦涩难懂的规则和新的 API。你可以随意使用像 return、catch 和 throw 这样的关键字以及 for 循环。你不需要时刻在脑中保持两个相并列的编程思想。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BFC等Formatting Contexts浅析</title>
      <link href="/224.html"/>
      <url>/224.html</url>
      
        <content type="html"><![CDATA[<h3 id="BFC-是什么"><a href="#BFC-是什么" class="headerlink" title="BFC 是什么"></a>BFC 是什么</h3><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有 Block-level box 参与，它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。同理，还有 inline-level box，run-in box。</p><h3 id="BFC-布局规则"><a href="#BFC-布局规则" class="headerlink" title="BFC 布局规则"></a>BFC 布局规则</h3><ul><li>内部的 Box 会在垂直方向，一个接一个地放置。</li><li>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。</li><li>每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC 的区域不会与 float box 重叠。</li><li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算 BFC 的高度时，浮动元素也参与计算。</li></ul><h3 id="哪些元素是-BFC"><a href="#哪些元素是-BFC" class="headerlink" title="哪些元素是 BFC"></a>哪些元素是 BFC</h3><ul><li>根元素，即 HTML 元素</li><li>float 属性不为 none</li><li>position 为 absolute 或 fixed</li><li>display 为 inline-block, table-cell, table-caption, flex, inline-flex</li><li>overflow 不为 visible</li></ul><h3 id="BFC-有什么用"><a href="#BFC-有什么用" class="headerlink" title="BFC 有什么用"></a>BFC 有什么用</h3><ul><li>自适应两栏布局</li><li>清除内部浮动（如给父元素加 overflow:hidden）</li><li>分属于不同的 BFC 时可以阻止 margin 重叠</li></ul><h3 id="什么是-FC"><a href="#什么是-FC" class="headerlink" title="什么是 FC"></a>什么是 FC</h3><p>FC 的全称是：Formatting Contexts，是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p>FC 一共包含 BFC、IFC、GFC 、FFC 四种类型。CSS2.1 规范中只有 BFC、IFC。CSS3 推出 GFC、FFC 两种新类型。</p><h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><p>IFC(Inline Formatting Contexts)直译为”内联格式化上下文”，IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)。</p><p><strong>IFC 特性</strong></p><ul><li><p>IFC 中的 line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与与 line box 之间，使得 line box 宽度缩短。</p></li><li><p>IFC 中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。</p></li></ul><p><strong>IFC 作用</strong></p><ul><li><p>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。</p></li><li><p>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</p></li></ul><h3 id="GFC"><a href="#GFC" class="headerlink" title="GFC"></a>GFC</h3><p>GFC(GridLayout Formatting Contexts)直译为”网格布局格式化上下文”，当为一个元素设置 display 值为 grid 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。</p><p>GFC 将改变传统的布局模式，他将让布局从一维布局变成了二维布局。简单的说，有了 GFC 之后，布局不再局限于单个维度了。这个时候你要实现类似九宫格，拼图之类的布局效果显得格外的容易。</p><h3 id="FFC"><a href="#FFC" class="headerlink" title="FFC"></a>FFC</h3><p>FFC(Flex Formatting Contexts)直译为”自适应格式化上下文”，display 值为 flex 或者 inline-flex 的元素将会生成自适应容器（flex container）。</p><p>Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。</p><p>伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。</p><p>整体来说，FFC 与 BFC 有点儿类似，但仍有以下几点区别：</p><ul><li><p>Flexbox 不支持 ::first-line 和 ::first-letter 这两种伪元素</p></li><li><p>vertical-align 对 Flexbox 中的子元素 是没有效果的</p></li><li><p>float 和 clear 属性对 Flexbox 中的子元素是没有效果的，也不会使子元素脱离文档流(但是对 Flexbox 是有效果的！)</p></li><li><p>多栏布局（column-*） 在 Flexbox 中也是失效的，就是说我们不能使用多栏布局在 Flexbox 排列其下的子元素</p></li><li><p>Flexbox 下的子元素不会继承父级容器的宽</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端前端适配方案总结</title>
      <link href="/218.html"/>
      <url>/218.html</url>
      
        <content type="html"><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>在介绍各方案之前，先有必要了解一些必备的名词。</p><h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>全称 <code>pixel</code>，像素。一个像素就是计算机屏幕所能显示一种特定颜色的最小区域。屏幕上显示数据最基本的点，不是长度单位。 如果点很小，那画面就清晰，我们称它为“分辨率高”，反之，就是“分辨率低”。</p><h3 id="ppi"><a href="#ppi" class="headerlink" title="ppi"></a>ppi</h3><p>全称 <code>Pixels Per Inch</code>，屏幕像素密度。单位是 <code>dpi</code>，表示的是每英寸所拥有的像素(Pixel)数目。 越大屏幕越高清。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量，iphone5 屏幕上垂直有 1136 个物理像素，水平有 640 个物理像素。<a href="https://www.sven.de/dpi/" target="_blank" rel="noopener">查询设备的分辨率及 ppi</a></p><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>相对长度单位。相对于根元素(即 html 元素)的 font-size 计算值的倍数。</p><h3 id="物理像素（设备像素）"><a href="#物理像素（设备像素）" class="headerlink" title="物理像素（设备像素）"></a>物理像素（设备像素）</h3><p>设备屏幕上的实际像素。如 iphone6 宽为 750。</p><h3 id="设备独立像素（逻辑像素-css-像素）"><a href="#设备独立像素（逻辑像素-css-像素）" class="headerlink" title="设备独立像素（逻辑像素/css 像素）"></a>设备独立像素（逻辑像素/css 像素）</h3><p>设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css 像素)，然后由相关系统转换为物理像素。如 iphone6 为 375×667。</p><h3 id="设备像素比-device-pixel-ratio-屏幕分辩比-dpr"><a href="#设备像素比-device-pixel-ratio-屏幕分辩比-dpr" class="headerlink" title="设备像素比(device pixel ratio/屏幕分辩比/dpr)"></a>设备像素比(device pixel ratio/屏幕分辩比/dpr)</h3><p>设备像素比 = 物理像素 / 设备独立像素</p><p>在某一方向上，x 方向或者 y 方向。在控制台通过 window.devicePixelRatio 可得。</p><h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h3><p>scale 是屏幕拉伸比。也就是视口上的 initial-scale , maximum-sacle 等属性。</p><h3 id="视口（viewport）"><a href="#视口（viewport）" class="headerlink" title="视口（viewport）"></a>视口（viewport）</h3><ul><li><p>布局视口：网页在开始设计时候的 dom 宽度（比如 960px）</p></li><li><p>可视视口：整个屏幕的视口（比如 iphone6 375px）</p></li><li><p>完美视口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1.0,width=device-width,user-scalable=0,maximum-scale=1.0"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  width：设置布局视口的宽 </span></span><br><span class="line"><span class="comment">  init-scale：设置页面的初始缩放程度 </span></span><br><span class="line"><span class="comment">  minimum-scale：设置了页面最小缩放程度</span></span><br><span class="line"><span class="comment">  maximum-scale：设置了页面最大缩放程度 </span></span><br><span class="line"><span class="comment">  user-scalable：是否允许用户对页面进行缩放操作</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="目前主流的自适应布局解决方案"><a href="#目前主流的自适应布局解决方案" class="headerlink" title="目前主流的自适应布局解决方案"></a>目前主流的自适应布局解决方案</h2><h3 id="响应式（Responsive-web-design"><a href="#响应式（Responsive-web-design" class="headerlink" title="响应式（Responsive web design)"></a>响应式（Responsive web design)</h3><p>通过媒体查询根据不同的屏幕分辨率来进行适配。</p><p>优点:</p><ul><li><code>media query</code> 可以做到设备像素比的判断，方法简单，成本低，特别是对移动和 PC 维护同一套代码的时候。目前像 Bootstrap 等框架使用这种方式布局。</li><li>图片便于修改，只需修改 css 文件。</li><li>调整屏幕宽度的时候不用刷新页面即可响应式展示。</li></ul><p>缺点:</p><ul><li>代码量比较大，维护不方便。</li><li>为了兼顾大屏幕或高清设备，会造成其他设备资源浪费，特别是加载图片资源。</li><li>为了兼顾移动端和 PC 端各自响应式的展示效果，难免会损失各自特有的交互方式。</li></ul><h3 id="流式布局（推荐）"><a href="#流式布局（推荐）" class="headerlink" title="流式布局（推荐）"></a>流式布局（推荐）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=width=device-width,initial-scale=1,maximum-scale=1, minimum-scale=1,user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>流式布局需要用到<code>百分比</code>或者 <code>flex</code>，即宽度永远铺满页面宽度，但高度和其他单位仍然用 px。它的字体精度可以保持跟设备系统一致（dpi）。</p><h3 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h3><h4 id="法一（推荐）"><a href="#法一（推荐）" class="headerlink" title="法一（推荐）"></a>法一（推荐）</h4><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>(100vw / 7.5);</span><br><span class="line">&#125; <span class="comment">/* 以iphone6 750的设计稿为准 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他元素用rem作为单位 */</span></span><br></pre></td></tr></table></figure><p>js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeRootFont</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> designWidth = <span class="number">750</span>,</span><br><span class="line">      rem2px = <span class="number">100</span>; <span class="comment">//这个100理论上可以是任何值</span></span><br><span class="line">    <span class="built_in">document</span>.documentElement.style.fontsize = (<span class="built_in">window</span>.innerWidth / designWidth) * rem2px + <span class="string">'px'</span>; <span class="comment">//iphone6: (375 / 750) * 100 + 'px';</span></span><br><span class="line">    <span class="comment">// 因为chrome下最小字体大小为12px，所以不能把html的font-size设置成0.5px或者5px，50px是我们最好的选择。</span></span><br><span class="line">  &#125;</span><br><span class="line">  changeRootFont();</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, changeRootFont, <span class="literal">false</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>此方法简单粗暴，无需考虑 dpr，物理像素之类。但缺陷就是 1px，图片高清，文字字体大小问题。文字大小可通过媒体查询来处理。计算量大，可通过 px2rem 插件来处理。</p><h4 id="法二（不推荐）"><a href="#法二（不推荐）" class="headerlink" title="法二（不推荐）"></a>法二（不推荐）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dpr, rem, scale;</span><br><span class="line"><span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement;</span><br><span class="line"><span class="keyword">var</span> fontEl = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line"><span class="keyword">var</span> metaEl = <span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>);</span><br><span class="line"></span><br><span class="line">dpr = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>;</span><br><span class="line">rem = (docEl.clientWidth * dpr) / <span class="number">10</span>;</span><br><span class="line">scale = <span class="number">1</span> / dpr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置viewport，进行缩放，达到高清效果</span></span><br><span class="line">metaEl.setAttribute(<span class="string">'content'</span>, <span class="string">'width='</span> + dpr * docEl.clientWidth + <span class="string">',initial-scale='</span> + scale + <span class="string">',maximum-scale='</span> + scale + <span class="string">', minimum-scale='</span> + scale + <span class="string">',user-scalable=no'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置data-dpr属性，留作的css hack之用</span></span><br><span class="line">docEl.setAttribute(<span class="string">'data-dpr'</span>, dpr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态写入样式</span></span><br><span class="line">docEl.firstElementChild.appendChild(fontEl);</span><br><span class="line">fontEl.innerHTML = <span class="string">'html&#123;font-size:'</span> + rem + <span class="string">'px!important;&#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给js调用的，某一dpr下rem和px之间的转换函数</span></span><br><span class="line"><span class="built_in">window</span>.rem2px = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  v = <span class="built_in">parseFloat</span>(v);</span><br><span class="line">  <span class="keyword">return</span> v * rem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.px2rem = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  v = <span class="built_in">parseFloat</span>(v);</span><br><span class="line">  <span class="keyword">return</span> v / rem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.dpr = dpr;</span><br><span class="line"><span class="built_in">window</span>.rem = rem;</span><br></pre></td></tr></table></figure><p>引入以上代码即可用。通过 hack 的 <code>data-dpr</code> 来单独控制字体。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span>: 16<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-attr">[data-dpr='2']</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">32px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方案原理是动态修改 <code>scale</code> 和 <code>font-size</code> 来达到高清效果。类似的可参照阿里的 <code>flexible</code>。</p><p>此方法解决了方法一存在的问题，缺陷是计算量大，可通过 px2rem 插件来处理。</p><h3 id="scale-伸缩布局"><a href="#scale-伸缩布局" class="headerlink" title="scale 伸缩布局"></a>scale 伸缩布局</h3><p>视觉稿、页面宽度、viewport width 使用统一宽度，利用浏览器自身缩放完成适配。页面样式（包括图像元素）完全按照视觉稿的尺寸，使用定值单位 （px、em）即可完成。</p><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>通过 js 更改 viewport 的 initial-scale。</p><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p>写死 viewport 的宽度.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=360, user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>优点:</p><ul><li>开发简单：缩放交给浏览器，完全按视觉稿切图。</li><li>还原精准：绝对等比例缩放，可以精准还原视觉稿（不考虑清晰度的情况下）。</li><li>测试方便：在 PC 端即可完成大部分测试，手机端只需酌情调整一些细节（比如图标、字体混合排列时，因为字体不同造成的对齐问题）。</li></ul><p>缺点:</p><ul><li>像素丢失：对于一些分辨率较低的手机，可能设备像素还未达到指定的 viewport 宽度，此时屏幕的渲染可能就不准确了。比较常见的是边框“消失”了，不过随着手机硬件的更新，这个问题会越来越少的。</li><li>缩放失效：某些安卓机不能正常的根据 meta 标签中 width 的值来缩放 viewport，需要配合 initial-scale 。</li><li>文本折行：存在于缩放失效的机型中，某些手机为了便于文本的阅读，在文本到达 viewport 边缘（非元素容器的边缘）时即进行折行，而当 viewport 宽度被修正后，浏览器并没有正确的重绘，所以就发现文本没有占满整行。一些常用的段落性文本标签会存在该问题。</li><li>不能开启 gpu raster 硬件加速：不能显式设置 minimum-scale=1.0，否则就达不到效果。而这个值是 chromium37 以上的 webview 触发 gpu raster 的一个条件，所以用这种方法就没法利用 gpu raster 硬件加速。</li></ul><p>注：</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="retina-下图片高清方案"><a href="#retina-下图片高清方案" class="headerlink" title="retina 下图片高清方案"></a>retina 下图片高清方案</h3><ol><li>两倍图片(@2x)，然后图片容器缩小 50%(方便但会造成资源浪费)。</li><li>不同的 dpr 下，加载不同的尺寸的图片。</li></ol><h3 id="retina-下-1px-解决方案"><a href="#retina-下-1px-解决方案" class="headerlink" title="retina 下 1px 解决方案"></a>retina 下 1px 解决方案</h3><ol><li>元素 scale（方便但圆角等无法用）</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scale</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scaleY</span>(0.5);</span><br><span class="line">  <span class="attribute">-webkit-transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>页面 scale（通用但页面整体都被缩放）</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=width=device-width,initial-scale=0.5,maximum-scale=0.5, minimum-scale=0.5,user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>书写高效CSS</title>
      <link href="/213.html"/>
      <url>/213.html</url>
      
        <content type="html"><![CDATA[<p>css 规范并不会强行规定浏览器必须如何实现样式系统，只会规定浏览器必须实现什么。因此，不同的样式系统引擎拥有不同的性能，开源的 Gecko 和 Webkit 算法类似，因此优缺点也类似。因此，下面的建议在大部分的 web 浏览器上应该是有意义的。</p><p>第一部分简单介绍样式系统规则分类；后面的章节主要指导如何利用样式系统的实现原理，来书写更有效率的规则。</p><h3 id="样式系统如何建立规则"><a href="#样式系统如何建立规则" class="headerlink" title="样式系统如何建立规则"></a>样式系统如何建立规则</h3><p>样式系统的规则分为四大类</p><ol><li>ID</li><li>class</li><li>tag</li><li>通用规则</li></ol><p>理解这四类规则非常关键，这是规则匹配的基础。</p><p>在接下来的段落中，我会使用”关键选择“（key selector)术语。key selector 是选择器的最后一部分。</p><p>例如，在下面的规则中：</p><pre><code>a img, div &gt; p, h1 + title {...}</code></pre><p>key selector 是 img,p 和 title。</p><h4 id="ID-rules"><a href="#ID-rules" class="headerlink" title="ID rules"></a>ID rules</h4><p>第一类是使用 ID 选择器作为 key selector.</p><pre><code>button#backButton {…} /* This is an ID-categorized rule */#urlBar[type=&quot;autocomplete&quot;] {…} /* This is an ID-categorized rule */ treeitem &gt; treerow &gt; treecell#myCell:active {…} /* This is an ID-categorized rule */</code></pre><h4 id="Class-rules"><a href="#Class-rules" class="headerlink" title="Class rules"></a>Class rules</h4><p>第二类是使用了 class 选择器作为 key selector</p><pre><code>button.toolbarButton {…} /* A class-based rule */ .fancyText {…} /* A class-based rule */ menuitem &gt; .menu-left[checked=&quot;true&quot;] {…} /* A class-based rule */</code></pre><h4 id="Tag-rules"><a href="#Tag-rules" class="headerlink" title="Tag rules"></a>Tag rules</h4><p>如果既不是 class 也不是 ID 作为 key selector,下一个候选是 tag。</p><pre><code>td {…} /* A tag-based rule */ treeitem &gt; treerow {…} /* A tag-based rule */ input[type=&quot;checkbox&quot;] {…} /* A tag-based rule */</code></pre><h4 id="Universal-rules"><a href="#Universal-rules" class="headerlink" title="Universal rules"></a>Universal rules</h4><p>剩下的均为此类。</p><pre><code>[hidden=&quot;true&quot;] {…} /* A universal rule */* {…} /* A universal rule */tree &gt; [collapsed=&quot;true&quot;] {…} /* A universal rule */</code></pre><h3 id="样式系统如何匹配规则"><a href="#样式系统如何匹配规则" class="headerlink" title="样式系统如何匹配规则"></a>样式系统如何匹配规则</h3><p>样式系统从 key selector 开始匹配，然后向左继续，寻找选择器的任意祖先。只要选择器的子树继续导出（这样翻译感觉怪怪的），样式系统会继续往左移动，直到要么匹配规则，要么因为不匹配终止。</p><p>最基本的概念是了解规则过滤。这些类别存在的目的是过滤掉不相关的规则，这样样式系统不用浪费时间去匹配它们。</p><p>这是提升性能的关键：检查一个指定的元素，规则越少，系统解析就越快。</p><p>例如，如果元素指定了 ID，那么只有与元素 ID 相同的 ID rule 会进行检查。只有存在于元素 class 列表的 class 规则才会进行检查。只有与标签相同的 tag rule 会被进行检查。通用规则总是会被检查。</p><h3 id="高效-css-建议"><a href="#高效-css-建议" class="headerlink" title="高效 css 建议"></a>高效 css 建议</h3><h4 id="避免使用通用规则"><a href="#避免使用通用规则" class="headerlink" title="避免使用通用规则"></a>避免使用通用规则</h4><p>避免一个规则的结束是通用规则这一类。</p><h4 id="不要使用-tag-或者-class-修饰-ID-rule"><a href="#不要使用-tag-或者-class-修饰-ID-rule" class="headerlink" title="不要使用 tag 或者 class 修饰 ID rule"></a>不要使用 tag 或者 class 修饰 ID rule</h4><p>如果一个规则使用了 ID 选择器作为 key selector，不要再添加 tag 标签指定。因为 ID 是唯一的，增加 tag name 会增加不必要的额外的匹配工作。</p><p><strong>BAD</strong><br>button#backButton {…}</p><p><strong>BAD</strong><br>.menu-left#newMenuIcon {…}</p><p><strong>GOOD</strong></p><p> #backButton {…}</p><p><strong>GOOD</strong></p><p> #newMenuIcon {…}</p><blockquote><p>例外：当需要通过改变元素的 class 来应用不同的样式，但是同样的 class 将会被其他元素共享。</p></blockquote><h4 id="不要使用-tag-修饰-class-规则"><a href="#不要使用-tag-修饰-class-规则" class="headerlink" title="不要使用 tag 修饰 class 规则"></a>不要使用 tag 修饰 class 规则</h4><p>尽管 class 可以在同一个页面重复出现，但是它的唯一性比 tag 更强。</p><p>你可以约定在 class 名称中包含 tag 名称，但是这会损失一些灵活性。当设计改变 tag 时，class 也会跟着变化。最好的是使用语义名称的 class name。</p><p><strong>BAD</strong></p><pre><code>treecell.indented {…}</code></pre><p><strong>GOOD</strong></p><pre><code>.treecell-indented {…}</code></pre><p><strong>BEST</strong></p><pre><code>.hierarchy-deep {…}</code></pre><h3 id="使用最特定的一类规则"><a href="#使用最特定的一类规则" class="headerlink" title="使用最特定的一类规则"></a>使用最特定的一类规则</h3><p>tag 这类会匹配太多的规则，这会大大的降低效率。通过给元素增加 class,我们可以回 class 分类进行细分，减少匹配时间。</p><p><strong>BAD</strong></p><pre><code>treeitem[mailfolder=&quot;true&quot;] &gt; treerow &gt; treecell {…}</code></pre><p><strong>GOOD</strong></p><pre><code>.treecell-mailfolder {…}</code></pre><h3 id="避免使用后代选择器"><a href="#避免使用后代选择器" class="headerlink" title="避免使用后代选择器"></a>避免使用后代选择器</h3><p>后代选择器是 css 中最耗时的选择器。尤其当选择器是 tag 或者通用这一类。</p><p><strong>BAD</strong></p><pre><code>treehead treerow treecell {…}</code></pre><p><strong>BETTER, BUT STILL BAD (see next guideline)</strong></p><pre><code>treehead &gt; treerow &gt; treecell {…}</code></pre><h3 id="tag-分类规则永远不要包含孩子选择器"><a href="#tag-分类规则永远不要包含孩子选择器" class="headerlink" title="tag 分类规则永远不要包含孩子选择器"></a>tag 分类规则永远不要包含孩子选择器</h3><p>避免使用孩子选择器在 tag 分类规则中。这会显著增长匹配时间。</p><p><strong>BAD</strong></p><pre><code>treehead &gt; treerow &gt; treecell {…}</code></pre><p><strong>GOOD</strong></p><pre><code>.treecell-header {…}</code></pre><h3 id="质疑所有使用孩子选择器的地方"><a href="#质疑所有使用孩子选择器的地方" class="headerlink" title="质疑所有使用孩子选择器的地方"></a>质疑所有使用孩子选择器的地方</h3><p>使用孩子选择器时务必谨慎，尽可能避免使用。</p><p>特别是，子选择器频繁适用于 RDF 树(这个自行 Google 吧)和 menus，如下：</p><p><strong>BAD</strong></p><pre><code>treeitem[IsImapServer=&quot;true&quot;] &gt; treerow &gt; .tree-folderpane-icon {…}</code></pre><p><strong>依靠继承</strong></p><p>了解哪些属性继承，然后使用继承。</p><p><strong>BAD</strong></p><pre><code>#bookmarkMenuItem &gt; .menu-left { list-style-image: url(blah) }</code></pre><p><strong>GOOD</strong></p><pre><code>#bookmarkMenuItem { list-style-image: url(blah) }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css居中完整版</title>
      <link href="/208.html"/>
      <url>/208.html</url>
      
        <content type="html"><![CDATA[<p>是时候对css居中的各种方式来波总结了！下面是一提到居中就应该联想到的关键属性：</p><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><p><strong>行内元素/行内块级元素特有:</strong></p><pre><code>.box{  text-align: center;}</code></pre><p><strong>块级元素特有:</strong></p><pre><code>.box{  margin: 0 auto;}</code></pre><p><strong>两者都可使用:</strong></p><ul><li><p>方法一</p><p>.parent {<br>  position: relative;<br>}.box {<br>  position: absolute;<br>  left: 50%;<br>  width: 200px;<br>  margin-left: -100px;<br>}</p></li></ul><ul><li><p>方法二</p><p>.parent {<br>  position: relative;<br>}.box {<br>  position: absolute;<br>  left: 50%;<br>  transform: translateX(-50%);<br>}</p></li></ul><ul><li><p>方法三</p><p>.parent {<br>  display: flex;<br>  justify-content: center;<br>}</p></li></ul><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul><li><p>方法一</p><p>.parent {<br>  height: auto;<br>  padding: 100px 0;<br>}</p></li></ul><ul><li><p>方法二</p><p>.parent {<br>  height: 100px;<br>  line-height: 100px;<br>}</p></li></ul><ul><li><p>方法三</p><p>.parent {<br>  display: table;<br>}.box {<br>  display: table-cell;<br>  vertical-align: middle;<br>}</p></li></ul><ul><li><p>方法四</p><p>.parent {<br>  display: flex;<br>  justify-content: center;<br>  flex-direction: column;<br>  height: 400px;<br>}</p></li></ul><ul><li><p>方法五</p><p>.parent {<br>  display: flex;<br>  align-items: center;<br>}</p></li></ul><ul><li><p>方法六</p><p>.parent {</p><pre><code>position: relative;</code></pre><p>}.box {</p><pre><code>position: absolute;top: 50%;height: 100px;margin-top: -50px; </code></pre><p>}</p></li></ul><ul><li><p>方法七</p><p>.parent {</p><pre><code>position: relative;</code></pre><p>}.box {</p><pre><code>position: absolute;top: 50%;transform: translateY(-50%);</code></pre><p>}</p></li></ul><ul><li><p>方法八: <strong><a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="noopener">ghost element</a></strong></p><p>.ghost-center {</p><pre><code>position: relative;</code></pre><p>}.ghost-center::before {</p><pre><code>content: &quot; &quot;;display: inline-block;height: 100%;width: 1%;vertical-align: middle;</code></pre><p>}.ghost-center p {</p><pre><code>display: inline-block;vertical-align: middle;</code></pre><p>}</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>flex布局总结</title>
      <link href="/203.html"/>
      <url>/203.html</url>
      
        <content type="html"><![CDATA[<p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。</p><h4 id="什么是flex布局"><a href="#什么是flex布局" class="headerlink" title="什么是flex布局"></a>什么是flex布局</h4><p>Flex（Flexible Box），即为”弹性布局”。设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</p><pre><code>.box{    display: -webkit-flex; /* Safari */    display: flex;    display: inline-flex; /* inline元素 */}</code></pre><h4 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h4><p>以下属性设置在flex布局中的父元素（即设有 display:flex的元素），用来控制内部子元素的行为。</p><pre><code>.box {    flex-direction: row(默) | row-reverse | column | column-reverse;    flex-wrap: nowrap(默) | wrap | wrap-reverse;    flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;    justify-content: flex-start(默) | flex-end | center | space-between | space-around;    align-items: flex-start | flex-end | center | baseline | stretch(默);    align-content: flex-start | flex-end | center | space-between | space-around | stretch(默);}</code></pre><ul><li>flex-direction: 子元素的排列方向。<ul><li>row: 水平方向，起点在左端。</li><li>row-reverse: 水平方向，起点在右端。</li><li>column: 垂直方向，起点在上沿。</li><li>column-reverse: 垂直方向，起点在下沿。</li></ul></li><li>flex-wrap: 如果子元素一条线排不下，如何换行。<ul><li>nowrap: 不换行。</li><li>wrap: 换行，第一行在上方。</li><li>wrap-reverse: 换行，第一行在下方。</li></ul></li><li>flex-flow: flex-direction和flex-wrap的简写形式。</li><li>justify-content: 子元素在一条横线上的对齐方式。<ul><li>flex-start: 左对齐。</li><li>flex-end: 右对齐。</li><li>center: 居中。</li><li>space-between: 两端对齐，项目之间的间隔都相等。</li><li>space-around: 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></li><li>align-items: 每个子元素在垂直方向上的对齐方式。<ul><li>flex-start: 对齐顶部。</li><li>flex-end: 对齐底部。</li><li>center: 垂直居中。</li><li>baseline: 子元素的第一行文字的基线对齐。</li><li>stretch: 如果子元素未设置高度或设为auto，将占满整个容器的高度。</li></ul></li><li>align-content: 定义数量超过一行的子元素的垂直对齐方式。<ul><li>flex-start: 对齐顶部。</li><li>flex-end: 对齐底部。</li><li>center: 垂直居中。</li><li>space-between: 垂直两端对齐，轴线之间的间隔平均分布。</li><li>space-around: 垂直两端对齐，每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch: 如果子元素未设置高度或设为auto，将占满整个容器的高度。</li></ul></li></ul><h4 id="容器内子元素的属性"><a href="#容器内子元素的属性" class="headerlink" title="容器内子元素的属性"></a>容器内子元素的属性</h4><pre><code>.item {  order: &lt;integer&gt;; /* 定义子元素的排列顺序。数值越小，排列越靠前，默认为0。 */  flex-grow: &lt;number&gt;; /* 定义子元素的放大比例，默认为0，即如果存在剩余空间，也不放大。 */  flex-shrink: &lt;number&gt;; /* 定义了子元素的缩小比例，默认为1，即如果空间不足，该项目将缩小。 */  flex-basis: &lt;length&gt; | auto; /* 定义了子元素所占固定空间（如100px），默认auto */  flex: &lt;flex-grow&gt; &lt;flex-shrink（可选）&gt; &lt;flex-basis（可选）&gt; ]; /* 快捷值：auto (1 1 auto) 和 none (0 0 auto) */  align-self: auto（默） | flex-start | flex-end | center | baseline | stretch; /* 该属性用来覆盖父元素统一的align-items属性，达到该子元素的个性化 */}</code></pre>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>css画三角形等图标</title>
      <link href="/196.html"/>
      <url>/196.html</url>
      
        <content type="html"><![CDATA[<p>css3的属性 transform(转换) 用途很广泛，功能也很强大，为了熟悉它的各种转换方式(平移 translate，旋转 rotate，扭曲 skew，放缩 scale)，我做了一些平常常用的一些简单的图标。</p><p>这些图标很多是通过三角形来拼贴起来的，所以我们需要知道怎么样画三角形。</p><ol><li><p>我们要将该 div 的 width 和 height 都设置为 0，三角形是通过设置 border 来实现；</p></li><li><p>通过我们需要画成的三角形的目标分析，这个三角形的朝向(只针对规则的朝向：上、右、下、左、上左、上右、下右、下左，不规则的朝向可以通过旋转来实现)；</p></li><li><p>如果是上、右、下、左四种中的一种，将朝向的对面的 border-color 设置为我们需要的颜色，该朝向的这一边不设置 border，其它两边的 border-color 设置为 transparent；</p></li><li><p>如果是上左、上右、下右、下左中的一种，以上右为例，设置相关的两边：上和右的 border-color 设置成我们想要的颜色，其它两边的 border-width 设置成 transparent。</p></li><li><p>border-width 的值就是底边长和高。</p></li></ol><p><strong>三角形</strong></p><p><img src="http://cdn.flqin.com/p196-1.jpg" alt></p><pre><code>.bottom {    width: 0;    height: 0;    border-top: 2em solid #000;    border-right: 1.8em solid transparent;    border-left: 1.8em solid transparent;}</code></pre><p><img src="http://cdn.flqin.com/p196-2.jpg" alt></p><pre><code>.bottomLeft {    width: 0;    height: 0;    border-width: 2em 1em;    border-style: solid;    border-color: transparent transparent #000 #000;}</code></pre><p><img src="http://cdn.flqin.com/p196-3.jpg" alt></p><pre><code>.bottomLeftRotate {    width: 0;    height: 0;    border-width: 2em 1em;    border-style: solid;    border-color: transparent transparent #000 #000;    transform: rotate(60deg);}</code></pre><p><strong>向上</strong></p><p><img src="http://cdn.flqin.com/p196-4.png" alt></p><pre><code>.top {    box-sizing: border-box;    position: relative;    width: 0;    height: 0;    border-right: .9em solid transparent;    border-bottom: .9em solid #000;    border-left: .9em solid transparent;}.top:after {    content: &quot;&quot;; /*针对before,after必须加上*/    position: absolute;    left: 50%;    top: .7em;    margin-left: -.45em; /*宽度的一半，结合 left: 50%; 使用*/    width: .9em;    height: 1.3em;    background-color: #000;}</code></pre><p><strong>向右</strong></p><p><img src="http://cdn.flqin.com/p196-5.png" alt></p><pre><code>.right {    box-sizing: border-box;    position: relative;    width: 1.3em;    height: .9em;    background-color: #000;}.right:after {    content: &quot;&quot;;    position: absolute;    top: 50%;    left: 1.1em;    margin-top: -.9em;    width: 0;    height: 0;    border-top: .9em solid transparent;    border-bottom: .9em solid transparent;    border-left: .9em solid #000;}</code></pre><p><strong>向下</strong></p><p><img src="http://cdn.flqin.com/p196-6.png" alt></p><pre><code>.bottom {    box-sizing: border-box;    position: relative;    width: .9em;    height: 1.3em;    background-color: #000;}.bottom:after {    content: &quot;&quot;;    position: absolute;    left: 50%;    top: 1.1em;    margin-left: -.9em;    width: 0;    height: 0;    border-right: .9em solid transparent;    border-top: .9em solid #000;    border-left: .9em solid transparent;}</code></pre><p><strong>向左</strong></p><p><img src="http://cdn.flqin.com/p196-7.png" alt></p><pre><code>.left {    box-sizing: border-box;    position: relative;    width: 0;    height: 0;    border-top: .9em solid transparent;    border-right: .9em solid #000;    border-bottom: .9em solid transparent;}.left:after {    content: &quot;&quot;;    position: absolute;    top: 0;    bottom: 0; /*在绝对定位中，top: 0; bottom: 0; margin: auto; 结合使用能竖直居中*/    left: .7em;    margin: auto;    width: 1.3em;    height: .9em;    background-color: #000;}</code></pre><p><strong>正确</strong></p><p><img src="http://cdn.flqin.com/p196-8.png" alt></p><pre><code>.true {    position: relative;    width: 1.2em;    height: .3em;    background-color: #000;    transform: rotate(60deg);    transform-origin: right center;    border-radius: .15em;}.true:after {    content: &quot;&quot;;    position: absolute;    top: .1em;    left: -.85em;    width: 2em;    height: .3em;    background-color: #000;    transform: rotate(60deg);    transform-origin: right center;    border-radius: .15em;}</code></pre><p><strong>错误</strong></p><p><img src="http://cdn.flqin.com/p196-9." alt></p><pre><code>.false {    position: relative;    width: 2em;    height: .3em;    background-color: #000;    transform: rotate(45deg);    border-radius: .15em;}.false:after {    content: &quot;&quot;;    position: absolute;    width: 2em;    height: .3em;    background-color: #000;    transform: rotate(90deg);    border-radius: .15em;}</code></pre><p><strong>菜单</strong></p><p><img src="http://cdn.flqin.com/p196-10.png" alt></p><pre><code>.menu {    box-sizing: border-box;    position: relative;    width: 2em;    height: 2em;    background-color: #000;    border-radius: .3em;}.menu:before {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    margin: auto;    width: 1.2em;    height: .15em;    background-color: #fff;}.menu:after {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    margin: auto;    width: 1.2em;    height: .9em;    border-width: .15em;    border-style: solid none;    border-color: #fff;}</code></pre><p><strong>菜单2</strong></p><p><img src="http://cdn.flqin.com/p196-11.png" alt></p><pre><code>.menu2 {    box-sizing: border-box;    position: relative;    width: .5em;    height: .5em;    background-color: #000;    border-radius: 50%;    cursor: pointer;}.menu2:before {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: 0;    left: -.75em;    width: .5em;    height: .5em;    background-color: #000;    border-radius: 50%;}.menu2:after {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: 0;    left: .75em;    width: .5em;    height: .5em;    background-color: #000;    border-radius: 50%;}</code></pre><p><strong>下载</strong></p><p><img src="http://cdn.flqin.com/p196-12.png" alt></p><pre><code>.download {    box-sizing: border-box;    position: relative;    width: 2em;    height: .8em;    border-width: .3em;    border-style: none solid solid;    border-color: #000;}.download:before {    content: &quot;&quot;;    position: absolute;    right: 0;    bottom: .7em;    left: 0;    margin: auto;    width: .3em;    height: 1em;    background-color: #000;}.download:after {    content: &quot;&quot;;    position: absolute;    right: 0;    bottom: .2em;    left: 0;    margin: auto;    width: 0;    height: 0;    border-right: .6em solid transparent;    border-top: .6em solid #000;    border-left: .6em solid transparent;}</code></pre><p><strong>上传</strong></p><p><img src="http://cdn.flqin.com/p196-13.png" alt></p><pre><code>.upload {    box-sizing: border-box;    position: relative;    width: 2em;    height: .8em;    border-width: .3em;    border-style: none solid solid;    border-color: #000;}.upload:before {    content: &quot;&quot;;    position: absolute;    right: 0;    bottom: .2em;    left: 0;    margin: auto;    width: .3em;    height: 1em;    background-color: #000;}.upload:after {    content: &quot;&quot;;    position: absolute;    right: 0;    bottom: 1.1em;    left: 0;    margin: auto;    width: 0;    height: 0;    border-right: .6em solid transparent;    border-bottom: .6em solid #000;    border-left: .6em solid transparent;}</code></pre><p><strong>视频</strong></p><p><img src="http://cdn.flqin.com/p196-14.png" alt></p><pre><code>.video {    box-sizing: border-box;    position: relative;    width: 1.5em;    height: 1.2em;    background-color: #000;    border-radius: .3em;}.video:after {    content: &quot;&quot;;    position: absolute;    top: 50%;    left: 1.4em;    margin-top: -.7em;    width: 0;    height: 0;    border-top: .7em solid transparent;    border-right: .6em solid #000;    border-bottom: .7em solid transparent;}</code></pre><p><strong>语音</strong></p><p><img src="http://cdn.flqin.com/p196-15.png" alt></p><pre><code>.voice {    box-sizing: border-box;    position: relative;    width: 1.4em;    height: 1em;    border-width: .2em;    border-style: none none solid;    border-color: #000;    border-radius: 50%;} .voice:before {    content: &quot;&quot;;    position: absolute;    right: 0;    left: 0;    bottom: .05em;    margin: auto;    width: .8em;    height: 1.3em;    background-color: #000;    border-radius: .4em;}.voice:after {    content: &quot;&quot;;    position: absolute;    right: 0;    bottom: -.6em;    left: 0;    margin: auto;    width: 0;    height: 0;    border-right: .6em solid transparent;    border-bottom: .4em solid #000;    border-left: .6em solid transparent;}</code></pre><p><strong>播放</strong></p><p><img src="http://cdn.flqin.com/p196-16.png" alt></p><pre><code>.play {    box-sizing: border-box;    position: relative;    width: 2em;    height: 2em;    border: .2em solid #000;    border-radius: 50%;}.play:after {    content: &quot;&quot;;    position: absolute;    top: 0;    bottom: 0;    left: 50%;    margin-top: auto;    margin-bottom: auto;    margin-left: -.3em; /*没有让其左右居中，因为看起来右边更空一些*/    width: 0;    height: 0;    border-top: .6em solid transparent;    border-bottom: .6em solid transparent;    border-left: .9em solid #000;}</code></pre><p><strong>暂停</strong></p><p><img src="http://cdn.flqin.com/p196-17.png" alt></p><pre><code>.pause {    box-sizing: border-box;    position: relative;    width: 2em;    height: 2em;    border: .2em solid #000;    border-radius: 50%;}.pause:before {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: 0;    bottom: 0;    left: 50%;    margin-top: auto;    margin-bottom: auto;    margin-left: -.35em;    width: .2em;    height: .9em;    background-color: #000;}.pause:after {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: 0;    bottom: 0;    left: 50%;    margin-top: auto;    margin-bottom: auto;    margin-left: .15em;    width: .2em;    height: .9em;    background-color: #000;}</code></pre><p><strong>上一首(集)</strong></p><p><img src="http://cdn.flqin.com/p196-18.png" alt></p><pre><code>.previous {    box-sizing: border-box;    position: relative;    width: 2em;    height: 2em;    border: .2em solid #000;    border-radius: 50%;}.previous:before {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: 0;    bottom: 0;    left: 50%;    margin-top: auto;    margin-bottom: auto;    margin-left: -.65em;    width: 0;    height: 0;    border-top: .45em solid transparent;    border-bottom: .45em solid transparent;    border-right: .6em solid #000;}.previous:after {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: 0;    bottom: 0;    left: 50%;    margin-top: auto;    margin-bottom: auto;    margin-left: -.2em;    width: 0;    height: 0;    border-top: .45em solid transparent;    border-bottom: .45em solid transparent;    border-right: .6em solid #000;}</code></pre><p><strong>下一首(集)</strong></p><p><img src="http://cdn.flqin.com/p196-19.png" alt></p><pre><code>.next {    box-sizing: border-box;    position: relative;    width: 2em;    height: 2em;    border: .2em solid #000;    border-radius: 50%;}.next:before {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: 0;    bottom: 0;    left: 50%;    margin-top: auto;    margin-bottom: auto;    margin-left: -.4em;    width: 0;    height: 0;    border-top: .45em solid transparent;    border-bottom: .45em solid transparent;    border-left: .6em solid #000;}.next:after {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: 0;    bottom: 0;    left: 50%;    margin-top: auto;    margin-bottom: auto;    margin-left: .05em;    width: 0;    height: 0;    border-top: .45em solid transparent;    border-bottom: .45em solid transparent;    border-left: .6em solid #000;}</code></pre><p><strong>停止</strong></p><p><img src="http://cdn.flqin.com/p196-20.png" alt></p><pre><code>.stop {    box-sizing: border-box;    position: relative;    width: 2em;    height: 2em;    border: .2em solid #000;    border-radius: 50%;}.stop:after {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    margin: auto;    width: .9em;    height: .9em;    background-color: #000;}</code></pre><p><strong>当前位置</strong></p><p><img src="http://cdn.flqin.com/p196-21.png" alt></p><pre><code>.position {    position: relative;    width: .6em;    height: .6em;    border: .4em solid #000;    border-radius: 50%;}.position:after {    content: &quot;&quot;;    position: absolute;    top: .55em;    left: -.4em;    width: 0;    height: 0;    border-top: 1em solid #000;    border-right: .7em solid transparent;    border-left: .7em solid transparent;    border-top-left-radius: 50%;    border-top-right-radius: 50%;}</code></pre><p><strong>pc</strong></p><p><img src="http://cdn.flqin.com/p196-22.png" alt></p><pre><code>.pc {    box-sizing: border-box;    position: relative;    width: 2em;    height: 1.4em;    border-width: .2em .2em .3em;    border-style: solid;    border-color: #000;    border-radius: .2em;    background-color: #efefef;}.pc:before {    content: &quot;&quot;;    position: absolute;    top: 1.2em;    right: 0;    left: 0;    margin: auto;    width: .6em;    height: .4em;    background-color: #000;}.pc:after {    content: &quot;&quot;;    position: absolute;    top: 1.6em;    right: 0;    left: 0;    margin: auto;    width: 1.6em;    height: .2em;    background-color: #000;}</code></pre><p><strong>phone</strong></p><p><img src="http://cdn.flqin.com/p196-23.png" alt></p><pre><code>.phone {    box-sizing: border-box;    position: relative;    width: 1.4em;    height: 2em;    background-color: #efefef;    border-width: .3em .2em .5em;    border-style: solid;    border-color: #000;    border-radius: .15em;}.phone:after {    content: &quot;&quot;;    position: absolute;    right: 0;    bottom: -.4em;    left: 0;    margin: auto;    width: .5em;    height: .3em;    background-color: #fff;    border-radius: .3em;}</code></pre><p><strong>搜索</strong></p><p><img src="http://cdn.flqin.com/p196-24.png" alt></p><pre><code>.search {    box-sizing: border-box;    position: relative;    width: 1em;    height: .3em;    background-color: #000;    border-top-right-radius: .15em;    border-bottom-right-radius: .15em;    transform: rotate(40deg);    transform-origin: right center;} .search:before {    content: &quot;&quot;;    position: absolute;    left: -1.3em;    bottom: -.6em;    width: 1em;    height: 1em;    border: .3em solid #000;    border-radius: 50%;} </code></pre><p><strong>五角星</strong></p><p><img src="http://cdn.flqin.com/p196-25.png" alt></p><pre><code>.star {    box-sizing: border-box;    position: relative;    width: 0;    height: 0;    border-top: .7em solid #000;    border-right: 1em solid transparent;    border-left: 1em solid transparent;}.star:before {    content: &quot;&quot;;    position: absolute;    top: -.7em;    left: -1em;    width: 0;    height: 0;    border-top: .7em solid #000;    border-right: 1em solid transparent;    border-left: 1em solid transparent;    transform: rotate(72deg);}.star:after {    content: &quot;&quot;;    position: absolute;    top: -.7em;    left: -1em;    width: 0;    height: 0;    border-top: .7em solid #000;    border-right: 1em solid transparent;    border-left: 1em solid transparent;    transform: rotate(-72deg);}</code></pre><p><strong>电子邮件</strong></p><p><img src="http://cdn.flqin.com/p196-26.png" alt></p><pre><code>.email {    box-sizing: border-box;    position: relative;    width: 0;    height: 0;    border-width: .7em 1em;    border-style: solid;    border-color: transparent transparent #000 #000;}.email:before {     content: &quot;&quot;;     position: absolute;     top: -.7em;     left: 1em;     transform: rotateY(180deg);     transform-origin: left center;    width: 0;    height: 0;    border-width: .7em 1em;    border-style: solid;    border-color: transparent transparent #000 #000;}.email:after {    content: &quot;&quot;;    position: absolute;    top: -.7em;    left: 50%;    margin-left: -.9em;    width: 0;    height: 0;    border-top: .6em solid #000;    border-right: .9em solid transparent;    border-left: .9em solid transparent;}</code></pre><p><strong>眼睛</strong></p><p><img src="http://cdn.flqin.com/p196-27.png" alt></p><pre><code>.eye {    box-sizing: border-box;    position: relative;    width: 2em;    height: 1.2em;    background-color: #000;    border-radius: 50%;}.eye:before {    content: &quot;&quot;;    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    margin: auto;    width: .8em;    height: .8em;    background-color: #fff;    border-radius: 50%;}.eye:after {    content: &quot;&quot;;    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    margin: auto;    width: .4em;    height: .4em;    background-color: #000;    border-radius: 50%;}</code></pre><p><strong>未锁</strong></p><p><img src="http://cdn.flqin.com/p196-28.png" alt></p><pre><code>.unlock {    box-sizing: border-box;    position: relative;    width: 1.6em;    height: 1.4em;    background-color: #000;    border-radius: .2em;}.unlock:before {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: -.4em;    right: -.4em;    width: 1em;    height: .6em;    border-width: .2em;    border-style: solid solid none;    border-color: #000;    border-radius: .5em;}.unlock:after {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    bottom: .2em;    left: 50%;    margin-left: -.15em;    width: .3em;    height: .5em;    border-top-left-radius: .25em;    border-top-right-radius: .25em;    background-color: #fff;}</code></pre><p><strong>杯子</strong></p><p><img src="http://cdn.flqin.com/p196-29.png" alt></p><pre><code>.cup {    box-sizing: border-box;    position: relative;    width: 1.3em;    height: 2em;    border-width: .2em .2em 1.2em;    border-style: solid;    border-color: #000;    background-color: #efefef;    border-bottom-left-radius: .3em;    border-bottom-right-radius: .3em;}.cup:before {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: .1em;    left: -.7em;    width: .7em;    height: 1.4em;    border-width: .2em;    border-style: solid;    border-color: #000;    border-top-left-radius: .3em;    border-bottom-left-radius: .3em;}</code></pre><p><strong>心</strong></p><p><img src="http://cdn.flqin.com/p196-30.png" alt></p><pre><code>.heart {    position: relative;    width: 1.4em;    height: 2em;    background-color: #000;    border-top-left-radius: 1em;    border-top-right-radius: 1em;    transform: rotate(-45deg);    transform-origin: center bottom;}.heart:after {    content: &quot;&quot;;    position: absolute;    top: -.7em;    left: -.7em;    width: 1.4em;    height: 2em;    background-color: #000;    border-top-left-radius: 1em;    border-top-right-radius: 1em;    transform: rotate(90deg);    transform-origin: center bottom;}</code></pre><p><strong>主页</strong></p><p><img src="http://cdn.flqin.com/p196-31.png" alt></p><pre><code>.home {    box-sizing: border-box;    position: relative;    width: 1.4em;    height: 1em;    background-color: #000;} .home:before {    content: &quot;&quot;;    position: absolute;    top: -.7em;    left: 50%;    margin-left: -1em;    border-left: 1em solid transparent;    border-right: 1em solid transparent;    border-bottom: .8em solid #000;}.home:after {    z-index: 2;    content: &quot;&quot;;    position: absolute;    right: 0;    bottom: 0;    left: 0;    margin: auto;    width: .3em;    height: .5em;    background-color: #fff;}</code></pre><p><strong>密码</strong></p><p><img src="http://cdn.flqin.com/p196-32.png" alt></p><pre><code>.password {    box-sizing: border-box;    position: relative;    width: 1.8em;    height: 1.4em;    background-color: #000;    border-radius: .2em;}.password:before {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    top: -.6em;    left: 50%;    margin-left: -.5em;    width: 1em;    height: 1em;    border: .2em solid #000;    border-radius: 50%;}.password:after {    box-sizing: border-box;    content: &quot;&quot;;    position: absolute;    bottom: .2em;    left: 50%;    margin-left: -.15em;    width: .3em;    height: .5em;    border-top-left-radius: .25em;    border-top-right-radius: .25em;    background-color: #fff;}</code></pre><p><strong>用户(账号)</strong></p><p><img src="http://cdn.flqin.com/p196-33.png" alt></p><pre><code>.user {    box-sizing: border-box;    position: relative;    width: .9em;    height: .9em;    background-color: #000;    border-radius: 50%;}.user:after {    content: &quot;&quot;;    position: absolute;    top: 1em;    left: 50%;    margin-left: -.9em;    width: 1.8em;    height: 1em;    background-color: #000;    border-top-left-radius: .9em;    border-top-right-radius: .9em;}</code></pre><p><strong>菜单3</strong></p><p><img src="http://cdn.flqin.com/p196-34.png" alt></p><pre><code>#menu {    color: #000;    display: block;    width: 50px;    height: 50px;    box-sizing: border-box;    border-top: 10px solid; /*没有设置颜色值，将同文本颜色一样*/    border-bottom: 10px solid;    padding-top: 10px;    padding-bottom: 10px;    background-color: currentColor; /*颜色关键字，将同文本颜色一致*/    background-clip: content-box; /*背景将绘制在内容方框内*/}</code></pre>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS实现单行、多行文本溢出显示省略号</title>
      <link href="/192.html"/>
      <url>/192.html</url>
      
        <content type="html"><![CDATA[<h3 id="单行文本的溢出"><a href="#单行文本的溢出" class="headerlink" title="单行文本的溢出"></a>单行文本的溢出</h3><pre><code>overflow: hidden;text-overflow:ellipsis;white-space: nowrap;</code></pre><p><img src="http://cdn.flqin.com/p192-1.png" alt></p><h3 id="多行文本的溢出"><a href="#多行文本的溢出" class="headerlink" title="多行文本的溢出"></a>多行文本的溢出</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><pre><code>p{    display: -webkit-box;    -webkit-box-orient: vertical;    -webkit-line-clamp: 3;    overflow: hidden;}</code></pre><p><img src="http://cdn.flqin.com/p192-2.png" alt></p><p><strong>适用范围</strong></p><p>因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端。</p><p>注：</p><ol><li><p>-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：</p></li><li><p>display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。</p></li><li><p>-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。</p></li></ol><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><pre><code>p {        position: relative;        line-height: 20px;        max-height: 40px;        overflow: hidden;    }    p::after {        content: &quot;...&quot;;        position: absolute;        bottom: 0;        right: 0;        padding-left: 40px;        background: linear-gradient(to right, transparent, #fff 55%);    }</code></pre><p><img src="http://cdn.flqin.com/p192-3.png" alt></p><p><strong>适用范围</strong></p><p>该方法适用范围广，但文字未超出行的情况下也会出现省略号,可结合js优化该方法。</p><p>注：</p><ol><li><p>将height设置为line-height的整数倍，防止超出的文字露出。</p></li><li><p>给p::after添加渐变背景可避免文字只显示一半。</p></li><li><p>由于ie6-7不显示content内容，所以要添加标签兼容ie6-7（如：…）；兼容ie8需要将::after替换成:after。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS选择器的权重与优先规则</title>
      <link href="/189.html"/>
      <url>/189.html</url>
      
        <content type="html"><![CDATA[<p>我们在使用CSS对网页元素定义样式时经常会遇到这种情况：要对一般元素应用一般样式，然后在更特殊的元素上覆盖它们。那么我们怎么样来保证我们所新定义的元素样式能覆盖目标元素上原有的样式呢？</p><p>在CSS中，会根据选择器的特殊性来决定所定义的样式规则的次序，具有更特殊选择器的规则优先于具有一般选择器的规则，如果两个规则的特殊性相同，那么后定义的规则优先。</p><p>那么，又怎么来计算选择器的特殊性呢？下面这张图介绍了特殊性的计算方法：</p><p><img src="http://cdn.flqin.com/p189-1.jpg" alt></p><p>我们把特殊性分为4个等级，每个等级代表一类选择器，每个等级的值为其所代表的选择器的个数乘以这一等级的权值，最后把所有等级的值相加得出选择器的特殊值。</p><p>4个等级的定义如下：</p><ul><li>第一等：代表内联样式，如: style=””，权值为1000。</li><li>第二等：代表ID选择器，如：#content，权值为100。</li><li>第三等：代表类，伪类和属性选择器，如.content，权值为10。</li><li>第四等：代表类型选择器和伪元素选择器，如div p，权值为1。</li></ul><p>例如上图为例，其中#NAV为二等选择器，.ACTIVE为三等选择器，UL、LI和A为四等选择器。则整个选择器表达式的特殊性的值为1_100+1_10+3*1=113</p><p>下面是一些计算示例：</p><p><img src="http://cdn.flqin.com/p189-2.jpg" alt></p><p>注意：通用选择器（*），子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以他们的权值都为0。</p><p>我们再来看一个具体的例子：假如有以下组样式规则，你能判断出HTML代码中的两个标题是什么颜色吗？</p><pre><code>#content div#main-content h2{    color:red;}#content #main-content&gt;h2{    color:blue;}body #content div[id=&quot;main-content&quot;] h2{    color:green;}#main-content div.paragraph h2{    color:orange;}#main-content [class=&quot;paragraph&quot;] h2{    color:yellow;}div#main-content div.paragraph h2.first{    color:pink;}</code></pre><p>以下是HTML代码：</p><pre><code>&lt;div id=&quot;content&quot;&gt;    &lt;div id=&quot;main-content&quot;&gt;        &lt;h2&gt;CSS简介&lt;/h2&gt;        &lt;p&gt;CSS（Cascading Style Sheet，可译为“层叠样式表”或“级联样式表”）是一组格式设置规则，用于控制Web页面的外观。&lt;/p&gt;        &lt;div class=&quot;paragraph&quot;&gt;            &lt;h2 class=&quot;first&quot;&gt;使用CSS布局的优点&lt;/h2&gt;            &lt;p&gt;1、表现和内容相分离 2、提高页面浏览速度 3、易于维护和改版 4、使用CSS布局更符合现在的W3C标准.&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>判断出来了么？答案是：两个标题都是红色的！</p><p>让我们来一起算算六个样式规则各自的特殊性的值：</p><ul><li>第一个特殊性的值=2_100+2_1=202</li><li>第二个特殊性的值=2*100+1=201</li><li>第三个特殊性的值=1_100+1_10+3*1=113</li><li>第四个特殊性的值=1_100+1_10+2*1=112</li><li>第五个特殊性的值=1_100+1_10+1*1=111</li><li>第六个特殊性的值=1_100+2_10+3*1=123</li></ul><p>清楚了吧，第一个样式规则以其202的高分一举夺得了本次样式选择器特殊性大赛的冠军，后面一些规则虽然看起来好像更复杂，但特殊性并不是拼谁的选择器表达式写得更长，ID选择器才是王道！</p><p>理解选择器的特殊性很重要，特别是在修复bug的时候，因为你需要了解哪些规则优先及其原因。</p><p>如果你遇到了似乎没有起作用的CSS规则，很可能是出现了特殊性冲突。请在你的选择器中添加他的一个父元素的ID，从而提高它的特殊性。如果这能解决问题，就说明样式表中其他地方很可能有更特殊的规则，它覆盖了你的规则。如果是这种情况，你可能需要检查代码，解决特殊性冲突，让代码尽可能简洁。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS3中:nth-child和:nth-of-type的区别深入理解</title>
      <link href="/184.html"/>
      <url>/184.html</url>
      
        <content type="html"><![CDATA[<p>关于:nth-child和:nth-of-type的区别之前一直没太注意。最近打算深入了解一些CSS3，才发现里面其实暗藏玄机。</p><p>:nth-child可以选择父元素下的字元素，:nth-of-type也可以。但是它们到底有什么区别呢？</p><p>其实区别很简单：:nth-of-type为什么要叫:nth-of-type？因为它是以”type”来区分的。也就是说：ele:nth-of-type(n)是指父元素下第n个ele元素，</p><p>而ele:nth-child(n)是指父元素下第n个元素且这个元素为ele，若不是，则选择失败。</p><p>eg:</p><pre><code>&lt;div&gt;    &lt;ul class=&quot;demo&quot;&gt;        &lt;p&gt;zero&lt;/p&gt;        &lt;li&gt;one&lt;/li&gt;        &lt;li&gt;two&lt;/li&gt;    &lt;/ul&gt;   &lt;/div&gt;</code></pre><p>上面这个例子，.demo li:nth-child(2)选择的是<li>one</li>节点，而.demo li:nth-of-type(2)则选择的是<li>two</li>节点。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>css3 media媒体查询器用法总结</title>
      <link href="/180.html"/>
      <url>/180.html</url>
      
        <content type="html"><![CDATA[<p>随着响应式设计模型的诞生，Web网站又要发生翻天腹地的改革浪潮，可能有些人会觉得在国内IE6用户居高不下的情况下，这些新的技术还不会广泛的蔓延下去，那你就错了，如今淘宝，凡客，携程等等公司都已经在大胆的尝试了这项技术，并完美的应用在了自己的网站上了。再不更新知识你就老了。我今天就总结一下响应式设计的核心CSS技术Media(媒体查询器)的用法。</p><p><strong>准备工作1：设置Meta标签</strong></p><p>首先我们在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果：</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</code></pre><p>这段代码的几个参数解释：</p><ul><li>width = device-width：宽度等于当前设备的宽度</li><li>initial-scale：初始的缩放比例（默认设置为1.0）</li><li>minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）</li><li>maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）</li><li>user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）</li></ul><p><strong>准备工作2：加载兼容文件JS</strong></p><p>因为IE8既不支持HTML5也不支持CSS3 Media，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果：</p><pre><code>&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;</code></pre><p><strong>准备工作3：设置IE渲染方式默认为最高(这部分可以选择添加也可以不添加)</strong></p><p>现在有很多人的IE浏览器都升级到IE9以上了，所以这个时候就有又很多诡异的事情发生了，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8。 为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新的：</p><pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;   </code></pre><p>太给力了。 不过我最近又发现了一个更给力的写法：</p><pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge，chrome=1&quot;&gt;</code></pre><p>怎么这段代码后面加了一个chrome=1，这个Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果有的用户电脑里面装了这个chrome的插件，就可以让电脑里面的IE不管是哪个版本的都可以使用Webkit引擎及V8引擎进行排版及运算，无比给力，不过如果用户没装这个插件，那这段代码就会让IE以最高的文档模式展现效果。这段代码我还是建议你们用上，不过不用也是可以的。</p><p><strong>进入CSS3 Media写法</strong></p><p>我们先来看下下面这段代码，估计很多人在响应式的网站CSS很经常看到类似下面的这段代码：</p><pre><code>@media screen and (max-width: 960px){    body{        background: #000;    }}</code></pre><p>这个应该算是一个media的一个标准写法，上面这段CSS代码意思是：当页面小于960px的时候执行它下面的CSS.这个应该没有太大疑问。</p><p>应该有人会发现上面这段代码里面有个screen，他的意思是在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。但是目前我发现很多网站都会直接省略screen,因为你的网站可能不需要考虑用户去打印时，你可以直接这样写：</p><pre><code>@media (max-width: 960px){    body{        background: #000;    }}</code></pre><p><strong>CSS2 Media用法</strong></p><p>其实并不是只有CSS3才支持Media的用法，早在CSS2开始就已经支持Media，具体用法，就是在HTML页面的head标签中插入如下的一段代码：</p><pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;style.css&quot;&gt;</code></pre><p>上面其实是CSS2实现的衬线用法，那CSS3的media难道就只能支持上面这一个功能吗？答案当然不是，他还有很多用法。 例如我们想知道现在的移动设备是不是纵向放置的显示屏，可以这样写：</p><pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen and (orientation:portrait)&quot; href=&quot;style.css&quot;&gt;</code></pre><p>我们把第一段的代码也用CSS2来实现，让它一样可以让页面宽度小于960的执行指定的样式文件：</p><pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen and (max-width:960px)&quot; href=&quot;style.css&quot;&gt;</code></pre><p>既然CSS2可以实现CSS的这个效果为什么不用这个方法呢，很多人应该会问，但是上面这个方法，最大的弊端是他会增加页面http的请求次数，增加了页面负担，我们用CSS3把样式都写在一个文件里面才是最佳的方法。</p><p><strong>回归CSS3 Media</strong></p><p>上面我们大概讲了下CSS2的媒体查询用法，现在我们重新回到CSS3的媒体查询，在第一段代码上面我用的是小于960px的尺寸的写法，那现在我们来实现等于960px尺寸的代码：</p><pre><code>@media screen and (max-device-width:960px){    body{        background:red;    }}</code></pre><p>然后就是当浏览器尺寸大于960px时候的代码了：</p><pre><code>@media screen and (min-width:960px){    body{        background:orange;    }}</code></pre><p>我们还可以混合使用上面的用法：</p><pre><code>@media screen and (min-width:960px) and (max-width:1200px){    body{        background:yellow;    }}</code></pre><p>上面的这段代码的意思是当页面宽度大于960px小于1200px的时候执行下面的CSS。</p><p><strong>Media所有参数汇总</strong></p><p>以上就是我们最常需要用到的媒体查询器的三个特性，大于，等于，小于的写法。媒体查询器的全部功能肯定不止这三个功能，下面是我总结的它的一些参数用法解释：</p><ul><li>width:浏览器可视宽度。</li><li>height:浏览器可视高度。</li><li>device-width:设备屏幕的宽度。</li><li>device-height:设备屏幕的高度。</li><li>orientation:检测设备目前处于横向还是纵向状态。</li><li>aspect-ratio:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9)</li><li>device-aspect-ratio:检测设备的宽度和高度的比例。</li><li>color:检测颜色的位数。（例如：min-color:32就会检测设备是否拥有32位颜色）</li><li>color-index:检查设备颜色索引表中的颜色，他的值不能是负数。</li><li>monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到）</li><li>resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。</li><li>grid：检测输出的设备是网格的还是位图设备。</li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搞清clientHeight、scrollHeight、offsetHeight和scrollTop的区别与联系</title>
      <link href="/178.html"/>
      <url>/178.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://cdn.flqin.com/body.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>测试屏幕宽高</title>
      <link href="/174.html"/>
      <url>/174.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.flqin.com/demo/screen-test.html" target="_blank" rel="noopener">点此测试</a></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML中   等6种空白空格的区别</title>
      <link href="/167.html"/>
      <url>/167.html</url>
      
        <content type="html"><![CDATA[<p>HTML提供了5种空格实体（space entity），它们拥有不同的宽度，非断行空格（&nbsp;）是常规空格的宽度，可运行于所有主流浏览器。其他几种空格（&ensp; &emsp; &thinsp; &zwnj; &zwj; ）在不同浏览器中宽度各异。</p><p><strong>&nbsp;</strong></p><p>它叫不换行空格，全称No-Break Space，它是最常见和我们使用最多的空格，大多数的人可能只接触了 ，它是按下space键产生的空格。在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个）。要使用html实体表示才可累加，该空格占据宽度受字体影响明显而强烈。</p><p><strong>&ensp;</strong></p><p>它叫“半角空格”，全称是En Space，en是字体排印学的计量单位，为em宽度的一半。根据定义，它等同于字体度的一半（如16px字体中就是8px）。名义上是小写字母n的宽度。此空格传承空格家族一贯的特性：透明的，此空格有个相当稳健的特性，就是其占据的宽度正好是1/2个中文宽度，而且基本上不受字体影响。</p><p><strong>&emsp;</strong></p><p>它叫“全角空格”，全称是Em Space，em是字体排印学的计量单位，相当于当前指定的点数。例如，1 em在16px的字体中就是16px。此空格也传承空格家族一贯的特性：透明的，此空格也有个相当稳健的特性，就是其占据的宽度正好是1个中文宽度，而且基本上不受字体影响。</p><p><strong>&thinsp;</strong></p><p>它叫窄空格，全称是Thin Space。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。它是em之六分之一宽。</p><p><strong>&zwnj;</strong></p><p>它叫零宽不连字，全称是Zero Width Non Joiner，简称“ZWNJ”，是一个不打印字符，放在电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制。Unicode中的零宽不连字字符映射为“”（zero width non-joiner，U+200C），HTML字符值引用为： ‌</p><p><strong>&zwj;</strong></p><p>它叫零宽连字，全称是Zero Width Joiner，简称“ZWJ”，是一个不打印字符，放在某些需要复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果。零宽连字符的Unicode码位是U+200D (HTML: &#8205; &zwj;）。</p><p>此外，浏览器还会把以下字符当作空白进行解析：空格（&#x0020;）、制表位（&#x0009;）、换行（&#x000A;）和回车（&#x000D;）还有（&#12288;）等等。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IE6/IE7/IE8/IE9/FF的CSS Hacks</title>
      <link href="/158.html"/>
      <url>/158.html</url>
      
        <content type="html"><![CDATA[<h3 id="IE6-IE7-FF的CSS-Hacks"><a href="#IE6-IE7-FF的CSS-Hacks" class="headerlink" title="IE6/IE7/FF的CSS Hacks"></a>IE6/IE7/FF的CSS Hacks</h3><h4 id="区别IE和非IE浏览器"><a href="#区别IE和非IE浏览器" class="headerlink" title="区别IE和非IE浏览器"></a>区别IE和非IE浏览器</h4><pre><code>#tip {    background:blue; /*非IE 背景藍色*/    background:red \9; /*IE6、IE7、IE8背景紅色*/}</code></pre><h4 id="区别IE6-IE7-IE8-FF"><a href="#区别IE6-IE7-IE8-FF" class="headerlink" title="区别IE6,IE7,IE8,FF"></a>区别IE6,IE7,IE8,FF</h4><p>【区别符号】：「\9」、「*」、「_」 【示例】：</p><pre><code>#ue{ /*Firefox 背景变蓝色*/    background:red \9; /*IE8 背景变红色*/    *background:black; /*IE7 背景变黑色*/    _background:orange; /*IE6 背景变橘色*/}</code></pre><p>【说明】：因为IE系列浏览器可读「\9」，而IE6和IE7可读「*」(米字号)，另外IE6可辨识「_」(底线)，因此可以依照顺序写下来，就会让浏 览器正确的读取到自己看得懂得CSS语法，所以就可以有效区分IE各版本和非IE浏览器(像是Firefox、Opera、Google Chrome、Safari等)。</p><h4 id="区别IE6、IE7、Firefox-方法-1"><a href="#区别IE6、IE7、Firefox-方法-1" class="headerlink" title="区别IE6、IE7、Firefox (方法 1)"></a>区别IE6、IE7、Firefox (方法 1)</h4><p>【区别符号】：「*」、「_」 【示例】：</p><pre><code>#tip {    background:blue; /*Firefox背景变蓝色*/    *background:black; /*IE7 背景变黑色*/    _background:orange; /*IE6 背景变橘色*/}</code></pre><p>【说明】：IE7和IE6可读「<em>」(米字号)，IE6又可以读「**」(底线)，但是IE7却无法读取「</em>」，至于Firefox(非IE浏览器)则完全无法辨识「」和「_」，因此就可以透过这样的差异性来区分IE6、IE7、Firefox。</p><h4 id="区别IE6、IE7、Firefox-方法-2"><a href="#区别IE6、IE7、Firefox-方法-2" class="headerlink" title="区别IE6、IE7、Firefox (方法 2)"></a>区别IE6、IE7、Firefox (方法 2)</h4><p>【区别符号】：「*」、「!important」 【示例】：</p><pre><code>#tip {    background:blue; /*Firefox 背景变蓝色*/    *background:green !important; /*IE7 背景变绿色*/    *background:orange; /*IE6 背景变橘色*/}</code></pre><p>【说明】：IE7可以辨识「_」和「!important」，但是IE6只可以辨识「_」，却无法辨识「!important」，至于Firefox可以读取「!important」但不能辨识「*」因此可以透过这样的差异来有效区隔IE6、IE7、Firefox。</p><h4 id="区别IE7、Firefox"><a href="#区别IE7、Firefox" class="headerlink" title="区别IE7、Firefox"></a>区别IE7、Firefox</h4><p>【区别符号】：「*」、「!important」 【示例】：</p><pre><code>#tip {    background:blue; /*Firefox 背景变蓝色*/    *background:green !important; /*IE7 背景变绿色*/}</code></pre><p>【说明】：因为Firefox可以辨识「!important」但却无法辨识「_」，而IE7则可以同时看懂「_」、「!important」，因此可以两个辨识符号来区隔IE7和Firefox。</p><h4 id="区别IE6、IE7-方法-1"><a href="#区别IE6、IE7-方法-1" class="headerlink" title="区别IE6、IE7 (方法 1)"></a>区别IE6、IE7 (方法 1)</h4><p>【区别符号】：「*」、「_」 【示例】：</p><pre><code>#tip {    *background:black; /*IE7 背景变黑色*/    _background:orange; /*IE6 背景变橘色*/}</code></pre><p>【说明】：IE7和IE6都可以辨识「*」(米字号)，但IE6可以辨识「_」(底线)，IE7却无法辨识，透过IE7无法读取「_」的特性就能轻鬆区隔IE6和IE7之间的差异。</p><h4 id="区别IE6、IE7-方法-2"><a href="#区别IE6、IE7-方法-2" class="headerlink" title="区别IE6、IE7 (方法 2)"></a>区别IE6、IE7 (方法 2)</h4><p>【区别符号】：「!important」 【示例】：</p><pre><code>#tip {    background:black !important; /*IE7 背景变黑色*/    background:orange; /*IE6 背景变橘色*/}</code></pre><p>【说明】：因为IE7可读取「!important;」但IE6却不行，而CSS的读取步骤是从上到下，因此IE6读取时因无法辨识「!important」而直接跳到下一行读取CSS，所以背景色会呈现橘色。</p><h4 id="区别IE6、Firefox"><a href="#区别IE6、Firefox" class="headerlink" title="区别IE6、Firefox"></a>区别IE6、Firefox</h4><p>【区别符号】：「_」 【示例】：</p><pre><code>#tip {    background:black; /*Firefox 背景变黑色*/    _background:orange; /*IE6 背景变橘色*/}</code></pre><p>【说明】：因为IE6可以辨识「_」(底线)，但是Firefox却不行，因此可以透过这样的差异来区隔Firefox和IE6，有效达成CSS hack。</p><h4 id="IE-6-ONLY"><a href="#IE-6-ONLY" class="headerlink" title="IE-6 ONLY"></a>IE-6 ONLY</h4><pre><code>* html #div {      height: 300px;  }</code></pre><h4 id="NON-IE-7-ONLY"><a href="#NON-IE-7-ONLY" class="headerlink" title="NON IE-7 ONLY"></a>NON IE-7 ONLY</h4><pre><code>#div {     _height: 300px;  }</code></pre><h4 id="Hide-from-IE-6-and-LOWER"><a href="#Hide-from-IE-6-and-LOWER" class="headerlink" title="Hide from IE 6 and LOWER"></a>Hide from IE 6 and LOWER</h4><pre><code>#div {     height/**/: 300px;  }html &amp;gt; body #div {        height: 300px;  }</code></pre><h3 id="浏览器专属-CSS-Hack-区分-Firefox-Opera-Safari-Internet-Explorer"><a href="#浏览器专属-CSS-Hack-区分-Firefox-Opera-Safari-Internet-Explorer" class="headerlink" title="浏览器专属 CSS Hack:区分 Firefox / Opera / Safari / Internet Explorer"></a>浏览器专属 CSS Hack:区分 Firefox / Opera / Safari / Internet Explorer</h3><pre><code>/* Opera */  html:first-child #opera  {  display: block;  }  /* IE 7 */ *:first-child+html{background-color:#F00;}/* IE 7 */  html &amp;gt; body #ie7  {  *display: block;  }  /* IE 6 */ * html #div{ background-color:#F00;}/* IE 6 */  body #ie6  {  _display: block;  } /*IE7及其更低版本*/*:first-child+html{}*html{}/*IE7,IE7以上和主流浏览器*/html&amp;gt;body{}/*适合主流浏览器(IE7排除在外，IE7以下的也不行)*/ html&amp;gt;/**/body{}/* Firefox 1 - 2 */  body:empty #firefox12  {  display: block;  }  /* Firefox */  @-moz-document url-prefix()  {  #firefox { display: block; }  } /* Safari */  @media screen and (-webkit-min-device-pixel-ratio:0)  {  #safari { display: block; }  } /* Opera */  @media all and (-webkit-min-device-pixel-ratio:10000), not all and (-webkit-min-device-pixel-ratio:0)  {  head~body #opera { display: block; }  }</code></pre><h3 id="最新的浏览器CSS-Hacks"><a href="#最新的浏览器CSS-Hacks" class="headerlink" title="最新的浏览器CSS Hacks"></a>最新的浏览器CSS Hacks</h3><pre><code>/* IE6 and below */ * html #uno  { color: red } /* IE7 */ *:first-child+html #dos { color: red }  *+html #dieciocho {  color: red }/* Safari 2-3 */ html[xmlns*=&quot;&quot;] body:last-child #seis { color: red/* webkit and opera */ @media all and (min-width: 0px){ .big{padding:11px;} }  /* webkit */ @media screen and (-webkit-min-device-pixel-ratio:0){ .big{padding:11px;} } /* opera */  @media all and (-webkit-min-device-pixel-ratio:10000), not all and (-webkit-min-device-pixel-ratio:0) { .big{padding:11px;} } /* firefox * / @-moz-document url-prefix(){ .big{padding:11px;}} /* all firefox */  #veinticinco,  x:-moz-any-link, x:default  { color: red }/* Firefox 3.0+ */ html&amp;gt;/**/body .big, x:-moz-any-link, x:default { padding:11px; } /* newest firefox */</code></pre><p><img src="http://cdn.flqin.com/css-hack.png" alt="css-hack"></p><p><strong>ps</strong>：IE6不支持!important，是指不支持important的优先级，并不影响css属性值的解析。比如“color:green!important;color:red;”，除了在IE6下字体颜色解析为红色，其他（你懂的）浏览器下都是绿色。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IE条件注释</title>
      <link href="/130.html"/>
      <url>/130.html</url>
      
        <content type="html"><![CDATA[<p>我们知道，IE6的存在，因其预装于目前市场占有率最大的 Windows XP 操作系统。对于老态龙钟的IE6，说拜拜还需要很长的时间。</p><p>IE虽然给我们网页设计师，带来了不少多麻烦，还好，IE条件注释，给我们解决浏览器兼容问题带来了一个很好的方法。</p><h2 id="一、什么是IE条件注释？"><a href="#一、什么是IE条件注释？" class="headerlink" title="一、什么是IE条件注释？"></a>一、什么是IE条件注释？</h2><p>IE条件注释，顾名思义就是使用IE特有的条件语句来显示代码块。</p><p>这些巧妙的逻辑片段只能被IE浏览器所支持，其它的浏览器理解为纯粹的HTML注释，不起任何作用。条件注释在IE5中首次出现，并且得到了Widnows浏览器所有后续版本的支持。IE条件注释及其有效，而且非常容易记住。通过这些技巧，我们可以为基于Windows的IE5、6、7、8添加一些特殊的行为。这样做的好处是，HTML和CSS代码可以通过验证。主要的缺点是这些注释需要放在HTML页面中，而不是放在CSS中。这样，当你不需要这些东西，或者有所更改的时候，就需要维护很多的地方。好处是通过这种方式使用条件注释，可以很轻松的管理项目中的目标浏览器，并使得CSS补丁文件保持独立自由。更重要的是它帮助我们优化了 CSS样式表，保证了主要样式表的干净，这对于大型网站来说就很重要了，也许你还没有感觉到它的可爱之处。</p><p>作为有Web标准意识的开发者，我们始终应该首先在大部分现有的兼容标准的浏览器上测试我们的设计，然后再为那些稍作细微修改就能回到正轨的浏览器提供补丁。</p><h2 id="二、条件注释使用方法"><a href="#二、条件注释使用方法" class="headerlink" title="二、条件注释使用方法"></a>二、条件注释使用方法</h2><h3 id="条件注释属性"><a href="#条件注释属性" class="headerlink" title="条件注释属性"></a>条件注释属性</h3><ul><li><strong>gt</strong> : greater than，选择条件版本以上版本，不包含条件版本</li><li><strong>lt</strong> : less than，选择条件版本以下版本，不包含条件版本</li><li><strong>gte</strong> : greater than or equal，选择条件版本以上版本，包含条件版本</li><li><strong>lte</strong> : less than or equal，选择条件版本以下版本，包含条件版本</li><li><strong>!</strong> : 选择条件版本以外所有版本，无论高低</li></ul><h3 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h3><p>我们概括性地说明一下你如何使用条件注释，首先，我们应该把你所有的CSS 等CSS文件放在中。条件注释的基本结构和HTML的注释()是一样的。因此 ，IE以外的浏览器将会把它们看 作是普通的注释而完全忽略它们。IE将会根据if条件来判断是否如解析普通的页面内容一样解析条件注释里的内容。条件注释使用的是HTML的注释结构，因此他们只能使用在HTML文件里，而不能在CSS文件中使用。</p><h4 id="Target-ALL-VERSIONS-of-IE（-所有的IE可识别-）"><a href="#Target-ALL-VERSIONS-of-IE（-所有的IE可识别-）" class="headerlink" title="Target ALL VERSIONS of IE（ 所有的IE可识别 ）"></a>Target ALL VERSIONS of IE（ 所有的IE可识别 ）</h4><pre><code>&lt;!-- [if IE]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;all-ie-only.css&quot; /&gt;&lt;![endif]--&gt;</code></pre><h4 id="Target-everything-EXCEPT-IE-（除IE外都可识别-）"><a href="#Target-everything-EXCEPT-IE-（除IE外都可识别-）" class="headerlink" title="Target everything EXCEPT IE （除IE外都可识别 ）"></a>Target everything EXCEPT IE （除IE外都可识别 ）</h4><pre><code>&lt;!-- [if !IE]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;not-ie.css&quot; /&gt;&lt;![endif]--&gt;</code></pre><h4 id="Target-IE-7-ONLY-（-仅IE7可识别-）"><a href="#Target-IE-7-ONLY-（-仅IE7可识别-）" class="headerlink" title="Target IE 7 ONLY （ 仅IE7可识别 ）"></a>Target IE 7 ONLY （ 仅IE7可识别 ）</h4><pre><code>&lt;!-- [if IE 7]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie7.css&quot;&gt;&lt;![endif]--&gt;</code></pre><h4 id="Target-IE-6-ONLY（仅IE6可识别）"><a href="#Target-IE-6-ONLY（仅IE6可识别）" class="headerlink" title="Target IE 6 ONLY（仅IE6可识别）"></a>Target IE 6 ONLY（仅IE6可识别）</h4><pre><code>&lt;!-- [if IE 6]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie6.css&quot; /&gt;&lt;![endif]--&gt;</code></pre><h4 id="Target-IE-5-ONLY（只有IE5可以识别）"><a href="#Target-IE-5-ONLY（只有IE5可以识别）" class="headerlink" title="Target IE 5 ONLY（只有IE5可以识别）"></a>Target IE 5 ONLY（只有IE5可以识别）</h4><pre><code>&lt;!-- [if IE 5]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie5.css&quot; /&gt;&lt;![endif]--&gt;</code></pre><h4 id="Target-IE-5-5-ONLY（只有IE5-5可以识别）"><a href="#Target-IE-5-5-ONLY（只有IE5-5可以识别）" class="headerlink" title="Target IE 5.5 ONLY（只有IE5.5可以识别）"></a>Target IE 5.5 ONLY（只有IE5.5可以识别）</h4><pre><code>&lt;!-- [if IE 5.5000]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie55.css&quot; /&gt;&lt;![endif]--&gt;</code></pre><h4 id="Target-IE-6-and-LOWER（IE6和IE6以下的）"><a href="#Target-IE-6-and-LOWER（IE6和IE6以下的）" class="headerlink" title="Target IE 6 and LOWER（IE6和IE6以下的）"></a>Target IE 6 and LOWER（IE6和IE6以下的）</h4><pre><code>&lt;!-- [if lt IE 7]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie6-and-down.css&quot; /&gt;&lt;![endif]--&gt;&lt;!-- [if lte IE 6]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie6-and-down.css&quot; /&gt;&lt;![endif]--&gt;</code></pre><h4 id="Target-IE-7-and-LOWER（IE7和IE7以下的）"><a href="#Target-IE-7-and-LOWER（IE7和IE7以下的）" class="headerlink" title="Target IE 7 and LOWER（IE7和IE7以下的）"></a>Target IE 7 and LOWER（IE7和IE7以下的）</h4><pre><code>&lt;!-- [if lt IE 8]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie7-and-down.css&quot; /&gt;&lt;![endif]--&gt;&lt;!-- [if lte IE 7]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie7-and-down.css&quot; /&gt;&lt;![endif]--&gt;</code></pre><h4 id="Target-IE-8-and-LOWER（IE8和IE8以下的）"><a href="#Target-IE-8-and-LOWER（IE8和IE8以下的）" class="headerlink" title="Target IE 8 and LOWER（IE8和IE8以下的）"></a>Target IE 8 and LOWER（IE8和IE8以下的）</h4><pre><code>&lt;!-- [if lt IE 9]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie8-and-down.css&quot; /&gt;&lt;![endif]--&gt;&lt;!-- [if lte IE 8]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie8-and-down.css&quot; /&gt;&lt;![endif]--&gt;</code></pre><h4 id="Target-IE-6-and-HIGHER（IE6和IE6以上的）"><a href="#Target-IE-6-and-HIGHER（IE6和IE6以上的）" class="headerlink" title="Target IE 6 and HIGHER（IE6和IE6以上的）"></a>Target IE 6 and HIGHER（IE6和IE6以上的）</h4><pre><code>&lt;!-- [if gt IE 5.5]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie6-and-up.css&quot; /&gt;&lt;![endif]--&gt;&lt;!-- [if gte IE 6]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie6-and-up.css&quot; /&gt;&lt;![endif]--&gt;</code></pre><h4 id="Target-IE-7-and-HIGHER（IE7和IE7以上的）"><a href="#Target-IE-7-and-HIGHER（IE7和IE7以上的）" class="headerlink" title="Target IE 7 and HIGHER（IE7和IE7以上的）"></a>Target IE 7 and HIGHER（IE7和IE7以上的）</h4><pre><code>&lt;!-- [if gt IE 6]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie7-and-up.css&quot; /&gt;&lt;![endif]--&gt;&lt;!-- [if gte IE 7]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie7-and-up.css&quot; /&gt;&lt;![endif]--&gt;</code></pre><h4 id="Target-IE-8-and-HIGHER（IE8和IE8以上的）"><a href="#Target-IE-8-and-HIGHER（IE8和IE8以上的）" class="headerlink" title="Target IE 8 and HIGHER（IE8和IE8以上的）"></a>Target IE 8 and HIGHER（IE8和IE8以上的）</h4><pre><code>&lt;!-- [if gt IE 7]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie8-and-up.css&quot; /&gt;&lt;![endif]--&gt;&lt;!-- [if gte IE 8]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie8-and-up.css&quot; /&gt;&lt; ![endif]--&gt;</code></pre><h4 id="Universal-IE-6-CSS（通用的IE-6样式）"><a href="#Universal-IE-6-CSS（通用的IE-6样式）" class="headerlink" title="Universal IE 6 CSS（通用的IE 6样式）"></a>Universal IE 6 CSS（通用的IE 6样式）</h4><p>处理IE 6和IE6以下的版本始终是一个超特殊的挑战。老态龙钟的IE6，还保持着高额的市场占有率，还不能彻底的放弃它，不然会有许多的客户抱怨我们。不过也有些人正在放弃对它的支持，包括大企业，大型网络应用，甚至政府。有一个不失落的 ，不放弃的 解决办法，那就是使用一个特精简的样式 universal IE 6 CSS.，然后为IE 7和以上（和所有其他浏览器）的应用常规的CSS。</p><pre><code>&lt;!-- [if !IE 6]&gt;&lt;!--&gt;&lt;!--&lt;![endif]--&gt;&lt;!-- [if gte IE 7]&gt;   &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen, projection&quot; href=&quot;REGULAR-STYLESHEET.css&quot; /&gt;&lt; ![endif]--&gt;&lt;!-- [if lte IE 6]&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen, projection&quot; href=&quot;http://universal-ie6-css.googlecode.com/files/ie6.0.3.css&quot; /&gt;&lt; ![endif]--&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
